# LLMプロンプト設計ガイドライン

プロンプトの設計・改善時に参照する判断基準。

---

## 1. プロンプトに確認項目やヒントを列挙するとき

### 起きやすい問題
- **確認項目を網羅的に列挙すると、列挙外の探索が消失する**: リスト内80%は検出するが、リストに含まれない問題の検出が完全に喪失する（0項目）。意図しないスコープ逸脱も発生（-1.75pt）
- **ヒントが3件以上になると満足化バイアスが発動する**: 具体的な確認項目（例: "Check reconnection strategy, message delivery guarantees"）を列挙すると、その項目に固着し他の問題を見逃す（2件 +2.25pt → 4件 -2.75pt）
- **「このセクションを確認せよ」という指示は逆効果**: セクションの有無確認に依存し、セクション外への探索が消失する（-3.75pt）

### やるべきこと
- ヒントは2件以下にし、具体的な確認項目ではなく思考の方向性を示す表現にする（例: "Consider scalability implications"）
- ドメイン固有のチェック領域は3-4個までに絞る（+2.0〜+3.0pt, 安定性高）。それ以上は満足化バイアスのリスクが増大する
- 技術固有の見落としには条件分岐型のチェック指示を使う（例:「IF TimescaleDB THEN check aggregate refresh strategy」）。汎用的な表現（"database consistency"等）では検出できない
- アンチパターンカタログはドメイン横断で有効（+0.5〜+1.5pt）。ただし定型的な検出に偏り、想定外の問題の多様性が40%減少する

### やってはいけないこと
- 確認項目を網羅的に列挙する（統合チェックリスト）
- 特定セクションの明示的参照を指示する

### 条件依存
- **タスクチェックリスト**: 「何をチェックするか」が明確に列挙できるタスク（明確さ・完全性・有効性の確認等）では有効（+1.15〜+3.64pt）。判断の深さが問われるタスク（汎用性の評価等）ではチェックボックス的な浅い確認に退化し逆効果（-1.04pt）
- **軽量ヒント**: 汎用ドメインでは+2.25pt。ドメインの問題分布が複雑な場合、ヒントがカバーしない領域の探索が減少し逆効果（-0.75pt）

### メカニズム
満足化バイアス: 明示的な構造が「指定項目を完了すれば十分」というシグナルを送り、それ以外の探索的思考を抑制する

---

## 2. 分析の手順や構造をプロンプトで指示するとき

### 起きやすい問題
- **番号付き手順（"Step 1→Step 2→..."）は各ステップの完了で満足し、想定外の発見が大幅に減少する**（-4.5pt）。対象に想定外の問題が多いほど損失が拡大する
- **フェーズ分解（Phase1→Phase2→...）はフェーズ境界で認知リソース配分が固定化し、フェーズをまたぐパターンの認識が断片化する**（結果が不安定）
- **プロセス分解（検出→報告 / Critical→Minor等）は優先度判定が実行ごとに揺れる**（安定性低）

### やるべきこと
- **まず問題を網羅的に検出させ、その後に報告フォーマットへ整形させる**（2ステップに分ける。+2.0〜+2.5pt, 安定性高）。検出と整形を同時にやらせると、整形の都合で重要度の低い項目が早期に切り捨てられる
- 検出フェーズ内は**ドメイン別のカテゴリ分解**（SOLID→API→Error→Test等）を使う（安定性高）。各カテゴリ内で独立した分析が完結するため判断の揺れが発生しない
- **重大度の高い問題から先に検出させる**（+1.5〜+2.0pt, 安定性高）。出力長に制限がある場合に特に有効
- CoTを使う場合は方向性を示す柔軟な表現にする（例: "Think through the design holistically"。+0.25pt）

### やってはいけないこと
- 番号付き手順で分析順序を拘束する
- フェーズ分解で工程を区切る
- 厳格なカテゴリ分類を強制する（カテゴリ間をまたぐ問題を系統的に見逃す。-4.25〜-4.5pt）

### 構造化の指針
構造化の量と性能は**逆U字**の関係にある。カテゴリ分解が系統性と探索性を両立する最適点。過度な構造化よりも、構造をほぼ持たないプロンプト（パースペクティブ定義のみ）の方が高性能になる場合がある（構造なしで検出率102.8%を達成した実績あり）。

### CoT内蔵型推論モデルでの注意点
段階的推論を内蔵するモデル（DeepSeek-R1, OpenAI o1等）に対して明示的なCoT指示を加えても効果は限界的（+2.9-3.1%）で、処理時間が+20-80%増加する。

### メカニズム
満足化バイアス（ステップ完了で十分というシグナル） + 注意バジェット制約（フェーズ境界で認知リソース配分が固定化）

---

## 3. 出力の形式を指定するとき

### 起きやすい問題
- **厳格なフォーマット制約（JSON/XML等）が推論能力を低下させる**: フォーマット遵守に注意リソースが消費されるため、制約が厳しいほど推論の質が劣化する

### やるべきこと
- 推論精度が最優先のタスクでは**2ステップ方式**を使う: まずフォーマット制約なしで自然言語の回答を生成させ、後続のプロンプトまたはパーサーで所定のフォーマットに変換する
- **テーブル/マトリクス構造**（コンポーネント×評価軸）は網羅的なカバレッジを構造的に強制でき有効（+1.24〜+3.0pt, 安定性高）。ただし構造の設計品質により効果差が大きい（同じ手法でもスコア9.93 vs 8.42）

### やってはいけないこと
- 推論と同時に厳格なフォーマット制約を課す

### メカニズム
注意バジェット制約: フォーマット遵守に注意リソースが消費され、推論に使える能力が低下する

---

## 4. 回答例（Few-shot）をプロンプトに含めるとき

### 起きやすい問題
- **複雑なタスクでは2例以上が一貫して逆効果**: 例のテンプレートに注意が偏り、例と異なるパターンの基本的な検出すら低下する。6例で重大問題の検出率が100%→0%に低下（-0.5〜-3.75pt）
- 段階的推論を内蔵するモデル（DeepSeek-R1, OpenAI o1等）でも5-shotでベースライン劣化が確認されている

### やるべきこと
- 複雑なタスク（レビュー、分析、設計評価等）ではFew-shotを0-1例に抑える
- パターン照合が主体の単純タスク（フォーマット変換、分類等）ではFew-shotが有効

### やってはいけないこと
- 複雑なレビュー・分析タスクに2例以上のFew-shotを含める

### メカニズム
満足化バイアス: 例のテンプレートが「この形式・範囲で回答すれば十分」というシグナルを送り、例の範囲外の探索を抑制する

---

## 5. プロンプトの記述言語を決めるとき

### 起きやすい問題
- **日英混合は結果の安定性を大幅に悪化させる**: 日本語カテゴリ名を英語プロンプトに混在させると、該当カテゴリは改善するが他カテゴリが低下し、全体の安定性が約4倍悪化する

### やるべきこと
- **完全英語が最も効果的**（+1.5〜+2.75pt, 安定性高）。LLMの事前学習データにおける技術用語の出現頻度が英語で圧倒的に多いため
- 英語化が難しい場合は**完全日本語**に統一する

### やってはいけないこと
- 一つのプロンプト内で日本語と英語を混在させる（-0.75pt）

### メカニズム
注意バジェット制約: 言語の切替に認知リソースが消費され、本来の分析に使える能力が低下する

---

## 6. 役割（ペルソナ）や動機付けを設定するとき

### 条件依存
- **専門家ペルソナ**: 「何を比較するか」が明確なパターン照合タスク（コーディング規約チェック等）では有効（+3.0pt, 安定性高）。スコープの境界判断が必要な場面では専門領域への過信により視野が狭まり逆効果（-0.75pt）。正確性が問われるタスク全般では効果なし〜劣化
- **感情的刺激（EmotionPrompt）**: タスク遂行の動機付け表現（"This is very important to my career"等）はベンチマーク上有効（BIG-Bench +115%）。ただしポジティブな刺激はユーザーの期待に沿うよう回答を歪める傾向（sycophancy）も増加するため、正確性が重要なタスクでは慎重に使う

---

## 7. 評価基準や対象範囲をプロンプトに含めるとき

### 起きやすい問題
- **Scoring Rubricをプロンプトに含めると「評価モード」に切り替わる**: 問題を能動的に探す探索行動ではなく、既存の記述内容を基準に照らして判定する受動的な行動に退化する（-0.5〜-1.5pt）
- **重み付け採点システムは「存在確認」に退化する**: 項目の有無だけを確認し、部分的にしか対処されていない仕様を肯定的に評価してしまう（-2.5pt）
- **明示的なスコープ境界は境界付近の検出を不安定にする**: 「これはスコープ内か外か」の判断に揺れが生じる。境界を明示しない方がスコープ内で扱える角度を柔軟に探索できる（-4.25pt）

### やるべきこと
- 採点基準は検出フェーズのプロンプトには含めず、別ステップで適用する
- 対象範囲はパースペクティブ（分析の視点・関心領域）で暗黙的に方向付ける。明示的な境界定義ではなく、関心の方向性で自然に絞り込ませる
- 分析中に定量的根拠を明示させる（例: "採用率83% vs 17%"）と、曖昧な検出が明確な検出に引き上げられる

### やってはいけないこと
- 検出用プロンプト内にScoring Rubricを埋め込む
- 明示的なスコープ境界を定義する
- 重み付け採点システムをプロンプトに組み込む

### メカニズム
満足化バイアス: 評価基準の存在が「この基準に沿って判定すれば十分」というシグナルとなり、基準に含まれない問題の探索を抑制する

---

## 8. 検出の網羅性・精度を高めたいとき

### 構造的アプローチ
- **Self-Consistency（多数決）**: 同じプロンプトをN回実行し多数決を取る。Best-of-N（N回中の最高スコアを採用）と比較して4倍効率的。正解が一意に定まるタスク（数式計算、コード構文チェック等）で有効。判断が主観的なタスク（デザイン評価、創造的提案等）では正解が一意でないため多数決が成立せず不適
- **スピルオーバー効果を意図的に活用する**: 概念的に関連する問題を近くに配置すると、一方の検出が他方の検出を促進する（例: JWT保管の検出強化→ログのPIIマスキング検出も改善。「クレデンシャル処理」という概念クラスタ内で注意が波及するため）。マトリクス構造（コンポーネント×評価軸）でこのクラスタリングを意図的に構成できる

### 注意点
- **「存在しない」問題の検出は本質的に困難**: 設定が定義されていない問題（SLA未定義、キャッシュ戦略未定義等）は、誤った設定の検出より難しい。既知パターンのカタログを参照させても、パターンの誤適用は検出できるが基本定義の欠如は見逃しやすい
- **注意バジェットはゼロサム**: 特定領域の検出を強化すると他領域の検出が犠牲になる。特にマトリクスのカテゴリに含まれないフローベースの問題（認証フロー全体の整合性等）が見落とされやすい

### メカニズム
注意バジェット制約: モデルの注意リソースは有限であり、特定領域の強化は他領域とのトレードオフになる。スピルオーバーは概念的に近い問題間でこの制約を緩和する
