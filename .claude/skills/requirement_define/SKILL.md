---
allowed-tools: Glob, Grep, Read, Write, Edit, Task
description: ユーザー要求書から要件定義書を生成するスキル
disable-model-invocation: true
---

ユーザー要求書（`docs/project-definition/problem-statement.md`）を入力として、情報ギャップ分析・システム境界定義・機能要件導出・NFR定量化・インターフェース要件・トレーサビリティ検証を経て、要件定義書（`docs/project-definition/requirements.md`）を生成する。

入力文書のパススルーセクション（問題定義・背景・スコープ等）と導出セクション（機能要件・非機能要件等）を1つの文書に統合する。技術選定や設計判断は扱わない。

## 使い方

```
/requirement_define
```

引数なし。`docs/project-definition/problem-statement.md` を入力として読み込む。

## 出力先

- `docs/project-definition/requirements.md`（固定パス）

## パス変数

- `{skill_dir}`: このファイルが存在するディレクトリの絶対パス
- `{input_path}`: `docs/project-definition/problem-statement.md` の絶対パス
- `{output_path}`: `docs/project-definition/requirements.md` の絶対パス

## コンテキスト節約の原則

1. 参照ファイルは使用する Phase でのみ読み込む（先読みしない）
2. 大量コンテンツの生成はサブエージェントに委譲する（Phase 3, Phase 7）
3. サブエージェントからの返答は最小限にする（詳細はファイルに保存させる）
4. 親コンテキストには要約・メタデータのみ保持する
5. サブエージェント間のデータ受け渡しはファイル経由で行う（親を中継しない）
6. EARS記法ガイド・NFR定量化ガイドは使用 Phase 時のみサブエージェントに渡す
7. 入力ドキュメント全文を親コンテキストに保持しない（Phase 0 で構造サマリのみ保持し、各 Phase で必要セクションのみ参照）

## ワークフロー

Phase 0（初期化・入力検証）→ 1（情報ギャップ分析）→ 2（システム境界定義）→ 3（機能要件導出）→ 4（NFR定量化）→ 5（インターフェース要件）→ 6（トレーサビリティ・最終品質ゲート）→ 7（文書生成・出力）

---

### Phase 0: 初期化・入力検証

```
## Phase 0: 初期化
```

**目的:** 入力ファイルの存在・構造を検証し、以降の Phase で使うメタデータを抽出する

#### Step 1: 入力ファイルの読み込みと検証

1. `{input_path}` = `docs/project-definition/problem-statement.md` を設定する
2. `{output_path}` = `docs/project-definition/requirements.md` を設定する
3. `{input_path}` を Read する。不在の場合はエラー出力して終了:
   「`docs/project-definition/problem-statement.md` が見つかりません。先に `/requirement_elicit` を実行してください」
4. ステータスが `Confirmed` であることを確認する。`Draft` の場合:
   「ステータスが Draft です。`/requirement_elicit` で確定してから実行してください」と出力して終了

#### Step 2: 構造サマリの抽出

入力ファイルから以下のメタデータを抽出し、親コンテキストに保持する（全文は保持しない）:

- `{title}`: ドキュメントのタイトル（H1 見出し）
- `{uc_list}`: ユースケース一覧（UC-N, シナリオ名, 優先度, 種別）のテーブル
- `{stakeholders}`: ステークホルダー一覧
- `{constraints}`: 制約一覧
- `{nfr_list}`: 非機能要求一覧（観点, 懸念・制約）
- `{scope_must}`: Must スコープ項目
- `{scope_excluded}`: スコープ外項目
- `{unresolved}`: 未解決事項

#### Step 3: 入力品質の事前チェック

以下を検証し、問題があればユーザーに提示する:

- ユースケースが0件の場合: 「ユースケースが定義されていません。`/requirement_elicit` を再実行してください」と出力して終了
- Must ユースケースが0件の場合: 警告を提示し続行するか確認
- 未解決事項に技術選定関連の項目が含まれる場合: 「未解決事項に技術選定が含まれています。要件は技術非依存で導出しますが、一部の要件は技術選定後に見直しが必要になる可能性があります」と注意を提示

テキスト出力:
```
## Phase 0 完了
- 入力: {input_path}
- UC数: {N}件 (Must: {M}, Nice: {K})
- ステークホルダー: {N}名
- 制約: {N}件
- NFR: {N}件
- 未解決事項: {N}件

Phase 1（情報ギャップ分析）に進みます。
```

---

### Phase 1: 情報ギャップ分析

```
## Phase 1: 情報ギャップ分析
```

**目的:** アーキテクチャ設計に必要な情報が入力文書に含まれているか検証し、不足を補完する

#### Step 1: チェックリスト評価

`{skill_dir}/references/gap-analysis-checklist.md` を Read し、Phase 0 の `{uc_list}`, `{constraints}`, `{nfr_list}`, `{scope_must}`, `{scope_excluded}` を基に、7カテゴリのチェック項目を入力文書に照合する。

各項目を以下に分類する:
- **Resolved**: 入力文書に明示的記述あり（該当箇所を引用）
- **Inferable**: 文脈から合理的に推定可能（推定内容と根拠を記録）
- **Gap**: 記載なし、推定も困難（ユーザーに質問が必要）

#### Step 2: Gap項目の解決

Gap 項目をper-item形式でユーザーに提示する:

```
### 情報ギャップ [{N}/{total}]
**カテゴリ: {category}**
- **不足情報**: {what is missing}
- **影響**: {Phase N の {section} に影響}
- **補足質問**: {specific question}

回答をお願いします。（不明な場合は「未定」と回答してください）
```

- 回答あり: `{gap_resolutions}` に記録
- 「未定」: `{deferred_gaps}` に記録（Section 12 に追加される）

#### Step 3: Inferable項目の確認

推定した前提をまとめてユーザーに確認する:

```
### 推定した前提（確認）

以下の情報は入力文書から推定しました。問題があれば修正してください。

| # | 推定内容 | 根拠 | 影響先 |
|---|---------|------|--------|
| 1 | {inference} | {source passage} | Phase {N} |

修正があればお知らせください。問題なければ「ok」と回答してください。
```

- 承認: Step 4 へ
- 修正指示: 修正を反映して再提示

#### Step 4: 結果の記録

以下を親コンテキストに保持する:
- `{gap_resolutions}`: 解決済みのQ&Aリスト（コンパクトなテキスト）
- `{deferred_gaps}`: 保留された未解決ギャップ（Section 12 に追加される）

テキスト出力:
```
## Phase 1 完了
- Resolved: {N}件（入力文書に記述あり）
- Inferable: {N}件（推定・確認済み）
- Gap解決: {N}件（ユーザー回答で補完）
- 保留: {N}件（未解決事項に追加）

Phase 2（システム境界定義）に進みます。
```

---

### Phase 2: システム境界定義

```
## Phase 2: システム境界定義
```

**目的:** システムの境界（アクター、外部システム、インターフェースポイント）を明確化する

#### Step 1: アクターと外部インターフェースの抽出

Phase 0 の `{stakeholders}`, `{uc_list}`, `{constraints}` と Phase 1 の `{gap_resolutions}` を基に、AIが以下を導出してテキスト出力する:

```
### アクター一覧（仮説）

| ID | アクター | 種別 | 概要 |
|----|---------|------|------|
| ACT-1 | {アクター名} | 人間/外部システム | {このアクターの役割} |

### 外部インターフェース（仮説）

| ID | インターフェース | 接続先 | 方向 | 概要 |
|----|-----------------|--------|------|------|
| IF-1 | {インターフェース名} | {接続先アクター/システム} | 入力/出力/双方向 | {データや操作の概要} |

修正があればお知らせください。問題なければ「ok」と回答してください。
```

- 承認: Step 2 へ
- 修正指示: 修正を反映して再提示

#### Step 2: システム境界記述の確定

Step 1 の確定結果を基に、テキスト形式のシステム境界記述を生成する:

```
### システム境界（確定）

**システム名**: {title から導出}
**スコープ**: {scope_must を基にシステムが提供する機能群の一文要約}

**内部（システムが担う範囲）**:
- {システム内部の機能/責務1}
- {システム内部の機能/責務2}

**外部（システムが担わない範囲）**:
- {外部アクター/システムの責務}
- {scope_excluded から導出}

修正があればお知らせください。問題なければ「ok」と回答してください。
```

#### Step 3: 品質ゲート（反早期設計ゲート）

Step 1-2 の確定内容を以下の基準で検証する:

**検出対象:**
- 具体的な技術名・製品名（例: 「PostgreSQL」「REST API」「React」）
- システムの内部実装メカニズム（例: 「キャッシュ」「非同期処理」「マイクロサービス」）
- プラットフォーム固有の表現（例: 「Androidの共有インテント」「iOS の Push 通知」）

**例外:** 入力ドキュメントの制約セクションに明記されている技術名は、制約由来のものとして許容する。

問題がなければ Phase 3 へ進む。

問題がある場合、各項目を個別にテキスト出力する:
```
### 設計混入の検出 [{N}/{total}]
- **箇所**: 「{該当箇所}」
- **問題**: {なぜ設計に踏み込んでいるか}
- **修正案**: 「{修正後}」

この修正を反映しますか？
```

ユーザーの応答を待ち、全項目の処理後に Phase 3 へ。

---

### Phase 3: 機能要件導出（UC → SR 分解）

```
## Phase 3: 機能要件導出
```

**目的:** Must ユースケースから機能要件（SR）を導出する。EARS記法で記述し、検証可能な形式にする。Nice ユースケース（スコープ外）は導出対象外

#### Step 1: SR導出（サブエージェントに委譲）

`Task` ツールで以下を実行する（`subagent_type: "general-purpose"`, `model: "sonnet"`）:

```
`{skill_dir}/templates/phase3-derive-sr.md` を Read で読み込み、その内容に従って処理を実行してください。

パス変数:
- `{input_path}`: {入力ファイルの絶対パス}
- `{ears_guide_path}`: {skill_dir}/references/ears-notation-guide.md の絶対パス
- `{actors_and_interfaces}`: {Phase 2 で確定したアクター/インターフェースのテキスト}
- `{gap_resolutions}`: {Phase 1 で解決した情報ギャップのQ&Aリスト}
- `{sr_save_path}`: docs/project-definition/requirements-draft-sr.md の絶対パス
```

サブエージェントの返答: `total_sr` + `uc_coverage_summary` + `ears_patterns_used` のみ

#### Step 2: SR一覧のレビュー

サブエージェントが保存した `docs/project-definition/requirements-draft-sr.md` を Read し、ユーザーに SR 一覧を UC ごとにグルーピングして提示する:

```
### Phase 3 SR一覧（仮説）

#### {UC-ID}: {シナリオ名} から導出

| SR-ID | 要件 | EARS型 | トレース元 |
|-------|------|--------|-----------|
| SR-001 | {EARS記法の要件文} | {Event-Driven/State-Driven/etc.} | {UC-ID} |

...（全Must UC分）

修正・追加・削除があればお知らせください。問題なければ「ok」と回答してください。
```

- 承認: Step 3 へ
- 修正指示: 修正をドラフトファイルに Edit で反映して再提示

#### Step 3: 品質ゲート（テスト可能性ゲート + 反早期設計ゲート）

全 SR を以下の基準で検証する:

**テスト可能性チェック:**
- 禁止用語の検出: 「速い」「簡単」「使いやすい」「サポートする」「適切な」「十分な」「一般的な」「柔軟な」「管理する」「処理する」
- 各 SR に対して「この SR の合否を判定するテストは構想可能か」をAIが評価する
- 1つの SR に複数の独立した関心事が含まれている場合は分割を提案する

**反早期設計チェック:**
- Phase 2 Step 3 と同じ検出対象を適用する（技術名、内部メカニズム、プラットフォーム固有表現）
- 制約由来の技術名は許容する

違反がある場合、各項目を個別にテキスト出力する:

```
### [{N}/{total}] SR-{ID}: {問題の種類}
- **問題**: 「{該当箇所}」は{具体的な問題の説明}
- **リスク**: {このまま残した場合の影響}
- **重要度**: {高/中}
- **修正案**: 「{修正後のEARS文}」
  （テスト例: {具体的なテスト構想}）

対応しますか？
```

ユーザーの応答を待ち、全項目の処理後に Phase 4 へ。

---

### Phase 4: NFR定量化

```
## Phase 4: NFR定量化
```

**目的:** ユーザー要求書の定性的なNFRを、測定可能な基準に変換する

#### Step 1: NFR定量化ガイドの読み込み

`{skill_dir}/references/nfr-quantification-guide.md` を Read する。

#### Step 2: NFR定量化の提示と合意

Phase 0 の `{nfr_list}` と `{constraints}` を基に、ガイドを参照しながらAIが定量化案を生成する。Phase 1 の `{gap_resolutions}` に NFR測定精度やデータ量に関する回答がある場合、それを反映する。

各NFR項目を個別にテキスト出力し、ユーザーの応答を待つ:

```
### NFR-{ID}: {観点}
- **元の記述**: 「{定性的記述}」
- **定量化案**: {定量的な基準}
- **導出根拠**: {なぜこの値/基準にしたか}
- **測定方法**: {どうやって測定するか}

この定量化でよいですか？
```

ユーザーが具体的な数値を持たない場合、松竹梅方式で候補を提示する（Phase 1 で既に回答済みの項目はスキップ）:
```
{観点}について、以下のどのレベルを目標としますか？
- A: {控えめな基準}（{トレードオフ}）
- B: {標準的な基準}（{トレードオフ}）
- C: {高い基準}（{トレードオフ}）
```

#### Step 3: 品質ゲート（定量化完了チェック）

全NFRを以下の基準で検証する:

- 全NFR項目に測定可能な基準があるか（「速い」「安全」等の曖昧表現が残っていないか）
- 各NFRに導出根拠が記載されているか
- 各NFRに測定方法が記載されているか
- FURPS+カテゴリの網羅確認（機能性/ユーザビリティ/信頼性/性能/保守性 + 制約）
  - 入力ドキュメントに記載がないカテゴリについて、対応が必要か確認する
- 「該当なし」の項目にもその判断理由があるか

問題がある場合、各項目を個別にテキスト出力する:

```
### NFR品質: {問題の説明}
- **問題**: {具体的な問題}
- **重要度**: {高/中}
- **修正案**: {提案}

対応しますか？
```

全項目の処理後に Phase 5 へ。

---

### Phase 5: インターフェース要件

```
## Phase 5: インターフェース要件
```

**目的:** インターフェース要件を整理し、全要件間の整合性を検証する

#### Step 1: インターフェース要件の導出

Phase 2 の外部インターフェース一覧から、各インターフェースの要件を導出してテキスト出力する:

```
### インターフェース要件（仮説）

| IR-ID | インターフェース | 要件 | トレース元 |
|-------|-----------------|------|-----------|
| IR-001 | IF-1: {名前} | {インターフェースに対する要件} | IF-1, {関連UC} |

修正があればお知らせください。問題なければ「ok」と回答してください。
```

- 承認: Step 2 へ
- 修正指示: 修正を反映して再提示

#### Step 2: 品質ゲート（整合性ゲート）

Phase 3-5 で導出した全要件（SR, NFR, IR）と Phase 0 の `{constraints}` の整合性を検証する:

**検出対象:**
- SR と NFR の矛盾（例: SR が大量データ保存を要求、NFR がストレージ最小化を要求）
- SR と制約の矛盾（例: SR が有料サービスの利用を前提、制約が「無償運用」）
- 異なる SR 間の矛盾（例: SR-A が排他的操作を要求、SR-B が同時操作を要求）
- NFR と制約の矛盾（例: 高可用性 NFR と低コスト制約）

矛盾がある場合、各項目を個別にテキスト出力する:

```
### 矛盾の検出 [{N}/{total}]
- **対象**: {要件ID-A} vs {要件ID-B または 制約: {制約名}}
- **矛盾**: {矛盾の説明}
- **リスク**: {このまま残した場合の影響}
- **解決案**: {提案}

どう解決しますか？
```

全項目の処理後に Phase 6 へ。

---

### Phase 6: トレーサビリティ・最終品質ゲート

```
## Phase 6: トレーサビリティ検証
```

**目的:** 全要件の網羅性・一貫性・検証可能性を最終確認する

#### Step 1: 網羅性チェック（完全性ゲート）

Phase 3-5 の全要件を基に以下を検証する:

1. **UC網羅**: 全 Must UC がいずれかの SR にトレースされているか
2. **エラーパス網羅**: 異常系・エッジケースの UC に対応する SR が存在するか
3. **NFR網羅**: 全 NFR 観点がいずれかの NFR 要件として定量化されているか
4. **孤立SR検出**: トレース元が空の SR が存在しないか（全 SR に UC-N または「—」が設定されていること）

```
### 網羅性チェック結果

- UC網羅: {M}/{N} Must UC カバー済み
  - 未カバー: {UC-ID リスト、または「なし」}
- エラーパス: {M}/{N} 異常系UC カバー済み
  - 未カバー: {UC-ID リスト、または「なし」}
- NFR網羅: {M}/{N} NFR 定量化済み
  - 未対応: {NFR 観点リスト、または「なし」}
- 孤立SR: {リスト、または「なし」}
```

未カバー項目がある場合、各項目を個別にテキスト出力する:

```
### 未カバー: {UC/NFR ID} ({名前})
- **問題**: {何がカバーされていないか}
- **リスク**: {このまま残した場合の影響}
- **重要度**: {高/中}
- **対応案**: {SR追加案 or 意図的除外の確認}

対応しますか？ (対応する / スキップ / 別の対応を指示)
```

孤立SRがある場合:
```
### 孤立SR: SR-{ID}
- **問題**: この SR はどの UC にもトレースされていません（ゴールドプレーティングの可能性）
- **対応案**: 削除 / トレース元を追加

対応しますか？
```

#### Step 2: 用語一貫性チェック

導出セクション（Phase 3-5 の結果）でテーブルヘッダーや見出しに「要求」が混在していないか確認する。「要件」に統一されていること。

#### Step 3: 最終品質サマリ

```
### Phase 6 品質サマリ

| ゲート | 結果 | 詳細 |
|--------|------|------|
| 反早期設計 | PASS/FAIL | 技術名混入: {N}件 |
| テスト可能性 | PASS/FAIL | 曖昧なSR: {N}件 |
| 整合性 | PASS/FAIL | 矛盾: {N}件 |
| 完全性 | PASS/FAIL | 未カバーUC: {N}件, 未カバーNFR: {N}件 |
| 用語一貫性 | PASS/FAIL | 「要求」混在: {N}件 |

全ゲート PASS の場合: 「Phase 7 に進みます。」
FAIL がある場合: 「上記の未解決項目を対応してから Phase 7 に進みますか？」
```

---

### Phase 7: 文書生成・出力

```
## Phase 7: 文書生成
```

**目的:** Phase 1-6 の確定結果と入力ユーザー要求書の内容を統合して最終ドキュメントを出力する

#### Step 1: 文書生成（サブエージェントに委譲）

`Task` ツールで以下を実行する（`subagent_type: "general-purpose"`, `model: "sonnet"`）:

```
`{skill_dir}/templates/phase7-generate-document.md` を Read で読み込み、その内容に従って処理を実行してください。

パス変数:
- `{input_path}`: {入力ファイルの絶対パス}
- `{template_path}`: {skill_dir}/references/output-template.md の絶対パス
- `{sr_draft_path}`: docs/project-definition/requirements-draft-sr.md の絶対パス
- `{output_save_path}`: {出力ファイルの絶対パス}
- `{actors_and_interfaces}`: {Phase 2 確定結果のテキスト}
- `{nfr_quantified}`: {Phase 4 確定結果のテキスト}
- `{interface_requirements}`: {Phase 5 確定結果のテキスト}
- `{gap_resolutions}`: {Phase 1 ギャップ解決結果のテキスト}
- `{deferred_gaps}`: {Phase 1 保留ギャップのテキスト}
```

サブエージェントの返答: `result` + `total_requirements` + `sections_completed` のみ

#### Step 2: ユーザー確認

生成されたドキュメントを Read し、ユーザーにテキスト出力する:
「修正があればお知らせください。問題なければ『ok』と回答してください。」

- 修正指示あり: 内容を Edit で修正して再提示
- 承認: Step 3 へ

#### Step 3: 出力処理

`{output_path}` の存在を確認する。

**存在しない場合:**
- Step 1 で既に Write 済みのため確認のみ

**存在する場合:**
1. 既存ファイルを Read する
2. 変更点をテキスト出力する:
   ```
   ## 既存ファイルとの差分

   ### 追加された内容
   - {追加されたセクションや項目}

   ### 変更された内容
   - {変更前} → {変更後}

   ### 削除された内容
   - {削除されたセクションや項目}

   上書きしてよいですか？
   ```
3. ユーザーが承認したら `{output_path}` に Write で上書きする

#### Step 4: クリーンアップ

ドラフトファイル `docs/project-definition/requirements-draft-sr.md` を削除する。

#### Step 5: 完了

```
## requirement_define 完了
- 入力: {input_path}
- 出力: {output_path}
- セクション: 12 + 付録
- 要件数: SR {N}件, NFR {N}件, IR {N}件
- 品質ゲート: 全 PASS

次のステップ: `/arch_design` でアーキテクチャ設計に進んでください。
```
