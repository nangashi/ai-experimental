以下の手順でコードベース調査・ADRチェック・設計ドキュメント生成を行ってください:

## 手順

### 1. 要件の把握

{requirements_path} を Read で読み込み、以下を把握する:
- 機能要件（具体的な振る舞い）
- 非機能要件（制約）
- スコープ（対象/対象外）
- 前提条件・制約
- 受け入れ基準

### 2. コードベース調査

要件に基づき、以下を調査する:

1. **影響を受けるファイル/コンポーネントの特定**:
   - 機能要件とスコープから関連しそうなディレクトリ・ファイルを Glob で探索する
   - キーワード（クラス名、関数名、設定キー等）を Grep で検索する
   - 主要なファイルを Read で読み込み、構造と責務を把握する

2. **既存の実装パターンの分析**:
   - 命名規約（変数/関数/ファイル名のケーススタイル）
   - エラーハンドリングパターン
   - テストの構造と配置規約
   - 依存関係の管理方法

3. **関連する既存テストの特定**:
   - 変更対象コンポーネントのテストファイルを Glob/Grep で特定する
   - テストの種別（ユニット/統合/E2E）と対象範囲を把握する

4. **技術的制約の確認**:
   - 設定ファイル（package.json, tsconfig.json 等）から技術スタックを確認する
   - 要件と既存コードベースの間に矛盾がないか確認する

**矛盾を検出した場合**: 以下のフォーマットで返答し、処理を中断する:
```
result: constraint_conflict
conflict: {矛盾の詳細説明}
affected_requirements: {影響を受ける要件番号}
```

### 3. ADRチェック

1. {adr_dir} を Glob で確認する（ディレクトリが存在しない場合は新規ADRの検討のみ行う）
2. 既存ADRファイルがある場合は Read で内容を確認する
3. 設計に必要な技術・アーキテクチャ要素を洗い出す（例: フレームワーク選定、認証方式、データベース設計、API設計方針）
4. 各要素を既存ADRと突合する:
   - **accepted で存在**: 設計にADR参照を記載する
   - **矛盾する既存ADR**: 以下のフォーマットで返答し、処理を中断する:
     ```
     result: adr_conflict
     conflicting_adr: {矛盾するADRファイル名}
     conflict: {矛盾の詳細説明}
     ```
   - **存在しない重要な技術判断**: 手順4でADRを新規作成する

### 4. ADR作成（必要な場合のみ）

ADRは**重要なアーキテクチャ/技術判断**にのみ作成する。軽微な実装選択には不要。

1. {adr_dir} が存在しない場合、Bash で `mkdir -p {adr_dir}` を実行する
2. 既存ADRファイルから最大番号を取得し、+1 で新規番号を決定する（なければ 0001）
3. 以下のテンプレートで `{adr_dir}/NNNN-title.md` を Write で保存する:

```markdown
# ADR-NNNN: {決定事項}

## ステータス

proposed

## 日付

{今日の日付 YYYY-MM-DD}

## コンテキスト

{この決定が必要になった背景。関連Issue: #{issue_number}}

## 選択肢

### 1. {選択肢A}

{説明、メリット・デメリット}

### 2. {選択肢B}

{説明、メリット・デメリット}

## 決定

{推奨する選択肢とその理由}

## 影響

{この決定が影響を与える範囲}
```

ADRのステータスは常に `proposed` とする（マージ時に accepted に変更される前提）。

### 5. design.md の生成

調査結果とADR情報を基に、以下のテンプレートに従って {design_save_path} に Write で保存する:

```markdown
# 設計: #{issue_number} {issue_title}

## 概要

{設計の1-2文サマリ}

## アーキテクチャ決定

{主要な技術選定・パターン選択とその理由。ADRがある場合はリンク}

## 詳細設計

### コンポーネント構成

{新規/変更コンポーネントとその責務}

### データモデル

{テーブル/スキーマ変更。該当なしの場合は「変更なし」}

### API/インターフェース

{エンドポイント/関数シグネチャの変更。該当なしの場合は「変更なし」}

### 処理フロー

{主要な処理の流れ。mermaidシーケンス図等を適宜使用}

## 実装ステップ

{順序付きリスト。各ステップに変更対象ファイルと変更内容を含む。issue_implement Phase 1 がこのセクションを入力として使用する}

1. {ステップ1}: `{変更ファイル}` — {変更内容}
2. {ステップ2}: `{変更ファイル}` — {変更内容}

## テスト戦略

{テスト種別（ユニット/統合/E2E）ごとの方針。新規テスト・既存テスト修正の対象}

## 影響範囲

{変更による既存機能への影響。影響なしの場合は「なし」}
```

### 記載ルール

- **実装ステップは必須**。各ステップに変更対象ファイルと変更内容を含めること。このセクションが issue_implement の入力となる
- **該当なしのセクション**は「変更なし」「なし」等を明記し、セクション自体は省略しない
- **ADR**がある場合は「アーキテクチャ決定」セクションからリンクする
- **既存パターンとの整合性**を重視する。調査で把握した命名規約・構造を設計に反映する

### 6. 返答

以下のフォーマットで返答する:

```
result: success
summary: {設計の1行サマリ}
components_changed: {変更コンポーネント数}
new_adrs: {作成したADRファイル名リスト（なければ "なし"）}
implementation_steps: {実装ステップ数}
test_strategy: {テスト種別リスト（例: unit, integration）}
```
