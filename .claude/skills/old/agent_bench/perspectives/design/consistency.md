# 観点定義: 一貫性（設計レビュー）

## 概要
設計書が既存のコードベースのパターンや規約と整合しているかを評価する。この観点は「パターンが良いか悪いか」ではなく「既存と合っているか」を評価する。既存コードベースが一貫してアンチパターンを使用している場合でも、新しい設計が同じパターンに従っていれば「一貫している」と判定する。設計書に既存パターンとの一貫性を判定するための情報が欠落している場合も、一貫性が検証不能な項目として検出する。

## 評価スコープ

### 共通指針: 既存パターンの調査方法と一致判定基準
関連する既存モジュール（同一レイヤー、同一ドメイン）のパターンを優先的に参照し、コードベース全体の傾向で補完する。

**支配的パターンの定義**: 「支配的パターン」とは、関連モジュールで一貫して採用されているパターンを指す。目安として、関連モジュールの70%以上、またはコードベース全体の50%以上が採用しているパターンが該当する。

**一致の判断基準**: 命名規則では大文字小文字・区切り文字（camelCase/snake_case/kebab-case）の違いも不一致とみなす。アーキテクチャパターンでは実装方式の種類（例: エラーハンドリングがグローバルハンドラか個別catchか）が一致すれば一致とみなす。ディレクトリ構造では配置ルール（例: ドメイン別/レイヤー別）が一致すれば一致とみなす。

この指針は以下の全評価項目に適用される。

- 命名規約の既存パターンとの一致（変数名、関数名、クラス名、ファイル名、データモデル（テーブル名、カラム名）の命名パターンが既存コードベースに合っているか、およびこれらの命名規則が設計書に明記されているか）
- 既存アーキテクチャパターンとの一致（レイヤー構成、依存方向、責務分離が既存の実装方式と一致しているか、およびアーキテクチャ設計方針が設計書に明記されているか）
- 実装パターンの既存パターンとの一致（エラー処理パターン（グローバルハンドラ/個別catch等）、認証・認可の実装パターン（middleware/decorator/manual等）、データアクセスパターン（Repository/ORM直接呼び出し等）およびトランザクション管理パターン、非同期処理パターン（async/await/Promise/callback等）、ログ出力パターン（ログレベル、メッセージ形式、構造化ログの有無）が既存方式に合っているか、およびこれらのパターン方針が設計書に明記されているか）
- ディレクトリ構造・ファイル配置の既存パターンとの一致（既存の配置規則やフォルダ構成に合っているか、およびファイル配置方針が設計書に明記されているか）
- API/インターフェース設計・依存関係の既存パターンとの一致（既存APIのエンドポイント命名、レスポンス形式、エラー形式と一致しているか、既存のライブラリ選定基準、バージョン管理方針、パッケージマネージャの使い方、設定ファイル形式（YAML/JSON等）、環境変数命名規則に合っているか、およびこれらの設計方針が設計書に明記されているか）

## スコープ外
- セキュリティ脆弱性 → security で扱う
- パフォーマンスの問題 → performance で扱う
- 設計原則（SOLID等）の遵守、テスト設計の十分性 → structural-quality で扱う

## ボーナス/ペナルティの判定指針
- **ボーナス対象**: 設計書が既存の支配的パターンから逸脱しているが正解キーに含まれない不整合の検出（例: 「既存APIは全て kebab-case だが新API設計は camelCase を使用」）
- **ペナルティ対象**: セキュリティやパフォーマンスの指摘（一貫性に無関係）、既存パターンの良し悪しを評価する指摘（例: 「既存の命名規則がわかりにくい」）
- **判断に迷うケース1**: 既存パターン自体に問題がある場合の「改善提案」→ 一貫性の観点では既存パターンとの不整合の検出に留め、改善提案は structural-quality に委ねる
- **判断に迷うケース2**: API設計がRESTful原則に反する → structural-quality のスコープ（設計原則の遵守）、API命名が既存エンドポイントと不統一 → consistency のスコープ（既存との一致）
- **判断に迷うケース3**: レイヤー間の依存方向が一般的なベストプラクティスと異なる → structural-quality のスコープ、既存コードベースの依存方向と異なる → consistency のスコープ

## 問題バンク

以下は埋め込み可能な問題のカテゴリと例。実際の埋め込み時はこれらを参考にしつつ、テスト対象文書の文脈に合った具体的な問題を作成する。

| カテゴリ | 問題例 | 深刻度 |
|---------|--------|-------|
| アーキテクチャ | レイヤーの依存方向が既存設計と逆転（既存はController→Service→Repositoryだが新設計はService→Controller） | 重大 |
| 実装パターン（情報欠落） | エラーハンドリングの方針が設計書に明記されておらず、既存パターンとの一貫性が検証できない | 重大 |
| 実装パターン（情報欠落） | データアクセスパターンおよびトランザクション管理の方針が設計書に明記されておらず、既存パターンとの一貫性が検証できない | 重大 |
| 命名 | 命名規則が既存と混在（例: 既存APIは kebab-case だが新設計は camelCase、既存テーブルは複数形だが新設計は単数形） | 中 |
| API設計 | レスポンス形式が既存APIと統一されていない（既存は `{data, error}` だが新設計は `{result, message}`） | 中 |
| 依存管理 | 既存で使用中のライブラリと同機能の別ライブラリを新たに導入（既存は axios だが新設計は fetch） | 中 |
| API設計（情報欠落） | API命名規則・レスポンス形式が設計書に明記されておらず、既存パターンとの一貫性が検証できない | 中 |
| ディレクトリ構造 | ファイル配置ルールが既存と異なる（既存はドメイン別フォルダ構成だが新設計はレイヤー別構成） | 軽微 |
| 実装パターン | ログ出力パターンが既存と異なる（既存は構造化ログ（JSON）だが新設計は平文） | 軽微 |
| 設定管理 | 環境変数の命名規則が既存と異なる（既存は全て大文字スネークケースだが新設計は camelCase） | 軽微 |
