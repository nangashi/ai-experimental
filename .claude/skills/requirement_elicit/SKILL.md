---
allowed-tools: Glob, Grep, Read, Write, Edit, Task
description: ユーザー要求をAI主導の対話で深掘りし、構造化された要求定義書を生成するスキル
disable-model-invocation: true
---

ユーザーの曖昧な要求をAI主導の対話で深掘りし、6カテゴリ（問題の本質・背景・代替手段・ユースケース・スコープ・成功基準）を網羅したユーザー要求書を生成する。

ユーザーの「何を・なぜ・誰が」を明確にすることに特化する。具体的な実装要件（NFRの数値、技術的トレードオフ、詳細フロー設計等）は扱わない。

## 使い方

```
/requirement_elicit
```

引数なし。対話形式で要求を深掘りする。

## 出力先

- `docs/project-definition/problem-statement.md`（固定パス）

## パス変数

- `{skill_dir}`: このファイルが存在するディレクトリの絶対パス
- `{output_path}`: `docs/project-definition/problem-statement.md` の絶対パス

## ワークフロー

Phase 0（初期化）→ 1（問題の本質）→ 2（背景）→ 3（代替手段）→ 4（ユースケース）→ 5（スコープ）→ 6（成功基準）→ 7（文書生成・出力）

---

### Phase 0: 初期化

```
## Phase 0: 初期化
```

1. `{output_path}` = `docs/project-definition/problem-statement.md` を設定する
2. ユーザーに以下を質問し、応答を待つ:
   「何を実現したいですか？思いついたレベルで構いません。」

---

### Phase 1: 問題の本質（What & Why）

```
## Phase 1: 問題の本質
```

**目的:** ユーザーが語る「解決策」の裏にある本当の問題を特定する

#### Step 1: 問題への転換

Phase 0 の回答を分析する:
- 回答が「解決策」寄り（「〜機能がほしい」「〜したい」）の場合:
  「それによって、どんな問題や不便が解消されますか？」と質問する
- 回答が「問題」寄り（「〜できなくて困っている」「〜が不便」）の場合:
  このステップはスキップする

#### Step 2: トリガーと影響

以下を質問する:
- 「なぜ今これが必要になりましたか？何がきっかけですか？」
- 「この問題で困っているのは誰ですか？どのくらいの頻度で困っていますか？」

#### Step 3: ゴール状態

以下を質問する:
- 「これが完璧に解決したら、何が変わりますか？」

#### Step 4: 仮説サマリ

Step 1〜3 の回答を基に、問題の本質を仮説として以下の形式で提示する:

```
### Phase 1 サマリ（仮説）
- **問題**: {問題の一文要約}
- **トリガー**: {なぜ今か}
- **影響範囲**: {誰が、どのくらいの頻度で}
- **ゴール**: {解決後の状態}

修正があればお知らせください。問題なければ「ok」と回答してください。
```

- 承認: Phase 2 へ
- 修正指示: 修正を反映してサマリを再提示

---

### Phase 2: 背景・コンテキスト

```
## Phase 2: 背景
```

**目的:** 暗黙の前提と制約を明示化する

#### Step 1: 現状把握

以下を質問する:
- 「今はどうやって対処していますか？」

回答が「何もしていない（新規）」の場合、Step 2 はスキップする。

#### Step 2: 現状の評価と過去の試行

Step 1 で既存の対処法がある場合のみ:
- 「今のやり方で、うまくいっている部分・いっていない部分は何ですか？」
- 「以前に同じ問題を解決しようとしたことはありますか？結果はどうでしたか？」

#### Step 3: 制約の発掘

以下を質問する:
- 「変えられないもの（環境・期間・チーム体制・予算など）はありますか？」
- 「関わる人や部署で、立場や利害が異なるケースはありますか？」

Phase 1 の情報から推測できる制約がある場合は、AIが仮説として提示する:
「Phase 1 の内容から、以下の制約があるように見えます。合っていますか？」

#### Step 4: 仮説サマリ

```
### Phase 2 サマリ（仮説）
- **現状**: {現状の対処法、またはなし}
- **過去の試行**: {過去の試みと結果、またはなし}
- **ステークホルダー**: {関係者一覧}
- **制約**: {制約一覧}

修正があればお知らせください。問題なければ「ok」と回答してください。
```

---

### Phase 3: 代替手段の検討

```
## Phase 3: 代替手段
```

**目的:** 最善のアプローチを選択する（「やらない」も含めて）

#### Step 1: 代替案の提示

Phase 1〜2 の情報を基に、AIが概念レベルで2-3個の代替案を生成して提示する。
技術的なトレードオフには踏み込まず、「何をするか」の方向性レベルで比較する。

```
以下のアプローチが考えられます:

1. {案1}: {概要}
2. {案2}: {概要}
3. {案3}: {概要}

これらについてどう思いますか？他に検討したいアプローチはありますか？
```

#### Step 2: 「やらない」選択肢の検討

必ず以下を質問する（ユーザーがどの代替案を好んでいても省略しない）:
- 「もしこれを作らなかったら、どうなりますか？」
- 「既存のツールやサービスで代替できる部分はありませんか？」

#### Step 3: 方向性の確定

各代替案の概要比較を提示し、方向性を確定する:
- 「どの方向で進めますか？理由も教えてください。」

#### Step 4: 仮説サマリ

```
### Phase 3 サマリ（仮説）
- **検討した代替案**:
  1. {案1}: {概要} → {採用/不採用: 理由}
  2. {案2}: {概要} → {採用/不採用: 理由}
  3. やらない → {帰結}
- **採用アプローチ**: {選定した案と理由}

修正があればお知らせください。問題なければ「ok」と回答してください。
```

---

### Phase 4: ユーザー体験・ユースケース

```
## Phase 4: ユースケース
```

**目的:** 具体的な利用場面を網羅し、抜け漏れを防ぐ

#### Step 1: ユースケース案の提示

Phase 1〜3 で確定した情報（問題定義・ステークホルダー・採用アプローチ）を基に、AIがユースケース案とユーザー種別を生成して提示する。

```
Phase 1〜3 の内容から、以下のユースケースとユーザー種別を想定しました。

**ユーザー種別:**
- {ペルソナ1}: {特徴}
- {ペルソナ2}: {特徴}

**ユースケース案:**
| # | シナリオ | 種別 | 概要 |
|---|---------|------|------|
| UC-1 | {名前} | 基本 | {一文で概要} |
| UC-2 | {名前} | 基本 | {一文で概要} |
| UC-3 | {名前} | 異常系 | {一文で概要} |

追加・削除・修正はありますか？
```

ユーザーの回答に基づきユースケース一覧を更新する。

#### Step 2: エッジケースの発掘

Step 1 のユースケース一覧を基に、AIが以下の観点からエッジケースを2-3個ずつ列挙して確認する。
一度に全部提示せず、関連性の高いものから段階的に提示する。

**観点:**
- 初回利用 vs 継続利用
- データが存在しない / 不正 / 大量の場合
- 権限が異なるユーザー
- 操作の取り消し・やり直し
- 外部サービスの障害・遅延

```
以下のケースはどうなりますか？

1. {ケース1の質問}
2. {ケース2の質問}
3. {ケース3の質問}
```

ユーザーの回答後、さらに確認が必要なケースがあれば追加で質問する。

#### Step 3: 網羅性チェック

Phase 1〜3 で確定した情報と現在のユースケース一覧をクロスリファレンスし、カバーされていない領域をAIが指摘する。

**チェック観点:**
- Phase 1 のゴール状態を達成するためのユースケースが揃っているか
- Phase 2 のステークホルダー全員の利用場面がカバーされているか
- Phase 2 の制約に触れるユースケース（制約が影響する場面）があるか
- Phase 3 の採用アプローチの主要な活動がユースケースとして表現されているか

不足があれば以下の形式で提示する:

```
以下の領域がユースケースでカバーされていません:

1. {不足領域}: {Phase 1-3 のどの情報から導出したか}
2. {不足領域}: {同上}

これらについてユースケースを追加しますか？不要であれば理由を教えてください。
```

ユーザーの回答に基づきユースケース一覧を更新する。

#### Step 4: 優先度付け

全シナリオ（ハッピーパス + エッジケース + Step 3 で追加分）を一覧化し、ユーザーに優先度を確認する:
- 「どのシナリオが最も重要ですか？簡易な対応で済むものはどれですか？」

#### Step 5: 記述品質チェック

Step 4 までの全UCを以下の2ルールで検証し、違反があれば修正を提案する。

**ルール1: 要求レベルの維持**
UCに実装手段・プラットフォーム固有表現が含まれていたら「何をしたいか」に置き換える。
- Bad: 「Androidの共有機能から保存する」（実装手段）
- Good: 「スマホから簡単に保存する」（要求）

**ルール2: 単一関心事**
1つのUCに複数の独立した活動が含まれていたら分割を提案する。
- Bad: 「AI要約を生成し、メタデータを表示し、記事を閲覧する」（3つの関心事）
- Good: 3つの独立したUCに分割

違反がある場合:
```
以下のUCに記述品質の問題があります:

- UC-{N}: {問題の説明}
  修正案: {修正後の記述、または分割案}

この修正を反映しますか？
```

ユーザーの承認後、ユースケース一覧を更新する。

#### Step 6: 仮説サマリ

```
### Phase 4 サマリ（仮説）

**ユーザー種別:**
- {ペルソナ1}: {特徴}
- {ペルソナ2}: {特徴}

**シナリオ一覧:**
| # | シナリオ | 優先度 | 種別 |
|---|---------|--------|------|
| UC-1 | {名前} | Must | 基本 |
| UC-2 | {名前} | Must | 異常系 |
| UC-3 | {名前} | Nice | エッジ |

修正があればお知らせください。問題なければ「ok」と回答してください。
```

---

### Phase 5: スコープと優先度

```
## Phase 5: スコープ
```

**目的:** 作るものと作らないものを明確に線引きする

#### Step 1: MVP特定

以下を質問する:
- 「最低限これだけあれば価値がある、というのは何ですか？」
- 「最初のリリースに絶対必要なものは何ですか？」

#### Step 2: スコープ外の確定

以下を質問する:
- 「これはやらない、と明言できるものはありますか？」

Phase 4 のユースケースのうち Nice-to-have に分類されたものについて:
「{ユースケース名} はスコープ外としてよいですか？」と個別に確認する。

#### Step 3: 非機能要求のヒアリング

以下の観点について、懸念や期待があるか質問する。具体的な数値ではなく「重要かどうか」「懸念があるか」のレベルで聞く。

```
以下の非機能的な観点について、気になることはありますか？

1. **コスト**: 初期コストやランニングコストに制約はありますか？既存の契約やサービスを活用する前提はありますか？
2. **運用負荷**: 誰が運用しますか？どの程度の手間なら許容できますか？
3. **パフォーマンス**: 速度や応答性について期待はありますか？
4. **セキュリティ・プライバシー**: 扱うデータに機密性はありますか？
5. **可用性**: どの程度の安定性が必要ですか？（常時使える必要があるか、多少の停止は許容できるか）
```

回答に矛盾や曖昧さがある場合（例: 「維持費ゼロ」と「有料APIを活用」が同時に出た場合）、AIが指摘して明確化を求める:
「{矛盾/曖昧な点}について確認させてください。{具体的な質問}」

#### Step 4: 仮説サマリ

```
### Phase 5 サマリ（仮説）
- **MVP**: {最小実行可能範囲の一文要約}
- **Must**: {必須要件のリスト}
- **Nice-to-have**: {将来検討する要件のリスト}
- **スコープ外**: {明示的に除外するもののリスト}
- **非機能要求**:
  - コスト: {懸念/制約、またはなし}
  - 運用負荷: {懸念/制約、またはなし}
  - パフォーマンス: {懸念/期待、またはなし}
  - セキュリティ: {懸念/制約、またはなし}
  - 可用性: {懸念/期待、またはなし}

修正があればお知らせください。問題なければ「ok」と回答してください。
```

---

### Phase 6: 成功基準

```
## Phase 6: 成功基準
```

**目的:** 合意可能な完了条件を設定する

#### Step 1: 完了条件

以下を質問する:
- 「これが成功したと言えるのは、どういう状態ですか？」
- 「どうなったら失敗ですか？」

#### Step 2: リスク（ユーザー認識）

まずユーザー自身のリスク認識を聞く:
- 「一番心配していることは何ですか？」

#### Step 3: リスク（AI主導の網羅チェック）

以下のリスクカテゴリを提示し、Step 2 でカバーされていないカテゴリについてリスク有無を確認する:

```
以下のリスクカテゴリについても確認させてください:

1. **技術実現性**: 未知の技術要素や、本当に実現できるか不透明な部分はありますか？
2. **コスト**: API利用料、インフラ費用など、予想外の出費リスクはありますか？
3. **運用負荷**: メンテナンス、障害対応、データ管理で想定以上の手間がかかるリスクは？
4. **依存関係**: 外部サービスの停止・仕様変更、ベンダーロックインのリスクは？
5. **スコープ肥大化**: 要件が膨らんで完成しないリスクは？
```

さらに、Phase 1〜5 の情報からAIが具体的なリスク候補を推測して提示する。
例: 「Phase 5 で AI API を活用する前提がありましたが、API仕様変更やコスト増のリスクはどう考えますか？」

#### Step 4: 仮説サマリ

```
### Phase 6 サマリ（仮説）
- **完了条件**: {成功の定義}
- **失敗条件**: {失敗の定義}
- **リスク**:
  | リスク | カテゴリ | 影響 | 対策 |
  |--------|----------|------|------|
  | {リスク1} | {技術実現性/コスト/運用負荷/依存関係/スコープ肥大化/その他} | {影響内容} | {緩和策} |
  | {リスク2} | {カテゴリ} | {影響内容} | {緩和策} |

修正があればお知らせください。問題なければ「ok」と回答してください。
```

---

### Phase 7: 文書生成・出力

```
## Phase 7: 文書生成
```

#### Step 1: テンプレート読み込み

`{skill_dir}/references/output-template.md` を Read する。

#### Step 2: 要求定義書の生成

Phase 1〜6 で確定した全情報をテンプレートに当てはめ、要求定義書を生成する。
ステータスは `Confirmed` とする。

#### Step 3: 要求・要件の境界チェック

生成した文書の全セクションを検証し、要件（実装レベル）に踏み込んでいる箇所を検出する。

**検出対象:**
- 具体的な技術名・製品名（例: 「PostgreSQLに保存」「React で実装」）
- システムの内部的な振る舞いの記述（例: 「バックグラウンドで非同期処理する」「キャッシュに保持する」）
- プラットフォーム固有の表現（例: 「iOS の Push 通知で」）
- 具体的な数値を伴う非機能要件（例: 「応答時間 200ms 以内」「99.9% 可用性」）
- API やデータモデルへの言及（例: 「REST API で取得」「JSON 形式で」）

問題がなければそのまま Step 4 へ進む。

問題がある場合:
```
以下の箇所が要件（実装レベル）に踏み込んでいます:

1. **{セクション名}**: 「{該当箇所}」
   → 要求レベルの修正案: 「{修正後}」

2. **{セクション名}**: 「{該当箇所}」
   → 要求レベルの修正案: 「{修正後}」

これらの修正を反映しますか？
```

ユーザーの承認後、文書に修正を反映する。

#### Step 4: ユーザー確認

文書の内容をユーザーにテキスト出力し、応答を待つ:
「修正があればお知らせください。問題なければ『ok』と回答してください。」

- 修正指示あり: 内容を修正して再提示
- 承認: Step 5 へ

#### Step 5: 出力処理

`{output_path}` の存在を確認する。

**存在しない場合:**
- `{output_path}` に Write で保存する

**存在する場合:**
1. 既存ファイルを Read する
2. 既存の内容と新しい内容をAIが比較し、変更点を以下の形式でテキスト出力する:
   ```
   ## 既存ファイルとの差分

   ### 追加された内容
   - {追加されたセクションや項目}

   ### 変更された内容
   - {変更前} → {変更後}

   ### 削除された内容
   - {削除されたセクションや項目}

   上書きしてよいですか？
   ```
3. ユーザーが承認したら `{output_path}` に Write で上書きする

#### Step 6: 完了

```
## requirement_elicit 完了
- 出力: {output_path}
- カテゴリ: 6/6 完了

次のステップ: `/requirement_define` で要件定義に進んでください。
```
