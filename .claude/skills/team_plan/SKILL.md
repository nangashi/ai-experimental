---
allowed-tools: Glob, Grep, Read, WebFetch, WebSearch, AskUserQuestion
description: AI agents collaborate to create a thorough development plan through multi-perspective review
---

AIエージェントが協業し、多角的レビューを経た詳細な開発計画を作成します。

## 使い方

ユーザーが実装したい機能や解決したい課題を引数として指定します。引数がない場合は、ユーザーに対象を質問してください。

例: `/team_plan TODOアプリにタグ機能を追加`

## ワークフロー

以下の6フェーズを順に実行してください。

---

### Phase 1: 要件理解 + コードベース探索

**目的**: ユーザーの要件を正確に理解し、既存コードベースのパターンを把握する。

1. ユーザーの入力から要件を整理する
2. `Glob` でプロジェクト全体の構造を把握する
   - 主要ディレクトリ、設定ファイル、エントリーポイントを確認
3. `Grep` と `Read` で既存の技術スタック・パターンを特定する
   - 使用言語、フレームワーク、ライブラリ
   - 命名規則、ディレクトリ構造の規約
   - エラーハンドリング、テスト、ログ出力のパターン
4. 要件に関連する既存コードを重点的に調査する

**出力**: 要件の整理結果と、コードベース分析の要約（以降のフェーズで参照する）

---

### Phase 2: 技術調査 + ユーザー選択

**目的**: 技術的な選択肢を調査し、ユーザーに選択してもらう。

1. 要件実現に必要な技術的決定事項を特定する
2. 各決定事項について `WebSearch` で選択肢を調査する（必要な場合）
3. `AskUserQuestion` でユーザーに選択してもらう

**ユーザーに確認すべき典型的な事項**（該当するもののみ）:
- 技術スタック・ライブラリの選定
- アーキテクチャパターン（レイヤード、クリーンアーキテクチャ等）
- UI/UXアプローチ
- データストレージ方式
- 認証・認可方式
- テスト戦略（テストフレームワーク、カバレッジ目標）
- その他、複数の実現方法がある設計判断

**注意**: 全項目を一度に質問するのではなく、関連性のある項目をグループ化して `AskUserQuestion` の1回の呼び出しで最大4問ずつ質問してください。

**出力**: ユーザーの選択結果とその理由

---

### Phase 3: 初期計画の作成

**目的**: Phase 1-2の結果を基に、plan-architectエージェントに包括的な開発計画を作成させる。

1. `Task` ツールで `plan-architect` サブエージェントを起動する
2. 以下の情報をプロンプトに含める:
   - Phase 1で整理した要件とコードベース分析結果
   - Phase 2でのユーザーの選択結果
   - 計画の出力先ファイルパス
3. plan-architectが出力した計画を確認する

**出力**: 初期開発計画（plan-architectの出力フォーマットに準拠）

---

### Phase 4: 多角的レビュー（並列実行）

**目的**: 5つの専門レビューエージェントで計画を多角的に評価する。

以下の5つのサブエージェントを `Task` ツールで**並列に**起動してください（1つのメッセージで5つの `Task` ツール呼び出しを行う）。

各サブエージェントには以下の情報を渡してください:
- Phase 3で作成された初期計画の全文
- Phase 1のコードベース分析結果の要約
- プロジェクトのルートディレクトリパス

#### レビューエージェント一覧

| エージェント | 評価観点 |
|---|---|
| `security-plan-reviewer` | セキュリティ（脅威モデリング、認証認可、データ保護） |
| `performance-plan-reviewer` | パフォーマンス（ボトルネック予防、I/O効率、キャッシュ） |
| `consistency-plan-reviewer` | 既存実装整合性（コーディング規約、アーキテクチャパターン） |
| `best-practices-plan-reviewer` | ベストプラクティス（SOLID原則、デザインパターン、テスト設計） |
| `maintainability-plan-reviewer` | 保守性（変更容易性、結合度、YAGNI原則） |

**出力**: 5つのレビューエージェントの評価結果

---

### Phase 5: フィードバック統合 + 矛盾解決

**目的**: 5つのレビュー結果を統合し、矛盾を解決して最終計画を完成させる。

#### 5.1 フィードバックの分類

各レビューエージェントの出力を以下の4カテゴリに分類して整理する:

1. **重大な問題（計画の修正が必須）**: 必ず初期計画に反映する
2. **改善提案（計画の品質向上に有効）**: 優先度をつけて初期計画に反映する
3. **確認事項（ユーザーへの確認が必要）**: Phase 5.2で `AskUserQuestion` を使う
4. **評価（良い点）**: 最終計画のレビューサマリに記録する

#### 5.2 矛盾の解決

レビューエージェント間で矛盾するフィードバックがある場合:

1. 両方の立場と根拠を整理する
2. `AskUserQuestion` でユーザーにトレードオフを提示して選択してもらう
   - 各選択肢のメリット・デメリットを明確に説明する
   - どのレビューエージェントがどの立場かを示す
3. ユーザーの決定と根拠を最終計画に記録する

#### 5.3 確認事項のユーザー確認

各レビューエージェントの「確認事項」を集約し、`AskUserQuestion` でユーザーに確認する。

#### 5.4 計画の修正と整合性確認

1. 重大な問題、改善提案、ユーザー決定を反映して初期計画を修正する
2. `Task` ツールで `plan-architect` サブエージェントを起動し、修正後の計画の整合性を確認する
   - フィードバックを反映した結果、計画内で矛盾が生じていないか
   - 実装順序に影響がないか
   - テスト戦略の更新が必要でないか

**出力**: フィードバック統合後の修正計画

---

### Phase 6: 最終計画の出力

**目的**: 最終的な開発計画をMarkdownファイルとして出力する。

#### 出力ファイル

プロジェクトルートに `plan.md` として出力する（既にファイルが存在する場合はユーザーに確認する）。

#### 出力フォーマット

```markdown
# 開発計画: [タイトル]

> 作成日: YYYY-MM-DD
> ステータス: レビュー済み

## 1. 概要
（plan-architectの出力セクション1）

## 2. ディレクトリ構成・ファイル修正一覧
（plan-architectの出力セクション2）

## 3. アーキテクチャ設計
（plan-architectの出力セクション3）

## 4. 実装詳細仕様
（plan-architectの出力セクション4）

## 5. ユニットテスト戦略
（plan-architectの出力セクション5）

## 6. 実装順序
（plan-architectの出力セクション6）

## 7. レビューサマリ

### 7.1 レビュー実施状況
| レビュー観点 | 重大な問題 | 改善提案 | 確認事項 |
|---|---|---|---|
| セキュリティ | N件 | N件 | N件 |
| パフォーマンス | N件 | N件 | N件 |
| 既存実装整合性 | N件 | N件 | N件 |
| ベストプラクティス | N件 | N件 | N件 |
| 保守性 | N件 | N件 | N件 |

### 7.2 反映した重大な問題
（各問題と対応内容のリスト）

### 7.3 反映した改善提案
（各提案と対応内容のリスト）

### 7.4 ユーザー決定事項
（ユーザーが判断した事項とその選択理由のリスト）

## 8. 備考
（計画作成時に判明した制約、前提条件、将来の検討事項等）
```

#### 完了報告

最終計画の出力後、ユーザーに以下を報告する:
- 出力ファイルのパス
- 計画の概要（1-2文）
- レビューで検出された重大な問題の件数
- ユーザーが判断した事項の件数
