---
allowed-tools: Glob, Grep, Read, WebFetch, WebSearch, AskUserQuestion, Task, TeamCreate, TeamDelete, SendMessage, TaskCreate, TaskUpdate, TaskList, TaskGet
description: AIエージェントチームが対話的に協業し、コンフリクト解決を含む多角的レビューを経た詳細な開発計画を作成します
---

AIエージェントがTeamCreateを使ったチームとして協業し、レビューアー間の対話的な議論を通じて高品質な開発計画を作成します。

## team_plan（v1）との違い

- レビューフェーズで `TeamCreate` を使い、エージェント間の対話を可能にする
- レビューアー間でコンフリクト（矛盾する指摘）が検出された場合、当事者同士が直接議論して合意形成を行う
- コンフリクトがない場合はv1と同等のコスト・動作

## 使い方

ユーザーが実装したい機能や解決したい課題を引数として指定します。引数がない場合は、ユーザーに対象を質問してください。

例: `/team_plan_v2 TODOアプリにタグ機能を追加`

## ワークフロー

以下の6フェーズを順に実行してください。

---

### Phase 1: 要件理解 + コードベース探索

**目的**: ユーザーの要件を正確に理解し、既存コードベースのパターンを把握する。

1. ユーザーの入力から要件を整理する
2. `Glob` でプロジェクト全体の構造を把握する
   - 主要ディレクトリ、設定ファイル、エントリーポイントを確認
3. `Grep` と `Read` で既存の技術スタック・パターンを特定する
   - 使用言語、フレームワーク、ライブラリ
   - 命名規則、ディレクトリ構造の規約
   - エラーハンドリング、テスト、ログ出力のパターン
4. 要件に関連する既存コードを重点的に調査する

**出力**: 要件の整理結果と、コードベース分析の要約（以降のフェーズで参照する）

---

### Phase 2: 技術調査 + ユーザー選択

**目的**: 技術的な選択肢を調査し、ユーザーに選択してもらう。

1. 要件実現に必要な技術的決定事項を特定する
2. 各決定事項について `WebSearch` で選択肢を調査する（必要な場合）
3. `AskUserQuestion` でユーザーに選択してもらう

**ユーザーに確認すべき典型的な事項**（該当するもののみ）:
- 技術スタック・ライブラリの選定
- アーキテクチャパターン（レイヤード、クリーンアーキテクチャ等）
- UI/UXアプローチ
- データストレージ方式
- 認証・認可方式
- テスト戦略（テストフレームワーク、カバレッジ目標）
- その他、複数の実現方法がある設計判断

**注意**: 全項目を一度に質問するのではなく、関連性のある項目をグループ化して `AskUserQuestion` の1回の呼び出しで最大4問ずつ質問してください。

**出力**: ユーザーの選択結果とその理由

---

### Phase 3: 初期計画の作成

**目的**: Phase 1-2の結果を基に、plan-architectエージェントに包括的な開発計画を作成させる。

1. `Task` ツールで `plan-architect` サブエージェントを起動する（※ワンショット、チーム外）
2. 以下の情報をプロンプトに含める:
   - Phase 1で整理した要件とコードベース分析結果
   - Phase 2でのユーザーの選択結果
   - 計画の出力先ファイルパス
3. plan-architectが出力した計画を確認する

**出力**: 初期開発計画（plan-architectの出力フォーマットに準拠）

---

### Phase 4: チーム作成 + 多角的レビュー（並列実行）

**目的**: TeamCreateでレビューチームを構成し、5つの専門レビューエージェントで計画を多角的に評価する。

#### 4.1 チームの作成

`TeamCreate` でレビューチームを作成する:
```
TeamCreate: team_name="plan-review"
```

#### 4.2 レビュータスクの作成

`TaskCreate` で以下の6つのタスクを作成する:

| タスク | 担当 |
|---|---|
| セキュリティレビュー | security-reviewer |
| パフォーマンスレビュー | performance-reviewer |
| 既存実装整合性レビュー | consistency-reviewer |
| ベストプラクティスレビュー | practices-reviewer |
| 保守性レビュー | maintainability-reviewer |
| レビュー結果に基づく計画修正 | architect（レビュー完了後に実行） |

計画修正タスクは5つのレビュータスクを `blockedBy` に設定する。

#### 4.3 レビューアーの起動（並列）

以下の5つのレビューアーを `Task` ツールで**並列に**起動する（1つのメッセージで5つの `Task` ツール呼び出しを行う）。

各レビューアーには以下の情報を渡す:
- `team_name`: "plan-review"
- `name`: 各レビューアーの名前（下表参照）
- `subagent_type`: "general-purpose"（チーム対応のため）
- Phase 3で作成された初期計画の全文
- Phase 1のコードベース分析結果の要約
- プロジェクトのルートディレクトリパス
- 担当するタスクのID

| 名前 | エージェント定義 | 評価観点 |
|---|---|---|
| `security-reviewer` | team-security-reviewer | セキュリティ（脅威モデリング、認証認可、データ保護） |
| `performance-reviewer` | team-performance-reviewer | パフォーマンス（ボトルネック予防、I/O効率、キャッシュ） |
| `consistency-reviewer` | team-consistency-reviewer | 既存実装整合性（コーディング規約、アーキテクチャパターン） |
| `practices-reviewer` | team-practices-reviewer | ベストプラクティス（SOLID原則、デザインパターン、テスト設計） |
| `maintainability-reviewer` | team-maintainability-reviewer | 保守性（変更容易性、結合度、YAGNI原則） |

各レビューアーはレビュー完了後、コーディネーターに `SendMessage` で結果を送信し、`TaskUpdate` でタスクを完了にする。

**出力**: 5つのレビューエージェントの評価結果（SendMessageで受信）

---

### Phase 5: 対話的フィードバック統合 + コンフリクト解決

**目的**: レビュー結果を統合し、コンフリクトがある場合はレビューアー間の対話で解決する。

#### 5.1 フィードバックの分類

各レビューエージェントから受信したメッセージを以下の4カテゴリに分類して整理する:

1. **重大な問題（計画の修正が必須）**: 必ず初期計画に反映する
2. **改善提案（計画の品質向上に有効）**: 優先度をつけて初期計画に反映する
3. **確認事項（ユーザーへの確認が必要）**: Phase 5.3で `AskUserQuestion` を使う
4. **評価（良い点）**: 最終計画のレビューサマリに記録する

#### 5.2 コンフリクト検出と解決

レビューアー間で矛盾するフィードバックを検出する。

**コンフリクトの典型パターン**:
- パフォーマンスレビューアーがキャッシュを推奨 ↔ 保守性レビューアーがYAGNIで反対
- セキュリティレビューアーが厳格な検証を推奨 ↔ ベストプラクティスレビューアーが過剰設計と指摘
- 一貫性レビューアーが既存パターン踏襲を推奨 ↔ ベストプラクティスレビューアーが既存パターンの改善を推奨

**コンフリクトがある場合**:

1. 関係する2名のレビューアーに `SendMessage` で議論を依頼する
   - コンフリクトの内容を説明
   - 相手の名前を伝え、直接DMで議論するよう指示
   - 最大2往復で合意を目指すよう依頼
2. レビューアーが議論を行い、結果をコーディネーターに報告する
3. 合意に至った場合: その合意内容を計画に反映
4. 合意に至らなかった場合: `AskUserQuestion` でユーザーにトレードオフを提示して選択してもらう
   - 各選択肢のメリット・デメリットを明確に説明する
   - どのレビューアーがどの立場かを示す

**コンフリクトがない場合**: このステップをスキップし、5.3に進む。

#### 5.3 確認事項のユーザー確認

各レビューエージェントの「確認事項」を集約し、`AskUserQuestion` でユーザーに確認する。

#### 5.4 計画の修正

1. 重大な問題、改善提案、コンフリクト解決結果、ユーザー決定を整理する
2. `SendMessage` でarchitectに修正指示を送信する:
   - 反映すべきフィードバックの一覧
   - 各フィードバックの優先度と対応方針
   - ユーザー決定事項
3. architectが修正した計画を受領し、内容を確認する

**出力**: フィードバック統合後の修正計画

---

### Phase 6: 最終計画の出力 + チーム解散

**目的**: 最終的な開発計画をMarkdownファイルとして出力し、チームを解散する。

#### 出力ファイル

プロジェクトルートに `plan.md` として出力する（既にファイルが存在する場合はユーザーに確認する）。

#### 出力フォーマット

```markdown
# 開発計画: [タイトル]

> 作成日: YYYY-MM-DD
> ステータス: レビュー済み（対話的コンフリクト解決済み）

## 1. 概要
（plan-architectの出力セクション1）

## 2. ディレクトリ構成・ファイル修正一覧
（plan-architectの出力セクション2）

## 3. アーキテクチャ設計
（plan-architectの出力セクション3）

## 4. 実装詳細仕様
（plan-architectの出力セクション4）

## 5. ユニットテスト戦略
（plan-architectの出力セクション5）

## 6. 実装順序
（plan-architectの出力セクション6）

## 7. レビューサマリ

### 7.1 レビュー実施状況
| レビュー観点 | 重大な問題 | 改善提案 | 確認事項 |
|---|---|---|---|
| セキュリティ | N件 | N件 | N件 |
| パフォーマンス | N件 | N件 | N件 |
| 既存実装整合性 | N件 | N件 | N件 |
| ベストプラクティス | N件 | N件 | N件 |
| 保守性 | N件 | N件 | N件 |

### 7.2 コンフリクト解決
| コンフリクト | 当事者 | 解決方法 | 結果 |
|---|---|---|---|
| （矛盾の内容） | （レビューアー名） | 合意 / ユーザー判断 | （採用された方針） |

### 7.3 反映した重大な問題
（各問題と対応内容のリスト）

### 7.4 反映した改善提案
（各提案と対応内容のリスト）

### 7.5 ユーザー決定事項
（ユーザーが判断した事項とその選択理由のリスト）

## 8. 備考
（計画作成時に判明した制約、前提条件、将来の検討事項等）
```

#### チームの解散

1. 全メンバーに `SendMessage` の `shutdown_request` を送信する
2. 全メンバーのシャットダウン完了を確認する
3. `TeamDelete` でチームを削除する

#### 完了報告

最終計画の出力後、ユーザーに以下を報告する:
- 出力ファイルのパス
- 計画の概要（1-2文）
- レビューで検出された重大な問題の件数
- コンフリクト解決の件数と方法
- ユーザーが判断した事項の件数
