# コンテンツ・ワークフロー分析

スキル定義のコンテキスト効率、データフロー、ワークフロー構造を分析し、問題を構造化レポートとして出力する。

## 入力

- `{skill_path}`: スキルディレクトリの絶対パス
- `{skill_name}`: スキル名
- `{file_list_path}`: ファイルリストのパス
- `{findings_save_path}`: 結果保存先パス

## 手順

### Step 1: ファイル収集

1. `{file_list_path}` を Read してスキル内の全 .md ファイルパスを取得する
2. `{skill_path}/SKILL.md` を Read する

### Step 2: チェック実行

以下のチェックを順に実行する。検出した問題は findings リストに追加していく。

#### C1: 大きなインラインコンテンツ

SKILL.md 内のコードブロック（``` で囲まれた領域）を検出し、各ブロックの行数をカウントする。
15行以上のブロックを finding として記録する（severity: warning）。

外部テンプレートファイルに切り出すことで SKILL.md のサイズを削減し、親コンテキストの消費を抑えられる。

Auto: no（テンプレートファイルの新規作成と SKILL.md の構造変更が必要）

#### C2: サブエージェント返答最小化指示の欠如

SKILL.md 内の各 `Task` 呼び出し箇所を特定する。
各 Task について、呼び出し前後の記述に返答最小化に関する指示が含まれているか確認する。

検出パターン（いずれかが存在すれば OK）:
- 「最小限」「とだけ返答」
- 「ファイルに保存」「Write で保存」
- テンプレート側に「返答する」の指示がある場合はテンプレートを Read して確認する

いずれのパターンも見つからない Task を finding として記録する（severity: warning）。

Auto: no（適切な最小化指示はタスクの性質に依存する）

#### C3: コンテキスト消費量の概算

以下を集計する:
- SKILL.md の行数
- 全テンプレートファイルの合計行数（各ファイルの行数も内訳として記録）
- 全エージェント定義ファイルの合計行数（各ファイルの行数も内訳として記録）
- 合計行数

結果を finding（severity: info）として記録する。
SKILL.md が 300行を超える場合は severity を warning に引き上げる（親コンテキストの大部分を占有するため）。

Auto: no

#### D1: 3ホップパターン

以下のパターンを SKILL.md 内で検出する:

1. Phase N の Task サブエージェントが結果をテキスト（返答内容）として返す
2. 親がその返答内容から情報を抽出し変数に保持する
3. Phase N+1 の Task サブエージェントにその変数をパス変数として渡す

検出のヒント:
- 「サブエージェントの返答から...を抽出する」→ 後続の Task に渡す記述
- パス変数にファイルパスではなくテキスト内容（サマリ、リスト等）を渡している記述
- サブエージェント A → 親で中継 → サブエージェント B の流れ

ファイル経由のデータフロー（サブエージェントがファイルに保存 → 次のサブエージェントがそのファイルを Read）に置換すべきパターンとして finding を記録する（severity: warning）。

Auto: no（データフローの再設計が必要）

#### D2: 書き込み・読み込みの不整合

SKILL.md 全体を通して:
1. Write/保存操作で出力されるファイルパスを全て収集する
2. Read/読み込み操作で参照されるファイルパスを全て収集する

以下を finding として記録する:
- **孤立出力**: Write されるがどの Phase でも Read されないファイル
  - 除外: 最終成果物（ユーザーに提示するレポート等）、外部ツールへの入力ファイル
  - Severity: info
- **未生成入力**: Read されるがどの Phase でも Write されないファイル
  - 除外: 外部入力ファイル（ユーザーが指定するファイル、他スキルの成果物）、スキルディレクトリ内のテンプレート/エージェント定義ファイル
  - Severity: error

Auto: no

#### E1: Phase/Step 番号の不整合

SKILL.md の見出し構造を解析する:
- `### Phase {N}:` 形式の見出しから Phase 番号を抽出し、連続性を確認する
- 各 Phase 内の `#### Step {N}:` や `#### ステップ{N}:` の番号の連続性を確認する

番号のスキップまたは重複を finding として記録する（severity: warning）。

Auto: yes（見出しの番号を連番に修正）

#### E3: 到達不能な分岐

条件分岐（「〜の場合」「〜が true の場合」等）で参照される変数が、その時点のワークフローで定義済みかを確認する。

以下を finding として記録する:
- 定義されていない変数を条件に使用している分岐（severity: error）
- Phase 0 で定義されるが、特定の条件分岐でしか設定されない変数を、後続 Phase で無条件に参照している場合（severity: warning）

Auto: no

### Step 3: 結果出力

検出された全 finding を以下のフォーマットで `{findings_save_path}` に Write する:

```
# Findings: Content & Workflow

Total: {N} issues (errors: {N}, warnings: {N}, info: {N})

### SK-101: {タイトル}
- **Check**: {C1/C2/C3/D1/D2/E1/E2/E3}
- **Severity**: {error/warning/info}
- **Location**: SKILL.md:{行番号またはセクション名}
- **Problem**: {問題の説明}
- **Fix**: {修正案の説明}
- **Auto**: {yes (具体的操作) / no}
```

ID は `SK-101` から連番で付与する（reference-analysis の ID 範囲 SK-001〜 との衝突を避ける）。

問題が0件の場合も以下を出力する:
```
# Findings: Content & Workflow

Total: 0 issues
```

最後に「保存完了: {findings_save_path}, 検出: {N}件 (error: {N}, warning: {N}, info: {N})」とだけ返答する。
