---
scope: コードの変更容易性を高めるための設計原則と適用条件
boundary: |
  クラス設計・メソッド設計・依存関係設計・命名設計レベルの原則を対象とする。
  アーキテクチャパターン（DDD戦略設計、マイクロサービス等）は対象外。
  プロセス/ワークフロー統合は対象外。
research_query: コードの変更容易性に関する設計原則、適用条件、制限事項、反論の研究データと実践知見
---

# コードの変更容易性を高める設計原則

コードの変更容易性（changeability）に寄与する設計原則を、適用条件・制限・反論とともに整理する。各原則は複数の設計思想家の知見で裏付けまたは限定されており、無条件に適用すべきものではない。

## 原則一覧

| # | 原則 | 適用条件 | カテゴリ |
|---|------|---------|---------|
| 1 | 値オブジェクト | ドメインロジック・バリデーションがある値 | クラス構造 |
| 2 | 完全コンストラクタ | 原則適用。技術制約で例外あり | クラス構造 |
| 3 | 不変性優先 | デフォルト方針 | クラス構造 |
| 4 | データクラス=低凝集の兆候 | ドメイン層限定 | クラス構造 |
| 5 | 副作用を持つstaticメソッドの排除 | 副作用・外部依存を持つstaticが対象 | メソッド・依存関係 |
| 6 | デメテルの法則 | 内部構造への依存を制限 | メソッド・依存関係 |
| 7 | CQS（コマンド・クエリ分離） | デフォルト原則。正当な例外あり | メソッド・依存関係 |
| 8 | 散在する条件分岐の構造化 | 同一条件が複数箇所に散在する場合 | 拡張性・構造化 |
| 9 | ファーストクラスコレクション | ビジネスルールがあるコレクション | 拡張性・構造化 |
| 10 | サブクラスの都合でスーパークラスを変更しない | 継承利用時 | 拡張性・構造化 |
| 11 | 目的が異なるものを共通化しない | 共通化判断時 | 命名・組織化 |
| 12 | null可能性の型による安全管理 | 型システムでnullを管理 | クラス構造 |
| 13 | 目的駆動命名 | ドメイン層 | 命名・組織化 |
| 14 | 役割駆動設計 | 大規模ドメインでの分割が必要な場合 | 命名・組織化 |
| 15 | DRY=意図の重複禁止 | 見た目ではなく意図・知識の重複 | 命名・組織化 |

---

## クラス構造の設計

### 1. 値オブジェクト

**原則**: ドメインロジックやバリデーションを持つ値は、プリミティブ型ではなく専用の型（クラス）として表現する。

**適用条件**: バリデーションルール、計算ロジック、フォーマット変換など、値に紐づくドメインロジックが存在する場合。

**効果**: 値に関するロジックが1箇所に凝集し、散在による重複・修正漏れを防ぐ。Martin Fowlerは「Primitive Obsession」をコードスメルとして認めており、DDDでも値オブジェクトはドメインモデリングの基本要素とされる。

**制限・反論**:
- **Rich Hickey（Simple Made Easy）**: 値をカスタムクラスで囲むことは汎用的なデータ操作（map, filter等）を不可能にする。「ほとんどのクラスは名前付きプロパティから値への連想マップにすぎない」
- **John Ousterhout（A Philosophy of Software Design）**: 小さなクラスを大量に作る「classitis」症候群。値オブジェクトがインターフェースの複雑さに対して十分な機能を隠蔽しない「浅いモジュール」になる危険
- **Kent Beck（Simple Design — Fewest Elements）**: バリデーションもドメインロジックもない値にまで専用クラスを作るのは、最小要素の規則に反する
- **現代言語のサポート**: Kotlinの`value class`、Haskellの`newtype`はラッパーのオーバーヘッドをコンパイル時に除去する。type aliasで十分な場合もある

**適用しない場合**: バリデーションもロジックもない単純な値（単なるID文字列、フラグ値等）。プロトタイプや小規模ツール。

---

### 2. 完全コンストラクタ

**原則**: オブジェクトはコンストラクタで全フィールドを初期化し、バリデーションを通過した状態でのみ生成可能にする。不正状態のオブジェクトが存在できない設計にする。

**適用条件**: ドメインオブジェクト全般。特に不変条件（invariant）を持つエンティティ・値オブジェクト。

**効果**: 不正状態のオブジェクトがシステム内に伝播することを構造的に防止する。Eric EvansもDDDにおいてアグリゲートの不変条件維持を重視している。

**制限・反論**:
- **GoFビルダーパターン**: 構築に多段階のステップが必要なオブジェクトでは、完全コンストラクタはパラメータ爆発を招く。ビルダーパターンやファクトリメソッドが適切
- **技術的制約**: ORMのリフレクションベース構築、デシリアライズ（JSON, Protocol Buffers等）では引数なしコンストラクタが技術的に必要
- **Kent Beck**: テスト時に完全なオブジェクトを毎回構築するコストが高い場合がある

**適用しない場合**: ORM/DI等のフレームワーク制約がある場合（例外として許容し理由を記録）。パラメータが多数の場合はビルダーパターンを併用。

---

### 3. 不変性優先

**原則**: フィールド・変数はデフォルトで不変（immutable）にする。値の変更が必要な場合は、既存オブジェクトを変更するのではなく新しいインスタンスを生成して返す。

**適用条件**: デフォルト方針として全般に適用。

**効果**: Rich Hickey、Eric Evans（値オブジェクトの不変性）、Joshua Bloch（Effective Java）など、ほぼ全ての設計思想家が支持する稀有な合意点。並行処理の安全性、予測可能性、デバッグ容易性のいずれにおいても優位。

**制限・反論**:
- **性能**: 大量データのバッチ処理やゲームエンジンなど、性能が最優先の領域では可変データ構造が不可避。構造共有（structural sharing）で緩和できるが万能ではない
- **言語設計の多様性**: Goは値型とポインタ型を明示的に使い分け、不変性を言語レベルで強制しない設計を選んでいる

**適用しない場合**: パフォーマンスクリティカルな局所的処理（計測に基づいて判断）。

---

### 4. データクラス=低凝集の兆候

**原則**: ドメイン層において、データのみを保持しロジックを持たないクラスは低凝集の兆候である。データを操作するロジックが外部に散在していないか確認する。

**適用条件**: ドメイン層のクラスに限定。DTO、イベント、コマンド、APIレスポンス等のデータ転送目的クラスは対象外。

**効果**: Martin Fowlerも「Data Class」をコードスメルとして認めている。ロジックの散在は重複コード、修正漏れ、整合性の崩壊を招く。

**制限・反論**:
- **Rich Hickey（Data-Oriented Programming）**: 「データに何も問題はない。データはファーストクラスの存在であるべき」。データとロジックを結合することこそが、汎用的なデータ操作を不可能にする
- **現代言語**: Kotlinの`data class`、Java 16の`record`、Haskellの代数的データ型は、データ構造を明示的に表現するための言語機能として設計されている
- **関数型パラダイム**: データ（代数的データ型）と関数（データを変換するもの）の分離が基本原則。「データクラスは低凝集」はOOPの凝集度定義に依存する

**適用しない場合**: DTO・イベント・コマンド等のデータ転送目的クラス。関数型パラダイムを採用している場合。インフラ層のデータ構造。

---

### 12. null可能性の型による安全管理

**原則**: null可能性を型で明示する（Kotlin: `String?`, Rust: `Option<T>`, TypeScript: `string | null`）。型レベルでnullの可能性を管理し、実行時のnullチェック散在を防ぐ。

**適用条件**: 型システムがnull安全をサポートする言語環境。

**効果**: Tony Hoare自身がnull参照を「10億ドルの過ち」と呼んだ。Martin Fowler（Special Case Pattern）、Robert C. Martin（Clean Code）もnull安全の方向性を支持。

**制限・反論**:
- 「nullを使わない」と「nullを安全に管理する」は異なるアプローチ。現代言語の型システムはnullを排除するのではなく型で制御する
- Go言語ではnilは正常系を表す重要な値（error戻り値パターン）

**適用しない場合**: 言語がnull安全の型システムを持たない場合は、NullObjectパターンやOptional型で代替。

---

## メソッド・依存関係の設計

### 5. 副作用を持つstaticメソッドの排除

**原則**: 外部状態に依存する、または副作用を持つstaticメソッドを避ける。テスト容易性と差し替え可能性を確保する。

**適用条件**: 副作用（DB書き込み、ファイルI/O、外部API呼び出し等）や外部状態への依存を持つstaticメソッドが対象。

**効果**: Martin Fowlerはstaticメソッドの主な問題をポリモーフィズム不可（テスト時のスタブ差し替え困難）と指摘。

**制限・反論**:
- **純粋関数としてのstatic**: 入力のみに依存し副作用を持たない純粋関数は、static/パッケージレベル関数として完全に正当。`Math.max()`のような計算はstaticが適切
- **Robert C. Martin**: 「ポリモーフィックである可能性がない場合」はstaticメソッドが適切
- **関数型プログラミング**: すべての関数がstatic（インスタンスに紐づかない）。Go言語もパッケージレベル関数が標準

**適用しない場合**: 純粋関数（副作用なし、外部状態非依存）。数学的計算、型変換、フォーマット処理。

---

### 6. デメテルの法則

**原則**: オブジェクトは直接の協力者のメソッドのみを呼び出すべきであり、協力者の内部構造を経由してアクセスしない（「知らない人に話しかけるな」）。

**適用条件**: オブジェクト間のメッセージパッシングを設計する場面。

**効果**: 内部構造への依存を制限することで、変更の波及を局所化する。内部構造が変わっても、直接のインターフェースが安定していれば呼び出し元の変更は不要になる。

**検出基準**: `a.getB().getC().doSomething()` のような3段階以上のメソッドチェーンは違反の典型的な兆候。

**制限・反論**:
- Fluent APIやビルダーパターンでは意図的にメソッドチェーンを使用する（これは同一オブジェクトへの操作であり、デメテルの法則違反ではない）
- 過度な適用は「委譲メソッドの増殖」を招き、John Ousterhoutの「浅いモジュール」問題になりうる

**適用しない場合**: Fluent API / ビルダーパターン。ナビゲーション的なアクセスが言語の慣習として確立している場合（例: RailsのActiveRecord関連）。

---

### 7. CQS（コマンド・クエリ分離）

**原則**: メソッドは「状態を変更するコマンド」か「値を返すクエリ」のどちらか一方だけを行うべきである。

**適用条件**: デフォルト原則として適用。例外は設計書に理由を記録する。

**効果**: Bertrand Meyerが提唱し、APIの理解しやすさを向上させる有用な指針として広く支持されている。Martin Fowlerも「非常に有用な原則」と評価。

**制限・反論**:
- **Martin Fowler**: `stack.pop()` のように「クエリとコマンドを一体にしたほうが著しく便利な場合がある」
- **並行処理**: `compareAndSwap`, `getAndIncrement`, `putIfAbsent` などのアトミック操作はCQSに違反するが不可欠
- 厳密な適用は1メソッドを2つに分割し、呼び出し側の複雑さが増す場合がある

**適用しない場合**: アトミック操作（並行処理）。pop()のような自然なAPI。分割が呼び出し側の複雑さを著しく増す場合。

---

## 拡張性・構造化の設計

### 8. 散在する条件分岐の構造化

**原則**: 同一条件の分岐（型判定、ステータス判定等）が複数箇所に散在している場合、ポリモーフィズムまたはパターンマッチで構造化する。

**適用条件**: 同一条件が2ファイル以上に散在している場合。種類の追加時に全分岐箇所を修正する必要がある状況。

**効果**: Martin Fowler（Replace Conditional with Polymorphism）が条件分岐が複数メソッドに散在している場合に有効なリファクタリング技法として紹介。

**制限・反論**:
- **Expression Problem**: ポリモーフィズムに置き換えると、新しいメソッド（振る舞い）の追加には全サブクラスの修正が必要になる。型の追加より振る舞いの追加が頻繁な場合、条件分岐のほうが変更容易
- **パターンマッチング**: Kotlin/Scala/Rustのsealed class + when/match式は、ポリモーフィズムとは異なるアプローチで網羅的な条件分岐をコンパイル時に検証する
- **John Ousterhout**: 大量の小さなクラスを生むことはclassitis。単純な分岐1つのためにクラス階層を作るのは浅いモジュールの典型
- **Dan Abramov（Goodbye, Clean Code）**: 抽象化が将来の変更を逆に困難にすることがある

**適用しない場合**: 単一箇所の単純な分岐。型の追加より振る舞いの追加が頻繁な場合。パターンマッチで網羅性を検証できる言語環境。

---

### 9. ファーストクラスコレクション

**原則**: ビジネスルール（最大件数制約、要素の重複禁止、合計値の計算等）を持つコレクションは、専用クラスにカプセル化する。

**適用条件**: コレクションにビジネスルールや不変条件が存在する場合。

**効果**: コレクション操作のビジネスルールが1箇所に集約され、変更・拡張が容易になる。DDDのアグリゲート設計とも整合する。

**制限・反論**:
- **Rich Hickey**: コレクションを専用クラスで包むことは、map/filter等の標準操作がそのまま使えなくなり、委譲メソッドの増殖を招く
- **John Ousterhout**: ビジネスルールを持たないコレクションのラッパーは浅いモジュールの典型例
- **現代言語のコレクションAPI**: Kotlin拡張関数やJava Stream APIにより、ラッパークラスなしでもドメインロジックを表現力豊かに記述可能

**適用しない場合**: ビジネスルールのない単純なコレクション。言語のコレクションAPIで十分に表現できる場合。

---

### 10. サブクラスの都合でスーパークラスを変更しない

**原則**: 継承関係において、子クラスの要求で親クラスを変更してはならない。サブクラスの追加がスーパークラスの修正を必要としない安定したインターフェースを設計する。

**適用条件**: 継承を使用する設計全般。

**効果**: 開放閉鎖原則（OCP）の具体的な適用。サブクラスの追加によるスーパークラスの変更は、他のサブクラスに予期しない影響を波及させる。

**制限・反論**:
- 過度に安定性を求めると、スーパークラスが過剰に抽象的になる場合がある
- そもそも継承よりコンポジションを優先すべき場面が多い（GoF: "Favor composition over inheritance"）

---

## 命名・組織化の設計

### 11. 目的が異なるものを共通化しない

**原則**: コードの見た目が似ていても、ビジネス上の目的が異なるなら共通化してはならない。共通化の判断は「コードの見た目」ではなく「意図の一致」に基づく。

**適用条件**: 共通化・再利用を検討する全ての場面。

**効果**: Sandi Metz（The Wrong Abstraction）は「間違った抽象は重複より遥かにコストが高い」と述べた。Dan Abramov（Goodbye, Clean Code）も安易な共通化が将来の変更を困難にする実体験を紹介している。Dave Thomas & Andy Hunt（DRY原典著者）も、DRYは見た目の類似ではなく知識の重複を対象とすると明言。

**制限・反論**:
- 「目的が同じかどうか」の判断基準が曖昧になりがち。チーム内で「目的」の定義が共有されていない場合、実務で適用困難
- 判断を誤ると、逆に正当な共通化を見逃す可能性もある

**適用しない場合**: なし（普遍的原則）。ただし「目的が同じ」と判断した場合の共通化は推奨される。

---

### 13. 目的駆動命名

**原則**: ドメイン層のクラス名・メソッド名は、技術的な「何であるか」ではなく、ビジネス上の「何のためか」で命名する。「商品」のような存在ベースの汎用名を避け、「予約品」「出品物」「発送品」のように目的ごとに分離する。

**適用条件**: ドメイン層の命名。

**効果**: Eric Evans（DDD/ユビキタス言語）、Martin Fowler（Intention Revealing Name）、Kent Beck（Simple Design — Reveals Intention）のいずれとも整合する。命名が適切であれば、クラスの責務が自然に分離される。

**制限・反論**:
- インフラ層やフレームワーク連携のコードでは、技術的な命名（`UserRepository`, `HttpClient`）が適切
- Evans は「命名はドメインエキスパートとの対話から生まれるべき」としており、開発者が独自に「目的」を定義するリスクがある

**適用しない場合**: インフラ層、技術的ユーティリティ、フレームワーク連携コード。

---

### 14. 役割駆動設計

**原則**: 大規模ドメインにおいて、1つのモデルに複数の役割（購入者・出品者・管理者等）が混在する場合、役割ごとにモデルを分割する。

**適用条件**: 大規模ドメインで、同一エンティティの異なる役割が明確に識別でき、役割間の振る舞いが異なる場合。

**効果**: Eric Evans（DDD/Bounded Context）の「大規模システムで単一の統一モデルを持つことに反対」する方針と整合。God Class化を構造的に防止する。

**制限・反論**:
- **John Ousterhout**: 過度な分割は浅いモジュールの増殖を招く。共通データ（氏名、メールアドレス等）の同期問題が発生
- **YAGNI**: 将来のための分割は、実際に複雑さが正当化するレベルに達してから行うべき
- CRUDアプリやマイクロサービスの1サービスでは、1つのモデルで十分な場合がほとんど

**適用しない場合**: 小規模プロジェクト。役割間で共有するデータが多く、分割コストが利益を上回る場合。

---

### 15. DRY=意図の重複禁止

**原則**: DRY原則は「コードの見た目の重複」ではなく「知識・意図の重複」を排除する原則である。同一の知識が複数箇所に存在する場合、単一の権威ある表現に統合する。

**適用条件**: 全般。

**効果**: Dave Thomas & Andy Hunt（The Pragmatic Programmer — DRY原典）の定義「Every piece of knowledge must have a single, unambiguous, authoritative representation within a system」と完全に一致する。業界で広く誤解されている「コードの見た目の重複を排除せよ」に対する重要な修正。

**制限・反論**:
- **Sandi Metz**: 「重複は間違った抽象より遥かに安い」。意図が同じかどうかの判断を誤ると、間違った共通化を招く
- **Dan Abramov（The Wet Codebase）**: 早すぎる段階で「意図が同じ」と判断するリスクがある。意図は時間とともに分岐することがある

**適用しない場合**: なし（普遍的原則）。ただしSandi Metzの補足「間違った抽象より重複のほうが安い」を常に併せて判断する。

---

## AI適用時の注意

設計原則をAIへの指示として使用する際、以下の挙動特性に留意する。詳細なAI挙動パターンは `ai-code-quality.md` を参照。

### 過剰適用リスク

AIは指示された原則を忠実に、しかし適用条件を無視して一律適用する傾向がある。

| 原則 | 過剰適用の典型例 | 対策 |
|------|---------------|------|
| 値オブジェクト | バリデーションもロジックもない値にまで専用クラスを生成（classitis） | 「バリデーションまたはドメインロジックがある値に限定する」と条件を明示 |
| 条件分岐の構造化 | 単一箇所の単純な分岐にもクラス階層を導入（抽象化肥大） | 「同一条件が2ファイル以上に散在する場合のみ」と条件を明示 |
| ファーストクラスコレクション | ビジネスルールのないコレクションにもラッパークラスを生成 | 「ビジネスルール（件数制約、重複禁止等）がある場合のみ」と条件を明示 |
| 役割駆動設計 | 小規模プロジェクトでもモデルを過剰分割 | 「大規模ドメインでのみ適用」と条件を明示 |
| DRY | 明らかに同一の意図を持つコードも重複させる（指示の逆解釈） | 「意図が同一なら統合する」と肯定形でも指示 |

### 指示設計の原則

- **適用条件を必ず併記する**: 「値オブジェクトにすべき」ではなく「バリデーションやドメインロジックがある値は値オブジェクトにする。ない場合はプリミティブ型またはtype aliasで十分」
- **理由を付与する**: 「〜するな」ではなく「〜のため、〜する」と理由付きで指示する。理由があるとモデルが条件を汎化できる（prompt-design.md 参照）
- **チェック項目は少数に絞る**: 設計チェックリストは5項目を上限とする。過剰な構造化は逆効果（prompt-design.md 参照）
- **YAGNI制約を明示する**: 設計原則と併せて「現時点で必要な場合のみ適用。将来のための先行投資は行わない」を制約として付与する
