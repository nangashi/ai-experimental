# セキュリティ設計レビュー結果

## 重大な問題（Critical Issues）

### C1. CSRF保護の欠如
**問題の詳細:**
状態を変更するすべてのAPI（予約作成・更新・削除、患者情報更新、診察記録作成・更新など）に対してCSRF保護が設計されていません。JWTがlocalStorageに保存される設計（5.3節）であり、JavaScriptから自由にアクセス可能なため、XSS攻撃と組み合わせることでCSRF攻撃が成立します。

**影響分析:**
攻撃者が悪意のあるスクリプトを注入できれば、ユーザーの意図しない予約作成・キャンセル、患者情報の改ざん、診察記録の不正な作成が可能になります。医療システムにおいてこれらの操作は患者の生命・健康に直接影響する可能性があります。

**対策:**
- JWTをlocalStorageではなくHttpOnly属性付きのCookieに保存し、SameSite=Strict属性を設定する
- または、状態変更APIに対してCSRFトークンを実装する（Spring Securityのデフォルトサポートを有効化）
- さらに、重要な操作（診察記録作成・更新）には追加の確認ステップを設計する

**参照箇所:**
- 5.3節「認証・認可方式」（JWTのlocalStorage保存）
- 5.1節のすべての状態変更エンドポイント

### C2. 認証エンドポイントのレート制限不足
**問題の詳細:**
ログインエンドポイント（`POST /api/auth/login`）、パスワードリセット（設計書に記載なし）、トークンリフレッシュ（`POST /api/auth/refresh`）に対する明示的なレート制限設計がありません。API Gatewayのレート制限（3.2節: 1分あたり100リクエスト）は一般的なAPIに適用されるもので、認証エンドポイントには不十分です。

**影響分析:**
ブルートフォース攻撃により患者や医療従事者のアカウントが侵害され、診察記録や個人情報への不正アクセスが可能になります。医療データは個人情報保護法・医療法により厳格な保護が求められるため、法的リスクも高くなります。

**対策:**
- ログインエンドポイントに対して、IPアドレスごとに1分あたり5回、アカウントごとに1時間あたり10回などの厳格なレート制限を設計する
- トークンリフレッシュエンドポイントにも同様の制限を適用する
- 連続ログイン失敗時のアカウントロックアウト機能を設計する（例: 5回失敗で15分間ロック）
- 失敗ログインの監視とアラート機能を設計する

**参照箇所:**
- 5.1節「認証API」
- 3.2節「API Gateway」のレート制限設定

### C3. カルテAPIの認可設計の欠如
**問題の詳細:**
`GET /api/patients/{id}`, `GET /api/patients/{id}/records`, `GET /api/records/{id}` などの個人医療情報を扱うエンドポイントにおいて、リソース所有者確認や所属確認の認可チェックが明示的に設計されていません。JWTにロールが含まれる（5.3節）とありますが、特定の患者データへのアクセス権限の検証方法が不明です。

**影響分析:**
患者Aが患者Bのカルテや診察履歴を閲覧できる可能性があります。これは個人情報保護法違反であり、医療法上の守秘義務違反にも該当します。また、医療従事者が所属していない医療機関の患者データにアクセスできる可能性もあります。

**対策:**
- 患者向けエンドポイント: JWTのユーザーIDとリクエストパスの{id}パラメータが一致することを検証する設計を明記する
- 医療従事者向けエンドポイント: 医療従事者と医療機関の所属関係、および医療機関と患者の予約関係を検証する設計を追加する
- Spring Securityの`@PreAuthorize`アノテーションまたはカスタムAuthorizationManagerを使用した実装方針を明記する

**参照箇所:**
- 5.1節「患者API」「カルテAPI」
- 5.3節「認証・認可方式」

### C4. 予約APIの認可設計の欠如
**問題の詳細:**
`PUT /api/appointments/{id}`, `DELETE /api/appointments/{id}` において、予約の所有者確認（予約を作成した患者本人のみが変更・キャンセル可能）が設計されていません。また、`POST /api/appointments` において、リクエストボディの患者IDとJWTのユーザーIDの一致確認が明記されていません。

**影響分析:**
攻撃者が他人の予約を勝手にキャンセルしたり、変更したりできる可能性があります。医療予約システムにおいて、これは患者の診療機会の喪失につながり、健康被害のリスクがあります。

**対策:**
- `PUT /api/appointments/{id}`, `DELETE /api/appointments/{id}`: 予約のpatient_idとJWTのユーザーIDが一致することを検証する設計を追加する
- `POST /api/appointments`: リクエストボディのpatient_idとJWTのユーザーIDの一致を検証する設計を明記する
- 医療従事者や管理者による操作の場合は、適切な権限チェックを設計する

**参照箇所:**
- 5.1節「予約API」

## 重要な問題（Significant Issues）

### S1. CORS設定の未設計
**問題の詳細:**
React SPA（Web）とReact Native（モバイル）からのアクセスが想定されていますが（3.1節）、CORS（Cross-Origin Resource Sharing）の許可オリジンの設定が設計書に記載されていません。特に、認証情報を含むリクエストに対してワイルドカード（`Access-Control-Allow-Origin: *`）を使用すると重大な脆弱性となります。

**影響分析:**
CORS設定が不適切な場合、悪意のあるサイトから患者の認証情報を含むリクエストが送信され、個人情報が窃取される可能性があります。また、過度に緩い設定は意図しないオリジンからのアクセスを許可してしまいます。

**対策:**
- Spring Securityの`CorsConfigurationSource`で明示的に許可オリジンを設定する設計を追加する
- 本番環境では具体的なドメイン（例: `https://medical-app.example.com`）のみを許可する
- `allowCredentials=true`を設定し、ワイルドカードを使用しないことを明記する
- 開発環境と本番環境で異なるCORS設定を使用する方針を設計する

**参照箇所:**
- 3.1節「全体構成」
- セクション4「Input Validation & Attack Defense」の「Web Security Controls」で言及すべき内容

### S2. ファイルアップロード機能の設計不足
**問題の詳細:**
S3（Amazon S3）が画像・ドキュメントのストレージとして使用される（2.3節）とありますが、ファイルアップロード機能の詳細設計がありません。ファイルタイプ検証、サイズ制限、ストレージの分離設計が不明です。

**影響分析:**
悪意のあるファイル（実行可能ファイル、巨大ファイル、スクリプト埋め込み画像など）がアップロードされる可能性があり、XSS攻撃、DoS攻撃、ストレージコストの増大につながります。特に医療画像を装った悪意のあるファイルは重大なリスクです。

**対策:**
- 許可するファイルタイプを明示的に設計する（例: JPEG, PNG, PDF）
- MIMEタイプの検証だけでなく、ファイルマジックナンバーによる実ファイルタイプ検証を実装する
- 最大ファイルサイズを設計する（例: 10MB）
- アップロードされたファイルは患者ごと・医療機関ごとに分離したS3バケット/プレフィックスに保存する設計を追加する
- ファイルのダウンロードURLは署名付きURL（presigned URL）を使用し、有効期限を設定する

**参照箇所:**
- 2.3節「ストレージ: Amazon S3」
- セクション4「Input Validation & Attack Defense」の「Web Security Controls」で言及すべき内容

### S3. SQLインジェクション対策の部分的な記載
**問題の詳細:**
「SQLインジェクション対策としてPreparedStatementを使用する」（7.2節）とありますが、Spring Data JPAを使用している（2.4節）ため、JPQLやネイティブクエリにおける対策も必要です。特に動的クエリ構築やカスタムリポジトリメソッドにおける対策が不明です。

**影響分析:**
動的クエリで文字列連結を使用した場合、SQLインジェクション攻撃により患者データの全件取得、データ改ざん、データ削除が可能になります。医療データの漏洩は法的・倫理的に重大な問題です。

**対策:**
- Spring Data JPAのクエリメソッド（派生クエリ、`@Query`アノテーション）を使用し、パラメータバインディングを徹底する設計方針を明記する
- ネイティブクエリを使用する場合は、必ず名前付きパラメータまたは位置パラメータを使用することを設計ガイドラインに含める
- `Criteria API`を使用した動的クエリ構築方針を設計する
- カスタムリポジトリでの文字列連結を禁止するコーディング規約を設計に含める

**参照箇所:**
- 7.2節「セキュリティ要件」
- セクション4「Input Validation & Attack Defense」の「Injection Attack Defense」で言及すべき内容

### S4. 出力エスケープの設計欠如
**問題の詳細:**
XSS（Cross-Site Scripting）対策としての出力エスケープ機構が設計されていません。患者名、診断内容、処方薬などのユーザー入力データがReact UIに表示される際のエスケープ処理が不明です。

**影響分析:**
攻撃者が患者名や診断内容に悪意のあるスクリプトを埋め込むことで、他のユーザー（医療従事者や管理者）のブラウザで任意のJavaScriptが実行され、セッション乗っ取りや個人情報の窃取が可能になります。

**対策:**
- ReactのデフォルトエスケープがJSX内のテキストに適用されることを確認し、設計書に明記する
- `dangerouslySetInnerHTML`の使用を原則禁止し、やむを得ず使用する場合はDOMPurifyなどのサニタイゼーションライブラリを使用する設計を追加する
- Spring側でも`OWASP Java Encoder`などを使用したエスケープ層を設計する（多層防御）

**参照箇所:**
- セクション4「Input Validation & Attack Defense」の「Injection Attack Defense」で言及すべき内容
- 6.1節「エラーハンドリング方針」のエラーメッセージ表示においても重要

### S5. 監査ログの不完全な設計
**問題の詳細:**
6.2節にログ方針が記載されていますが、セキュリティ監査のための重要イベント（認証失敗、権限エラー、診察記録へのアクセス、患者情報の変更など）の明示的なログ設計がありません。すべてのAPIリクエストをINFOレベルでログ出力するとあるため、セキュリティイベントが埋もれる可能性があります。

**影響分析:**
セキュリティインシデント発生時の原因調査が困難になり、不正アクセスの検出が遅れます。医療データへの不正アクセスは法的報告義務があるため、監査証跡の欠如はコンプライアンス違反となります。

**対策:**
- 以下のイベントを明示的にSECURITYレベルで記録する設計を追加する:
  - 認証成功・失敗（ユーザーID、IPアドレス、タイムスタンプ）
  - 権限エラー（アクセス試行されたリソース、ユーザーID）
  - 診察記録の作成・更新・閲覧（患者ID、医師ID、操作内容）
  - 患者情報の変更（変更前後の値）
  - 管理者操作（医療機関の追加・削除など）
- 監査ログは改ざん防止のため、別のストレージ（CloudWatch Logs、S3）に転送し、保持期間を設計する（例: 7年間）

**参照箇所:**
- 6.2節「ロギング方針」
- セクション5「Infrastructure, Dependencies & Audit」で言及すべき内容

## 中程度の問題（Moderate Issues）

### M1. JWTトークンの保存方法の脆弱性
**問題の詳細:**
JWTトークンをlocalStorageに保存する設計（5.3節）は、XSS攻撃に対して脆弱です。JavaScriptから自由にアクセス可能なため、XSS脆弱性が存在する場合、攻撃者は容易にトークンを窃取できます。

**影響分析:**
XSS攻撃によりJWTトークンが窃取されると、攻撃者は被害者になりすまして任意の操作が可能になります。医療システムでは診察記録の改ざんや個人情報の窃取につながります。

**対策:**
- JWTトークンをHttpOnly属性付きのCookieに保存する設計に変更する
- Secure属性とSameSite=Strict属性も設定する
- リフレッシュトークンも同様にHttpOnly Cookieに保存する
- これによりJavaScriptからのアクセスを防ぎ、HTTPS通信のみで送信し、CSRF攻撃も防止できる

**参照箇所:**
- 5.3節「認証・認可方式」

### M2. エラーメッセージの情報漏洩リスク
**問題の詳細:**
エラーレスポンスに「詳細なスタックトレースを含め、デバッグを容易にする」（6.1節）とあります。本番環境でスタックトレースを返却すると、内部実装の詳細（使用ライブラリ、ファイルパス、データベース構造など）が漏洩し、攻撃者に有用な情報を提供してしまいます。

**影響分析:**
攻撃者はエラーメッセージから内部構造を推測し、より効果的な攻撃を実行できます。特にSQLインジェクションやパストラバーサル攻撃において、エラーメッセージは重要な手がかりとなります。

**対策:**
- 本番環境では一般的なエラーメッセージのみをユーザーに返却し、詳細なスタックトレースは内部ログにのみ記録する設計に変更する
- 開発環境と本番環境で異なるエラーハンドリング設定を使用する
- エラーIDを生成してユーザーに返却し、内部ログと紐付けることでサポート時の調査を可能にする

**参照箇所:**
- 6.1節「エラーハンドリング方針」

### M3. JWT署名アルゴリズムの未指定
**問題の詳細:**
JWTを使用する（5.3節）とありますが、署名アルゴリズム（HS256, RS256など）が指定されていません。また、署名鍵の管理方法も設計されていません。

**影響分析:**
弱い署名アルゴリズム（`none`アルゴリズムの許可など）を使用した場合、攻撃者は署名を偽造して任意のユーザーになりすますことができます。また、署名鍵がハードコードされていると、ソースコード漏洩時に全ユーザーのトークンが危殆化します。

**対策:**
- JWT署名アルゴリズムとしてRS256（非対称鍵）を使用する設計を明記する
- `none`アルゴリズムは明示的に拒否する設定を追加する
- 署名鍵はAWS Secrets Managerまたは環境変数から取得し、定期的にローテーションする設計を追加する
- 鍵ローテーション時の既存トークンの扱い（猶予期間など）を設計する

**参照箇所:**
- 5.3節「認証・認可方式」

### M4. 入力検証の具体的な設計不足
**問題の詳細:**
「外部入力はSpring Validationで検証し」（7.2節）とありますが、具体的な検証ルール（氏名の文字数制限、メールアドレス形式、電話番号形式など）が設計されていません。

**影響分析:**
入力検証が不十分な場合、異常に長い文字列によるバッファオーバーフロー、特殊文字によるインジェクション攻撃、不正な形式のデータによるビジネスロジックエラーが発生する可能性があります。

**対策:**
- 主要フィールドに対する検証ルールを設計書に明記する:
  - 氏名: 1-100文字、許可文字（Unicode文字、スペース、ハイフン）
  - メールアドレス: RFC 5322準拠、最大254文字
  - 電話番号: 数字とハイフン、10-15文字
  - パスワード: 8-100文字、大小英字・数字・記号を含む
- Spring Validationの`@NotNull`, `@Size`, `@Email`, `@Pattern`などのアノテーションを使用する実装方針を追加する
- カスタムバリデータの作成方針も設計する

**参照箇所:**
- 7.2節「セキュリティ要件」
- セクション4「Input Validation & Attack Defense」で具体化すべき内容

### M5. 第三者ライブラリの脆弱性管理方針の不足
**問題の詳細:**
「第三者ライブラリの脆弱性管理ポリシー」が評価基準（セクション5）に含まれていますが、設計書には具体的な管理方針が記載されていません。使用ライブラリは列挙されています（2.4節）が、脆弱性スキャンや更新ポリシーが不明です。

**影響分析:**
既知の脆弱性を持つライブラリを使用し続けることで、攻撃者に悪用される可能性があります。特に公開されている脆弱性（CVE）は自動スキャンツールで容易に発見されます。

**対策:**
- GitHub Dependabotまたは`OWASP Dependency-Check`を使用した自動脆弱性スキャンをCIパイプラインに組み込む設計を追加する
- 脆弱性検出時の対応フロー（重大度に応じた修正期限など）を設計する
- ライブラリのバージョン管理ポリシー（最新の安定版を使用、セキュリティパッチの適用など）を明記する
- 四半期ごとの依存関係レビューを実施する方針を追加する

**参照箇所:**
- セクション5「Infrastructure, Dependencies & Audit」で言及すべき内容
- 6.4節「デプロイメント方針」にCIパイプラインの一部として含めるべき

### M6. シークレット管理の部分的な設計
**問題の詳細:**
「環境変数はECS Task Definitionに記載し、AWS Systems Manager Parameter Storeから取得」（6.4節）とありますが、JWT署名鍵、データベースパスワード、APIキーなどの重要なシークレットの管理方針が不完全です。また、シークレットのローテーション方針が不明です。

**影響分析:**
シークレットが不適切に管理されると、ソースコードリポジトリへの誤ったコミット、ログファイルへの出力、開発者の離職後のアクセス継続などのリスクがあります。

**対策:**
- JWT署名鍵、データベースパスワード、外部APIキーなどは AWS Secrets Manager に保存する設計に変更する（Parameter Storeよりも自動ローテーション機能が強力）
- 開発環境と本番環境で異なるシークレットを使用し、アクセス制御を厳格にする設計を追加する
- シークレットのローテーションポリシー（例: 90日ごと）を設計する
- アプリケーション起動時にシークレットを取得し、メモリ内で保持する方式を明記する
- シークレットがログに出力されないようにするロギング設定を追加する

**参照箇所:**
- 6.4節「デプロイメント方針」
- セクション5「Infrastructure, Dependencies & Audit」で詳細化すべき内容

### M7. パスワードポリシーの不足
**問題の詳細:**
パスワードは「bcryptアルゴリズム（コスト係数10）でハッシュ化する」（7.2節）とありますが、パスワードの複雑性要件（長さ、文字種など）が設計されていません。

**影響分析:**
弱いパスワード（例: "123456"）が許可されると、ブルートフォース攻撃や辞書攻撃により容易にアカウントが侵害されます。医療システムでは患者データへの不正アクセスにつながります。

**対策:**
- パスワードポリシーを設計する:
  - 最小長: 8文字（推奨: 12文字以上）
  - 大文字、小文字、数字、記号をそれぞれ1文字以上含む
  - よく使われるパスワード（"password123"など）を禁止リストで拒否
  - ユーザー名や氏名を含むパスワードを拒否
- パスワード変更の強制周期（例: 90日）を設計する
- パスワード履歴を保持し、過去のパスワードの再使用を防止する

**参照箇所:**
- 7.2節「セキュリティ要件」
- 5.1節「認証API」でパスワードポリシーの検証を明記すべき

## 軽微な改善提案（Minor Improvements）

### I1. API Gatewayのレート制限の詳細化
**問題の詳細:**
API Gatewayのレート制限が「1分あたり100リクエスト」（3.2節）とありますが、これが全体の制限なのか、ユーザーごとの制限なのか不明です。

**対策:**
- レート制限の粒度を明記する（IPアドレスごと、ユーザーごと、APIキーごとなど）
- エンドポイントごとに異なる制限を設定する方針を検討する（例: 予約作成は1分あたり10回、検索は1分あたり100回）

**参照箇所:**
- 3.2節「API Gateway」

### I2. HTTPSの強制設定
**問題の詳細:**
「すべての通信をTLS 1.3で暗号化する」（7.2節）とありますが、HTTPからHTTPSへのリダイレクト設計が明記されていません。

**対策:**
- API GatewayまたはALBレベルでHTTPリクエストを自動的にHTTPSにリダイレクトする設定を追加する
- HSTSヘッダー（Strict-Transport-Security）を設定し、ブラウザに常にHTTPSを使用させる設計を追加する

**参照箇所:**
- 7.2節「セキュリティ要件」

### I3. セキュリティヘッダーの設計
**問題の詳細:**
XSS、クリックジャッキング、MIMEスニッフィングなどを防止するセキュリティヘッダー（Content-Security-Policy, X-Frame-Options, X-Content-Type-Optionsなど）の設計が含まれていません。

**対策:**
- 以下のセキュリティヘッダーをレスポンスに含める設計を追加する:
  - `Content-Security-Policy`: スクリプトやスタイルの読み込み元を制限
  - `X-Frame-Options: DENY`: クリックジャッキング防止
  - `X-Content-Type-Options: nosniff`: MIMEスニッフィング防止
  - `Referrer-Policy: strict-origin-when-cross-origin`: リファラー情報の制御
- Spring SecurityのHeadersConfigurerを使用した実装方針を明記する

**参照箇所:**
- 7.2節「セキュリティ要件」に追加すべき内容

## ポジティブな側面

### P1. 基本的な暗号化の実装
TLS 1.3の使用とbcryptによるパスワードハッシュ化（コスト係数10）は適切な設計です。これにより通信の盗聴とパスワードの平文保存のリスクが軽減されています。

### P2. 構造化ロギングの採用
JSON形式の構造化ログ（6.2節）により、ログ分析とセキュリティ監視が容易になります。CloudWatch Logsとの統合により、集中管理とアラート設定が可能です。

### P3. Multi-AZ構成による可用性
データベースのMulti-AZ構成（7.3節）により、障害時の自動フェイルオーバーが可能であり、医療システムに求められる高可用性を実現できます。

### P4. JWTベースの認証設計
JWTを使用したステートレスな認証設計（5.3節）は、スケーラビリティと分散システムへの適合性が高く、適切な選択です。ただし、トークンの保存方法（M1で指摘）の改善が必要です。

## まとめ

本設計書は医療予約システムの基本的なアーキテクチャを定義していますが、**セキュリティ設計において重大な欠陥が複数存在します**。特に以下の4点は早急に対処すべき重大リスクです：

1. **CSRF保護の欠如**（C1）: 状態変更APIに対する保護が必須
2. **認証エンドポイントのレート制限不足**（C2）: ブルートフォース攻撃のリスク
3. **カルテAPIの認可設計の欠如**（C3）: 患者データへの不正アクセスのリスク
4. **予約APIの認可設計の欠如**（C4）: 他人の予約操作のリスク

医療データを扱うシステムとして、個人情報保護法、医療法、GDPR（将来的な海外展開時）などの法的要件を満たすため、上記の重大問題の解決は必須です。また、セキュリティインシデント発生時の監査証跡として、適切な監査ログ設計（S5）も不可欠です。

設計フェーズでこれらの問題を修正することで、実装後の大規模な設計変更を回避できます。
