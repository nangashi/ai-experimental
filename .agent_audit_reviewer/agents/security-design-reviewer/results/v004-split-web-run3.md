# セキュリティ設計レビュー: リアルタイム医療予約システム

## 重大な問題（Critical Issues）

### C1: カルテAPI・患者情報APIにおける認可設計の完全欠落

**影響**: データベース内の全患者の医療記録・個人情報への無制限アクセスが可能となり、医療情報漏洩による法的責任、患者プライバシー侵害、HIPAA/個人情報保護法違反のリスクが極めて高い。

**詳細分析**:
以下のエンドポイントで、リソース所有権検証・所属確認の設計が明記されていない:

- `GET /api/patients/{id}`: 任意の患者IDを指定することで、他患者の氏名・生年月日・住所・電話番号・保険証番号を取得可能
- `PUT /api/patients/{id}`: 他患者の個人情報を改ざん可能
- `GET /api/patients/{id}/records`: 他患者の診察履歴・診断内容・処方薬情報を取得可能
- `GET /api/records/{id}`: 診察記録IDを列挙することで全患者のカルテにアクセス可能
- `POST /api/records`: 任意の患者IDに対して偽の診察記録を作成可能
- `PUT /api/records/{id}`: 他患者のカルテを改ざん可能

設計書5.3節では「ロールベースアクセス制御（RBAC）により、エンドポイントごとに必要なロールを定義」とあるが、ロール確認のみでは不十分。医療従事者は「DOCTOR」ロールを持つが、全患者のカルテにアクセスすべきではない。

**対策**:
1. **患者本人確認**: `/api/patients/{id}`へのアクセス時、JWTペイロードのuserIdと対象患者のuser_idを照合し、本人以外のアクセスを拒否
2. **医療従事者の診療権限確認**: `/api/records/*`へのアクセス時、医師が担当する医療機関・診療科と予約レコードの紐付けを検証。設計書に「医師-医療機関の所属関係テーブル」を追加し、担当外患者のカルテアクセスを防止
3. **予約ベースの閲覧制限**: 診察記録の閲覧は、確定済み予約(appointments.status=CONFIRMED)の存在を前提条件とする
4. **管理者権限の監査ログ**: ADMIN ロールによるアクセスは全件監査ログに記録し、不正アクセス検知を可能にする

**参照箇所**: 5.1節（API設計）、5.3節（認証・認可方式）

---

### C2: 予約APIにおける認可設計の欠落による不正予約操作

**影響**: 他患者の予約を無断でキャンセル・変更可能となり、医療サービスの妨害、患者の健康リスク、医療機関の信頼性低下につながる。

**詳細分析**:
以下のエンドポイントで、予約所有権検証の設計が明記されていない:

- `PUT /api/appointments/{id}`: 任意の予約IDを指定し、他患者の予約日時・診療科を変更可能
- `DELETE /api/appointments/{id}`: 他患者の予約を一方的にキャンセル可能

設計書3.3節「データフロー」では「Spring Securityが各エンドポイントでJWT検証」とあるが、これは認証（本人確認）のみで、認可（操作権限確認）の設計が欠落している。

**対策**:
1. **所有権検証**: `PUT/DELETE /api/appointments/{id}`実行時、対象予約のpatient_idとJWTペイロードのuserIdから導出される患者IDを照合
2. **医療機関側の権限設計**: 医療従事者による予約変更を許可する場合、対象予約のinstitution_idと医師の所属機関を照合
3. **ステータス遷移制御**: 予約キャンセルは「PENDING→CANCELLED」「CONFIRMED→CANCELLED」のみ許可し、すでにCANCELLED状態の予約への操作を拒否
4. **監査ログ**: 予約の変更・キャンセル操作を全件記録し、不正操作の追跡を可能にする

**参照箇所**: 5.1節（API設計）、4.2節（appointmentsテーブル）

---

### C3: JWT トークンのlocalStorage保存によるXSS脆弱性リスク

**影響**: XSS攻撃により認証トークンが窃取され、攻撃者が正規ユーザーとしてシステムにアクセス可能となり、医療記録の閲覧・改ざん、予約の不正操作が実行される。

**詳細分析**:
設計書5.3節で「JWTトークンはlocalStorageに保存し、各APIリクエストのAuthorizationヘッダーで送信する」と明記されている。localStorageはJavaScriptから自由にアクセス可能なため、XSS攻撃が成功すると`localStorage.getItem('token')`でトークンを窃取される。

医療システムでは診察記録・個人情報といった高感度データを扱うため、トークン窃取の影響が極めて大きい。特にReact SPAでは第三者ライブラリの脆弱性や開発者のコーディングミスによりXSSが発生する可能性が常に存在する。

**対策**:
1. **httpOnly Cookie への移行**: JWTをhttpOnly属性付きCookieに格納し、JavaScriptからのアクセスを完全に遮断
2. **Secure属性・SameSite属性の設定**: `Set-Cookie: token=...; HttpOnly; Secure; SameSite=Strict`によりHTTPS通信のみでCookieを送信し、CSRF対策も強化
3. **CSP（Content Security Policy）の導入**: `Content-Security-Policy: script-src 'self'`等の設定により、インラインスクリプト実行を制限しXSS発生リスクを低減
4. **トークンの短期化**: アクセストークンの有効期限を15分に短縮し、リフレッシュトークン（httpOnly Cookie）で更新する設計に変更。窃取時の悪用期間を最小化

**参照箇所**: 5.3節（認証・認可方式）

---

## 重要な問題（Significant Issues）

### S1: ログイン・認証エンドポイントにおけるレート制限設計の欠落

**影響**: ブルートフォース攻撃により、辞書攻撃や総当たり攻撃でパスワードが破られ、患者アカウント・医療従事者アカウントへの不正ログインが発生。医療記録の不正閲覧・改ざん、予約の不正操作につながる。

**詳細分析**:
設計書3.2節で「API Gateway」のレート制限は「1分あたり100リクエスト」と記載されているが、これは全エンドポイント共通の設定と推測される。以下の認証関連エンドポイントで、個別のレート制限設計が明記されていない:

- `POST /api/auth/login`: 同一ユーザー名に対する連続ログイン試行を制限する設計がない
- `POST /api/auth/refresh`: リフレッシュトークンの濫用を防ぐ制限がない
- `POST /api/auth/register`: 大量のアカウント作成によるリソース枯渇攻撃のリスク

API Gateway全体で100req/minの制限があっても、1分間に100回のログイン試行は可能であり、8桁英数字パスワードなら現実的な時間で破られる可能性がある。

**対策**:
1. **ログインエンドポイントの個別レート制限**: 同一IPアドレスから`/api/auth/login`への試行を「5回/5分」に制限。失敗回数に応じて指数バックオフ（10秒→1分→5分）を実装
2. **アカウント単位のロックアウト**: 同一ユーザー名に対して連続5回ログイン失敗した場合、15分間そのアカウントへのログインを禁止
3. **リフレッシュトークンのレート制限**: `/api/auth/refresh`を「10回/時間」に制限し、窃取されたリフレッシュトークンの濫用を抑制
4. **CAPTCHA の導入**: 3回連続ログイン失敗後、CAPTCHA認証を要求し自動化攻撃を防止
5. **監査ログと異常検知**: 連続ログイン失敗を記録し、管理者に通知する仕組みを設計

**参照箇所**: 3.2節（主要コンポーネント）、5.1節（認証API）

---

### S2: CSRF・CORS設計の完全欠落による認証セッションハイジャックリスク

**影響**: 悪意あるWebサイト経由でユーザーの意図しない予約作成・キャンセル、カルテ改ざんが実行される。医療サービスの妨害、患者データの不正操作につながる。

**詳細分析**:
設計書全体でCSRF（Cross-Site Request Forgery）対策・CORS（Cross-Origin Resource Sharing）設定の記載が一切ない。以下の状態変更APIで特にCSRFリスクが高い:

- `POST /api/appointments`: 攻撃者サイトから被害者の認証情報で予約を勝手に作成
- `DELETE /api/appointments/{id}`: 重要な予約を一方的にキャンセル
- `POST /api/records`: 偽の診察記録を作成
- `PUT /api/patients/{id}`: 患者の連絡先情報を改ざん

JWTをlocalStorageに保存する現行設計では、攻撃者サイトからJavaScript経由でlocalStorageを読み取ることは不可（Same-Origin Policy）だが、被害者が攻撃者サイトを閲覧中に正規サイトへのリクエストを発行させることは可能。

**対策**:
1. **CSRF トークンの導入**: Spring SecurityのCsrfTokenRepositoryを有効化し、すべての状態変更API（POST/PUT/DELETE）でCSRFトークンを検証
2. **SameSite Cookie 属性の設定**: httpOnly Cookieに移行した場合、`SameSite=Strict`属性により他サイトからのCookie送信を完全に遮断
3. **CORS 設定の明示化**: 許可するオリジンを明示的にホワイトリスト化（例: `https://医療予約サイト.example.com`）し、ワイルドカード（`Access-Control-Allow-Origin: *`）を禁止
4. **Preflight リクエストの検証**: カスタムヘッダー（`X-Requested-With: XMLHttpRequest`）を要求し、単純なフォーム送信によるCSRF攻撃を防止

**参照箇所**: 5.1節（API設計）、5.3節（認証・認可方式）

---

### S3: 医療記録・患者データの暗号化設計の欠落

**影響**: データベース侵害時、診断内容・処方薬・保険証番号などの機密情報が平文で漏洩し、患者プライバシー侵害、法的責任、医療機関の信頼性低下につながる。

**詳細分析**:
設計書7.2節で「すべての通信をTLS 1.3で暗号化する」と記載されているが、これは通信経路（transit）の保護のみであり、保存データ（at rest）の暗号化設計がない。以下のテーブルで機密データが平文保存される:

- `patients.insurance_number`: 保険証番号（個人識別情報）
- `medical_records.diagnosis`: 診断内容（医療機密情報）
- `medical_records.prescription`: 処方薬情報（医療機密情報）
- `medical_records.lab_results`: 検査結果（医療機密情報）

データベースサーバーへのSSHアクセス権限を持つ内部犯、バックアップメディアの物理的窃取、SQLインジェクション攻撃によるデータダンプ等のシナリオで、暗号化されていないデータが大量に流出するリスクがある。

**対策**:
1. **データベースレベルの暗号化**: Amazon RDS のストレージ暗号化（AWS KMS）を有効化し、データベースファイル・バックアップ・レプリカを自動暗号化
2. **アプリケーションレベルの列暗号化**: 特に機密性の高いカラム（insurance_number, diagnosis, prescription, lab_results）をAES-256で暗号化してから保存。Spring Crypto Moduleやデータベースの暗号化関数を使用
3. **キー管理設計**: AWS Secrets Manager または AWS KMS で暗号化キーを管理し、アプリケーションからのキーアクセスをIAMロールで制御
4. **データ分類とポリシー定義**: PIIデータ（保険証番号、生年月日、住所）と医療記録データを分類し、それぞれの暗号化要件・保持期間・削除ポリシーを設計書に明記

**参照箇所**: 4.2節（テーブル設計）、7.2節（セキュリティ要件）

---

## 中程度の問題（Moderate Issues）

### M1: 監査ログ設計の不完全性

**影響**: セキュリティインシデント発生時、攻撃経路・被害範囲の特定が困難となり、法的対応・再発防止策の策定が遅延する。

**詳細分析**:
設計書6.2節で「すべてのAPIリクエスト・レスポンスをINFOレベルでログ出力」と記載されているが、セキュリティ監査の観点で不十分:

1. **認証失敗の記録がない**: ログイン失敗・JWT検証失敗の記録設計が明記されていない
2. **機密データへのアクセス追跡がない**: 誰がいつどの患者のカルテを閲覧したか追跡できない
3. **権限変更の記録がない**: 管理者によるユーザーロール変更の監査証跡がない
4. **ログの改ざん防止設計がない**: ログファイル自体へのアクセス制御・整合性検証の設計がない

**対策**:
1. **セキュリティイベントの明示的ログ設計**:
   - 認証失敗: username, IPアドレス, User-Agent, 失敗理由
   - 認可失敗: userId, 要求エンドポイント, 要求リソースID, 拒否理由
   - 機密データアクセス: userId, アクセス対象（患者ID, 診察記録ID）, 操作種別（読取/更新/削除）
   - 管理者操作: 対象ユーザー, 変更内容（ロール変更, アカウント削除等）

2. **ログの保護**:
   - CloudWatch Logs のログストリームに対する書き込み専用IAMロールを設定し、アプリケーションからログの削除・変更を禁止
   - ログの保持期間を最低1年間に設定（医療記録の法的保存期間に準拠）

3. **異常検知アラート**: CloudWatch Insightsで以下のパターンを検知し管理者に通知
   - 同一IPからの連続ログイン失敗（5回以上/5分）
   - 深夜時間帯の大量カルテアクセス（10件以上/時）
   - 患者以外による患者情報APIへのアクセス

**参照箇所**: 6.2節（ロギング方針）

---

### M2: エラーレスポンスにおける情報漏洩リスク

**影響**: 攻撃者がエラーメッセージから内部実装・データベーススキーマ・ファイルパスを推測し、より高度な攻撃の足がかりとなる。

**詳細分析**:
設計書6.1節で「エラーメッセージには詳細なスタックトレースを含め、デバッグを容易にする」と記載されているが、これは本番環境では重大なセキュリティリスク:

- スタックトレースからJavaクラス名・メソッド名・ファイルパスが露出
- データベースエラーからテーブル名・カラム名・制約条件が判明
- バリデーションエラーから内部的なフィールド名・検証ロジックが推測可能

例: SQLインジェクション試行時に「ERROR: syntax error at or near "'"」といったPostgreSQLエラーが返ると、攻撃者はデータベースの種類・バージョンを特定できる。

**対策**:
1. **環境別エラーレスポンス設計**:
   - 本番環境: 汎用的なエラーメッセージのみ返却（例: "An error occurred. Please contact support."）
   - 開発環境: 詳細なスタックトレース・デバッグ情報を含める

2. **エラーコードの導入**: 内部的なエラー種別を一意なコード（例: ERR-AUTH-001, ERR-DB-003）で識別し、ログには詳細情報を記録しつつ、クライアントには最小限の情報のみ返却

3. **例外ハンドリングの統一**: Spring Boot の`@ControllerAdvice`で全例外を捕捉し、環境変数（`SPRING_PROFILES_ACTIVE=production`）に応じてレスポンスをフィルタリング

4. **バリデーションエラーの抽象化**: 「Invalid email format」ではなく「Invalid input」と返し、具体的なフィールド名を隠蔽

**参照箇所**: 6.1節（エラーハンドリング方針）

---

### M3: 依存ライブラリの脆弱性管理方針の欠落

**影響**: 既知の脆弱性を持つライブラリ（Spring Boot, Spring Security, React等）を長期間使用し続け、攻撃者による悪用のリスクが高まる。

**詳細分析**:
設計書2.4節で主要ライブラリのバージョンは記載されているが、脆弱性管理・更新ポリシーの設計がない:

- Spring Security 6.2: CVE検索の定期実行設計がない
- React 18.3: 既知のXSS脆弱性への対応方針がない
- PostgreSQL 16: セキュリティパッチ適用の運用設計がない

医療システムでは長期運用が前提であり、リリース後数年間にわたって脆弱性対応が必要となる。

**対策**:
1. **自動脆弱性スキャンの導入**: GitHub Dependabot または Snyk を CI/CD パイプラインに統合し、Pull Request 作成時に依存ライブラリの脆弱性を自動検出

2. **更新ポリシーの定義**:
   - Critical/High 脆弱性: 検出後7日以内にパッチ適用
   - Medium 脆弱性: 検出後30日以内に対応
   - Low 脆弱性: 次回メンテナンスウィンドウで対応

3. **依存関係の固定とレビュー**: `pom.xml`, `package-lock.json` で依存バージョンを固定し、更新時はセキュリティレビュー・回帰テストを実施

4. **脆弱性データベースの定期確認**: NVD（National Vulnerability Database）、Spring Security Advisory を月次で確認し、影響評価を実施

**参照箇所**: 2.4節（主要ライブラリ）

---

## 軽微な改善提案（Minor Improvements）

### I1: JWT署名アルゴリズムの明示化

現在の設計書では JWT の署名アルゴリズムが明記されていない。HS256（共通鍵）を使用する場合、秘密鍵の漏洩リスクがある。

**推奨**: RS256（公開鍵暗号）を採用し、秘密鍵はバックエンドのみが保持、公開鍵は各サービスで検証可能にする設計を明記する。

**参照箇所**: 5.3節（認証・認可方式）

---

### I2: パスワードポリシーの明示化

bcryptのコスト係数10は記載されているが、パスワードの最小長・複雑性要件が設計されていない。

**推奨**: 最小12文字、大文字・小文字・数字・記号の組み合わせを要求するポリシーを設計書に追加する。

**参照箇所**: 7.2節（セキュリティ要件）

---

### I3: セッションタイムアウトの設計

JWT有効期限は1時間と記載されているが、ユーザーの無操作時の自動ログアウト設計がない。

**推奨**: フロントエンドで最終操作から30分間無操作の場合、自動ログアウトする設計を追加する。

**参照箇所**: 5.3節（認証・認可方式）

---

## 評価まとめ

本設計書は基本的な技術スタック・データモデル・API設計は整備されているが、**認可設計の欠落**という根本的なセキュリティ問題が存在します。特に医療システムでは患者データ保護が最優先であり、以下の3点は必須対応事項です:

1. **全エンドポイントにおける認可ロジックの明示的設計** (C1, C2)
2. **認証トークンのセキュアな保存方式への変更** (C3)
3. **保存データの暗号化設計** (S3)

また、CSRF/CORS対策（S2）、レート制限（S1）、監査ログ（M1）の設計を追加することで、実運用に耐えうるセキュリティレベルに到達できます。
