# 商品レビュー機能追加 - 開発計画書

## セクション1: 概要

### 1.1 機能概要
ECサイト「ShopNow」に商品レビュー機能を追加します。ユーザーは購入した商品に対して星評価・テキスト・画像を含むレビューを投稿でき、商品詳細ページでレビュー一覧と平均評価を閲覧できます。管理者はレビューの削除およびフラグ付けが可能です。

### 1.2 技術スタック
- **バックエンド**: Node.js + Express
- **データベース**: PostgreSQL
- **ストレージ**: S3互換ストレージ
- **フロントエンド**: React + TypeScript
- **テスト**: Jest + supertest

### 1.3 アーキテクチャパターン
既存コードベースに準拠し、Controller → Service → Repository の3層アーキテクチャを採用します。

### 1.4 重大な設計問題と改善方針

提示されたレビューチームの実装案には、以下の重大な問題があります。本計画ではこれらを修正した設計を提示します。

#### 問題1: XSS脆弱性（CRITICAL）
- **問題**: HTMLリッチテキストを `dangerouslySetInnerHTML` で無害化せずに表示
- **対策**: サーバーサイドでDOMPurifyを使用してHTMLをサニタイズし、安全なHTMLのみを保存・配信

#### 問題2: 責務分離の違反
- **問題**: ControllerでDB直接操作、Modelクラスにビジネスロジック・通知・レポート生成が混在
- **対策**: 
  - ControllerはHTTPハンドリングのみ
  - Serviceにビジネスロジックを配置
  - Repositoryでデータアクセスを抽象化
  - Modelはデータ構造の定義のみ（既存パターンに準拠）

#### 問題3: パフォーマンス問題
- **問題**: 平均評価をフロントエンド・バックエンドで毎回全レビューから計算
- **対策**: 
  - `products` テーブルに `average_rating`, `review_count` カラムを追加
  - レビュー作成・削除時にトランザクション内で更新
  - 商品詳細APIで事前計算済みの値を返却

#### 問題4: エラーハンドリングの欠如
- **問題**: try-catch未使用、バリデーション不足
- **対策**: 既存パターンに従いtry-catch + next(error)、カスタムエラークラスを使用

#### 問題5: 画像アップロードの曖昧さ
- **問題**: "適当なものを使う"という不明確な指示
- **対策**: 
  - `aws-sdk` (v3) を使用してS3にアップロード
  - 署名付きURLを生成してクライアント側から直接アップロード
  - アップロード完了後にURLをレビュー作成APIに送信

---

## セクション2: ディレクトリ/ファイル設計

### 2.1 新規作成ファイル一覧

```
src/
├── controllers/
│   └── reviewController.ts          [新規] レビューのHTTPハンドリング
├── services/
│   ├── reviewService.ts              [新規] レビューのビジネスロジック
│   └── imageUploadService.ts         [新規] S3署名付きURL生成
├── repositories/
│   ├── reviewRepository.ts           [新規] レビューのデータアクセス
│   └── productRepository.ts          [変更] 平均評価更新メソッド追加
├── models/
│   └── Review.ts                     [新規] レビューのデータ構造定義
├── middleware/
│   ├── auth.ts                       [既存] 認証ミドルウェア（変更なし）
│   └── sanitize.ts                   [新規] HTMLサニタイズミドルウェア
├── utils/
│   ├── validator.ts                  [変更] レビューバリデーション追加
│   ├── sanitizer.ts                  [新規] DOMPurifyラッパー
│   └── errors.ts                     [変更] ValidationError等のカスタムエラー
├── routes/
│   └── index.ts                      [変更] レビューエンドポイント追加
├── __tests__/
│   ├── review.test.ts                [新規] レビュー機能のテスト
│   ├── reviewService.test.ts         [新規] Serviceレイヤーのテスト
│   └── imageUpload.test.ts           [新規] 画像アップロードのテスト
└── migrations/
    ├── 001_create_reviews_table.sql  [新規] reviewsテーブル作成
    └── 002_add_rating_to_products.sql [新規] productsテーブル拡張
```

### 2.2 ファイル責務定義

| ファイル | 責務 | 主要メソッド |
|---------|------|------------|
| `reviewController.ts` | HTTPリクエスト/レスポンス処理、パラメータ抽出、エラーハンドリング | `createReview`, `getProductReviews`, `deleteReview`, `flagReview`, `getUploadUrl` |
| `reviewService.ts` | ビジネスロジック、トランザクション制御、平均評価更新 | `createReview`, `getReviewsByProductId`, `deleteReview`, `flagReview`, `updateProductRating` |
| `imageUploadService.ts` | S3署名付きURL生成、画像パス検証 | `generateUploadUrl`, `validateImagePath` |
| `reviewRepository.ts` | SQL実行、レビューCRUD操作 | `create`, `findByProductId`, `findById`, `delete`, `updateFlag` |
| `Review.ts` | レビューのデータ構造定義（インターフェース） | - |
| `sanitize.ts` | リクエストボディのHTMLサニタイズ | `sanitizeMiddleware` |
| `sanitizer.ts` | DOMPurifyを使ったHTML浄化 | `sanitizeHtml` |

---

## セクション3: アーキテクチャ設計

### 3.1 データモデル設計

#### 3.1.1 Review型定義

```typescript
// src/models/Review.ts
export interface Review {
  id: string;
  productId: string;
  userId: string;
  rating: number;        // 1-5
  title: string;         // 最大200文字
  body: string;          // サニタイズ済みHTML
  images: string[];      // S3のURL配列（最大3件）
  flagged: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateReviewDto {
  productId: string;
  rating: number;
  title: string;
  body: string;          // サニタイズ前のHTML
  images: string[];
}

export interface ReviewSummary {
  averageRating: number;
  reviewCount: number;
}
```

#### 3.1.2 Product型拡張

```typescript
// src/models/Product.ts（既存ファイルに追加）
export interface Product {
  id: string;
  name: string;
  price: number;
  // ... 既存フィールド
  averageRating: number;   // [追加] 平均評価（非正規化）
  reviewCount: number;     // [追加] レビュー件数
}
```

### 3.2 データベース設計

#### 3.2.1 reviewsテーブル

```sql
-- migrations/001_create_reviews_table.sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  images TEXT[] DEFAULT '{}',
  flagged BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_reviews_product_id ON reviews(product_id);
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
CREATE INDEX idx_reviews_flagged ON reviews(flagged) WHERE flagged = true;

-- 同一ユーザーが同一商品に複数レビュー投稿を防止
CREATE UNIQUE INDEX idx_reviews_unique_user_product ON reviews(product_id, user_id);
```

#### 3.2.2 productsテーブル拡張

```sql
-- migrations/002_add_rating_to_products.sql
ALTER TABLE products 
  ADD COLUMN average_rating NUMERIC(3,2) DEFAULT 0.00 CHECK (average_rating >= 0 AND average_rating <= 5),
  ADD COLUMN review_count INTEGER DEFAULT 0 CHECK (review_count >= 0);

CREATE INDEX idx_products_average_rating ON products(average_rating DESC);

-- 既存商品の初期値を計算（既存レビューがある場合）
UPDATE products p
SET 
  average_rating = COALESCE((SELECT AVG(rating) FROM reviews WHERE product_id = p.id), 0),
  review_count = (SELECT COUNT(*) FROM reviews WHERE product_id = p.id);
```

### 3.3 APIエンドポイント設計

#### 3.3.1 レビューAPI

| メソッド | パス | 認証 | 説明 |
|---------|------|-----|------|
| POST | `/api/products/:productId/reviews` | 必須 | レビュー作成 |
| GET | `/api/products/:productId/reviews` | 不要 | 商品のレビュー一覧取得 |
| DELETE | `/api/reviews/:reviewId` | 管理者 | レビュー削除 |
| PATCH | `/api/reviews/:reviewId/flag` | 管理者 | レビューフラグ設定 |
| GET | `/api/reviews/upload-url` | 必須 | 画像アップロード用署名付きURL取得 |

#### 3.3.2 リクエスト/レスポンス仕様

**POST `/api/products/:productId/reviews`**

```typescript
// Request Body
{
  "rating": 5,
  "title": "素晴らしい商品です",
  "body": "<p>とても満足しています。<strong>おすすめ</strong>です。</p>",
  "images": [
    "https://s3.example.com/reviews/abc123.jpg",
    "https://s3.example.com/reviews/def456.jpg"
  ]
}

// Response (201 Created)
{
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "productId": "...",
    "userId": "...",
    "rating": 5,
    "title": "素晴らしい商品です",
    "body": "<p>とても満足しています。<strong>おすすめ</strong>です。</p>", // サニタイズ済み
    "images": ["https://s3.example.com/reviews/abc123.jpg", "..."],
    "flagged": false,
    "createdAt": "2026-02-06T10:00:00Z",
    "updatedAt": "2026-02-06T10:00:00Z"
  },
  "productRating": {
    "averageRating": 4.75,
    "reviewCount": 24
  }
}
```

**GET `/api/products/:productId/reviews`**

```typescript
// Response (200 OK)
{
  "data": [
    {
      "id": "...",
      "productId": "...",
      "userId": "...",
      "userName": "山田太郎", // JOIN で取得
      "rating": 5,
      "title": "素晴らしい商品です",
      "body": "<p>とても満足しています。<strong>おすすめ</strong>です。</p>",
      "images": ["https://s3.example.com/reviews/abc123.jpg"],
      "flagged": false,
      "createdAt": "2026-02-06T10:00:00Z",
      "updatedAt": "2026-02-06T10:00:00Z"
    }
    // ... 他のレビュー
  ],
  "summary": {
    "averageRating": 4.75,
    "reviewCount": 24
  }
}
```

**GET `/api/reviews/upload-url`**

```typescript
// Query Parameters
?fileName=review-image.jpg&contentType=image/jpeg

// Response (200 OK)
{
  "uploadUrl": "https://s3.example.com/reviews/upload/...",  // 署名付きURL
  "imageUrl": "https://s3.example.com/reviews/abc123.jpg",   // 保存後のアクセスURL
  "expiresIn": 300  // 秒
}
```

### 3.4 セキュリティ設計

#### 3.4.1 XSS対策
- **サーバーサイドHTMLサニタイズ**: `isomorphic-dompurify` を使用してレビュー作成時に `body` フィールドをサニタイズ
- **許可タグ**: `<p>`, `<br>`, `<strong>`, `<em>`, `<ul>`, `<ol>`, `<li>`, `<a>` (href属性はhttp/httpsのみ)
- **禁止要素**: `<script>`, `<iframe>`, `<object>`, `on*` イベントハンドラ、`javascript:` スキーム

#### 3.4.2 認証・認可
- レビュー作成: `auth.ts` ミドルウェアでJWT検証、`req.user.id` を使用
- レビュー削除/フラグ設定: `req.user.role === 'admin'` のチェック追加

#### 3.4.3 入力検証
- `rating`: 1-5の整数
- `title`: 1-200文字
- `body`: 1-5000文字（サニタイズ前）
- `images`: 配列要素数0-3、各要素は有効なHTTPS URL

#### 3.4.4 S3アクセス制御
- 署名付きURLは5分間有効
- アップロード先は `/reviews/{uuid}/` に制限
- 画像ファイルのみ許可（MIME type: `image/jpeg`, `image/png`, `image/webp`）
- 最大ファイルサイズ: 5MB

### 3.5 トランザクション設計

レビュー作成時のトランザクション境界:

```typescript
BEGIN;
  -- 1. レビュー挿入
  INSERT INTO reviews (...) VALUES (...);
  
  -- 2. 商品の平均評価を再計算して更新
  UPDATE products 
  SET 
    average_rating = (SELECT AVG(rating) FROM reviews WHERE product_id = $1),
    review_count = (SELECT COUNT(*) FROM reviews WHERE product_id = $1)
  WHERE id = $1;
COMMIT;
```

レビュー削除時も同様のトランザクションで `products` テーブルを更新します。

---

## セクション4: 実装詳細仕様

### 4.1 Repository層

#### 4.1.1 reviewRepository.ts

```typescript
// src/repositories/reviewRepository.ts
import { Pool } from 'pg';
import { Review, CreateReviewDto } from '../models/Review';

export class ReviewRepository {
  constructor(private db: Pool) {}

  async create(dto: CreateReviewDto, userId: string): Promise<Review> {
    const query = `
      INSERT INTO reviews (product_id, user_id, rating, title, body, images)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING 
        id, product_id as "productId", user_id as "userId", 
        rating, title, body, images, flagged, 
        created_at as "createdAt", updated_at as "updatedAt"
    `;
    const values = [dto.productId, userId, dto.rating, dto.title, dto.body, dto.images];
    const result = await this.db.query(query, values);
    return result.rows[0];
  }

  async findByProductId(productId: string): Promise<Review[]> {
    const query = `
      SELECT 
        r.id, r.product_id as "productId", r.user_id as "userId",
        r.rating, r.title, r.body, r.images, r.flagged,
        r.created_at as "createdAt", r.updated_at as "updatedAt",
        u.name as "userName"
      FROM reviews r
      INNER JOIN users u ON r.user_id = u.id
      WHERE r.product_id = $1
      ORDER BY r.created_at DESC
    `;
    const result = await this.db.query(query, [productId]);
    return result.rows;
  }

  async findById(reviewId: string): Promise<Review | null> {
    const query = `
      SELECT 
        id, product_id as "productId", user_id as "userId",
        rating, title, body, images, flagged,
        created_at as "createdAt", updated_at as "updatedAt"
      FROM reviews
      WHERE id = $1
    `;
    const result = await this.db.query(query, [reviewId]);
    return result.rows[0] || null;
  }

  async delete(reviewId: string): Promise<void> {
    const query = 'DELETE FROM reviews WHERE id = $1';
    await this.db.query(query, [reviewId]);
  }

  async updateFlag(reviewId: string, flagged: boolean): Promise<Review> {
    const query = `
      UPDATE reviews 
      SET flagged = $1, updated_at = NOW()
      WHERE id = $2
      RETURNING 
        id, product_id as "productId", user_id as "userId",
        rating, title, body, images, flagged,
        created_at as "createdAt", updated_at as "updatedAt"
    `;
    const result = await this.db.query(query, [flagged, reviewId]);
    return result.rows[0];
  }

  async countByProductId(productId: string): Promise<number> {
    const query = 'SELECT COUNT(*) as count FROM reviews WHERE product_id = $1';
    const result = await this.db.query(query, [productId]);
    return parseInt(result.rows[0].count, 10);
  }
}
```

#### 4.1.2 productRepository.ts（拡張）

既存ファイルに以下のメソッドを追加:

```typescript
// src/repositories/productRepository.ts
export class ProductRepository {
  // ... 既存メソッド

  async updateRating(productId: string, client?: PoolClient): Promise<void> {
    const db = client || this.db;
    const query = `
      UPDATE products
      SET 
        average_rating = COALESCE((SELECT AVG(rating) FROM reviews WHERE product_id = $1), 0),
        review_count = (SELECT COUNT(*) FROM reviews WHERE product_id = $1),
        updated_at = NOW()
      WHERE id = $1
    `;
    await db.query(query, [productId]);
  }

  async getRating(productId: string): Promise<{ averageRating: number; reviewCount: number }> {
    const query = `
      SELECT average_rating as "averageRating", review_count as "reviewCount"
      FROM products
      WHERE id = $1
    `;
    const result = await this.db.query(query, [productId]);
    return result.rows[0] || { averageRating: 0, reviewCount: 0 };
  }
}
```

### 4.2 Service層

#### 4.2.1 reviewService.ts

```typescript
// src/services/reviewService.ts
import { PoolClient } from 'pg';
import { ReviewRepository } from '../repositories/reviewRepository';
import { ProductRepository } from '../repositories/productRepository';
import { Review, CreateReviewDto, ReviewSummary } from '../models/Review';
import { sanitizeHtml } from '../utils/sanitizer';
import { NotFoundError, ForbiddenError } from '../utils/errors';

export class ReviewService {
  constructor(
    private reviewRepository: ReviewRepository,
    private productRepository: ProductRepository,
    private db: any // Pool instance
  ) {}

  async createReview(dto: CreateReviewDto, userId: string): Promise<{ review: Review; summary: ReviewSummary }> {
    // HTMLサニタイズ
    const sanitizedDto = {
      ...dto,
      body: sanitizeHtml(dto.body)
    };

    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      // レビュー作成
      const review = await this.reviewRepository.create(sanitizedDto, userId);

      // 商品の平均評価更新
      await this.productRepository.updateRating(dto.productId, client);

      await client.query('COMMIT');

      // 更新後の評価サマリを取得
      const summary = await this.productRepository.getRating(dto.productId);

      return { review, summary };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async getReviewsByProductId(productId: string): Promise<{ reviews: Review[]; summary: ReviewSummary }> {
    // 商品存在チェック
    const product = await this.productRepository.findById(productId);
    if (!product) {
      throw new NotFoundError('Product not found');
    }

    const reviews = await this.reviewRepository.findByProductId(productId);
    const summary = await this.productRepository.getRating(productId);

    return { reviews, summary };
  }

  async deleteReview(reviewId: string, adminUserId: string): Promise<{ summary: ReviewSummary }> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }

    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      await this.reviewRepository.delete(reviewId);
      await this.productRepository.updateRating(review.productId, client);

      await client.query('COMMIT');

      const summary = await this.productRepository.getRating(review.productId);
      return { summary };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async flagReview(reviewId: string, flagged: boolean): Promise<Review> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }

    return await this.reviewRepository.updateFlag(reviewId, flagged);
  }
}
```

#### 4.2.2 imageUploadService.ts

```typescript
// src/services/imageUploadService.ts
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { v4 as uuidv4 } from 'uuid';

export class ImageUploadService {
  private s3Client: S3Client;
  private bucketName: string;
  private region: string;

  constructor() {
    this.bucketName = process.env.S3_BUCKET_NAME!;
    this.region = process.env.S3_REGION || 'us-east-1';
    this.s3Client = new S3Client({
      region: this.region,
      credentials: {
        accessKeyId: process.env.S3_ACCESS_KEY_ID!,
        secretAccessKey: process.env.S3_SECRET_ACCESS_KEY!
      },
      endpoint: process.env.S3_ENDPOINT // S3互換ストレージの場合
    });
  }

  async generateUploadUrl(fileName: string, contentType: string): Promise<{ uploadUrl: string; imageUrl: string }> {
    // MIME typeバリデーション
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (!allowedTypes.includes(contentType)) {
      throw new Error('Invalid content type. Only JPEG, PNG, and WebP are allowed.');
    }

    // ファイル名バリデーション（拡張子チェック）
    const extension = fileName.split('.').pop()?.toLowerCase();
    if (!['jpg', 'jpeg', 'png', 'webp'].includes(extension || '')) {
      throw new Error('Invalid file extension.');
    }

    // ユニークなキー生成
    const key = `reviews/${uuidv4()}/${fileName}`;

    // 署名付きURL生成
    const command = new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      ContentType: contentType,
      ContentLength: 5 * 1024 * 1024 // 5MB制限
    });

    const uploadUrl = await getSignedUrl(this.s3Client, command, { expiresIn: 300 }); // 5分

    // 公開アクセスURL
    const imageUrl = `https://${this.bucketName}.s3.${this.region}.amazonaws.com/${key}`;

    return { uploadUrl, imageUrl };
  }

  validateImagePath(imagePath: string): boolean {
    // S3のURLかどうかチェック
    const pattern = new RegExp(`^https://${this.bucketName}\\.s3\\.${this.region}\\.amazonaws\\.com/reviews/[a-f0-9-]+/.*\\.(jpg|jpeg|png|webp)$`, 'i');
    return pattern.test(imagePath);
  }
}
```

### 4.3 Controller層

#### 4.3.1 reviewController.ts

```typescript
// src/controllers/reviewController.ts
import { Request, Response, NextFunction } from 'express';
import { ReviewService } from '../services/reviewService';
import { ImageUploadService } from '../services/imageUploadService';
import { validateCreateReview, validateUploadUrl } from '../utils/validator';
import { ValidationError, ForbiddenError } from '../utils/errors';

export class ReviewController {
  constructor(
    private reviewService: ReviewService,
    private imageUploadService: ImageUploadService
  ) {}

  async createReview(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // バリデーション
      const errors = validateCreateReview(req.body);
      if (errors.length > 0) {
        throw new ValidationError('Validation failed', errors);
      }

      // 画像URL検証
      const { images } = req.body;
      if (images && images.length > 0) {
        for (const imageUrl of images) {
          if (!this.imageUploadService.validateImagePath(imageUrl)) {
            throw new ValidationError('Invalid image URL');
          }
        }
      }

      const userId = req.user!.id; // authミドルウェアで設定済み
      const productId = req.params.productId;

      const result = await this.reviewService.createReview(
        { ...req.body, productId },
        userId
      );

      res.status(201).json({
        data: result.review,
        productRating: result.summary
      });
    } catch (error) {
      next(error);
    }
  }

  async getProductReviews(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const productId = req.params.productId;
      const result = await this.reviewService.getReviewsByProductId(productId);

      res.json({
        data: result.reviews,
        summary: result.summary
      });
    } catch (error) {
      next(error);
    }
  }

  async deleteReview(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // 管理者権限チェック
      if (req.user!.role !== 'admin') {
        throw new ForbiddenError('Admin access required');
      }

      const reviewId = req.params.reviewId;
      const result = await this.reviewService.deleteReview(reviewId, req.user!.id);

      res.json({
        message: 'Review deleted successfully',
        productRating: result.summary
      });
    } catch (error) {
      next(error);
    }
  }

  async flagReview(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // 管理者権限チェック
      if (req.user!.role !== 'admin') {
        throw new ForbiddenError('Admin access required');
      }

      const reviewId = req.params.reviewId;
      const { flagged } = req.body;

      if (typeof flagged !== 'boolean') {
        throw new ValidationError('flagged must be a boolean');
      }

      const review = await this.reviewService.flagReview(reviewId, flagged);

      res.json({ data: review });
    } catch (error) {
      next(error);
    }
  }

  async getUploadUrl(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { fileName, contentType } = req.query;

      // バリデーション
      const errors = validateUploadUrl({ fileName, contentType });
      if (errors.length > 0) {
        throw new ValidationError('Validation failed', errors);
      }

      const result = await this.imageUploadService.generateUploadUrl(
        fileName as string,
        contentType as string
      );

      res.json({
        uploadUrl: result.uploadUrl,
        imageUrl: result.imageUrl,
        expiresIn: 300
      });
    } catch (error) {
      next(error);
    }
  }
}
```

### 4.4 Middleware層

#### 4.4.1 sanitize.ts（新規）

```typescript
// src/middleware/sanitize.ts
import { Request, Response, NextFunction } from 'express';
import { sanitizeHtml } from '../utils/sanitizer';

export const sanitizeReviewBody = (req: Request, res: Response, next: NextFunction): void => {
  if (req.body && req.body.body) {
    // Note: Serviceレイヤーでもサニタイズするため、ここは補助的な役割
    // Controllerに到達する前に明らかに危険なタグを除去
    req.body.body = sanitizeHtml(req.body.body);
  }
  next();
};
```

### 4.5 Utils層

#### 4.5.1 sanitizer.ts（新規）

```typescript
// src/utils/sanitizer.ts
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeHtml(dirtyHtml: string): string {
  return DOMPurify.sanitize(dirtyHtml, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'a'],
    ALLOWED_ATTR: ['href'],
    ALLOWED_URI_REGEXP: /^https?:\/\//
  });
}
```

#### 4.5.2 validator.ts（拡張）

既存ファイルに以下を追加:

```typescript
// src/utils/validator.ts
export function validateCreateReview(data: any): string[] {
  const errors: string[] = [];

  if (!data.rating || typeof data.rating !== 'number' || data.rating < 1 || data.rating > 5) {
    errors.push('rating must be a number between 1 and 5');
  }

  if (!data.title || typeof data.title !== 'string' || data.title.trim().length === 0) {
    errors.push('title is required');
  } else if (data.title.length > 200) {
    errors.push('title must be 200 characters or less');
  }

  if (!data.body || typeof data.body !== 'string' || data.body.trim().length === 0) {
    errors.push('body is required');
  } else if (data.body.length > 5000) {
    errors.push('body must be 5000 characters or less');
  }

  if (data.images) {
    if (!Array.isArray(data.images)) {
      errors.push('images must be an array');
    } else if (data.images.length > 3) {
      errors.push('images must contain 3 or fewer items');
    } else {
      for (const img of data.images) {
        if (typeof img !== 'string' || !img.startsWith('https://')) {
          errors.push('each image must be a valid HTTPS URL');
          break;
        }
      }
    }
  }

  return errors;
}

export function validateUploadUrl(data: any): string[] {
  const errors: string[] = [];

  if (!data.fileName || typeof data.fileName !== 'string') {
    errors.push('fileName is required and must be a string');
  }

  if (!data.contentType || typeof data.contentType !== 'string') {
    errors.push('contentType is required and must be a string');
  } else if (!['image/jpeg', 'image/png', 'image/webp'].includes(data.contentType)) {
    errors.push('contentType must be image/jpeg, image/png, or image/webp');
  }

  return errors;
}
```

#### 4.5.3 errors.ts（拡張）

既存ファイルに以下を追加:

```typescript
// src/utils/errors.ts
export class ValidationError extends Error {
  public statusCode = 400;
  public details?: string[];

  constructor(message: string, details?: string[]) {
    super(message);
    this.name = 'ValidationError';
    this.details = details;
  }
}

export class ForbiddenError extends Error {
  public statusCode = 403;

  constructor(message: string) {
    super(message);
    this.name = 'ForbiddenError';
  }
}

export class NotFoundError extends Error {
  public statusCode = 404;

  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}
```

### 4.6 Routes設定

#### 4.6.1 routes/index.ts（拡張）

既存ファイルに以下を追加:

```typescript
// src/routes/index.ts
import { Router } from 'express';
import { ReviewController } from '../controllers/reviewController';
import { authenticate, requireAdmin } from '../middleware/auth';

const router = Router();

// 依存性注入（実際の初期化コードは省略）
const reviewController = new ReviewController(reviewService, imageUploadService);

// レビューエンドポイント
router.post('/products/:productId/reviews', authenticate, reviewController.createReview.bind(reviewController));
router.get('/products/:productId/reviews', reviewController.getProductReviews.bind(reviewController));
router.delete('/reviews/:reviewId', authenticate, requireAdmin, reviewController.deleteReview.bind(reviewController));
router.patch('/reviews/:reviewId/flag', authenticate, requireAdmin, reviewController.flagReview.bind(reviewController));
router.get('/reviews/upload-url', authenticate, reviewController.getUploadUrl.bind(reviewController));

export default router;
```

### 4.7 認証ミドルウェア拡張

#### 4.7.1 auth.ts（拡張）

既存ファイルに以下を追加:

```typescript
// src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import { ForbiddenError } from '../utils/errors';

// 既存のauthenticate関数はそのまま

export const requireAdmin = (req: Request, res: Response, next: NextFunction): void => {
  if (!req.user || req.user.role !== 'admin') {
    return next(new ForbiddenError('Admin access required'));
  }
  next();
};
```

---

## セクション5: ユニットテスト戦略

### 5.1 テスト方針

- **カバレッジ目標**: 80%以上
- **フレームワーク**: Jest + supertest
- **モック**: Repository層をモック化してService層をテスト、Service層をモック化してController層をテスト
- **E2Eテスト**: 主要フローのみ実施（レビュー作成→取得→削除）

### 5.2 テストケース一覧

#### 5.2.1 reviewService.test.ts

```typescript
describe('ReviewService', () => {
  describe('createReview', () => {
    it('正常にレビューを作成し、商品評価を更新する', async () => {
      // モックのセットアップ
      // レビュー作成とトランザクション処理を検証
    });

    it('HTMLサニタイズが正しく実行される', async () => {
      // <script>タグが除去されることを検証
    });

    it('同一ユーザーが同一商品に2回目のレビューを投稿するとエラー', async () => {
      // UNIQUE制約違反を検証
    });
  });

  describe('getReviewsByProductId', () => {
    it('商品IDに紐づく全レビューと評価サマリを取得する', async () => {});

    it('存在しない商品IDの場合NotFoundErrorをthrowする', async () => {});
  });

  describe('deleteReview', () => {
    it('レビュー削除後に商品評価が再計算される', async () => {});

    it('存在しないレビューIDの場合NotFoundErrorをthrowする', async () => {});
  });

  describe('flagReview', () => {
    it('レビューのフラグを更新する', async () => {});
  });
});
```

#### 5.2.2 review.test.ts（E2Eテスト）

```typescript
describe('Review API E2E', () => {
  let authToken: string;
  let productId: string;

  beforeAll(async () => {
    // テストユーザー作成＆認証トークン取得
    // テスト用商品作成
  });

  describe('POST /api/products/:productId/reviews', () => {
    it('認証済みユーザーがレビューを投稿できる', async () => {
      const response = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          rating: 5,
          title: 'Great product!',
          body: '<p>Very satisfied with this purchase.</p>',
          images: []
        });

      expect(response.status).toBe(201);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.rating).toBe(5);
      expect(response.body.productRating.reviewCount).toBe(1);
    });

    it('認証なしでは401エラー', async () => {
      const response = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .send({ rating: 5, title: 'Test', body: '<p>Test</p>' });

      expect(response.status).toBe(401);
    });

    it('不正なratingで400エラー', async () => {
      const response = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ rating: 6, title: 'Test', body: '<p>Test</p>' });

      expect(response.status).toBe(400);
    });

    it('XSS攻撃がサニタイズされる', async () => {
      const response = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          rating: 4,
          title: 'Test',
          body: '<p>Safe content</p><script>alert("XSS")</script>'
        });

      expect(response.status).toBe(201);
      expect(response.body.data.body).not.toContain('<script>');
      expect(response.body.data.body).toContain('<p>Safe content</p>');
    });
  });

  describe('GET /api/products/:productId/reviews', () => {
    it('商品のレビュー一覧と評価サマリを取得できる', async () => {
      const response = await request(app)
        .get(`/api/products/${productId}/reviews`);

      expect(response.status).toBe(200);
      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.summary).toHaveProperty('averageRating');
      expect(response.body.summary).toHaveProperty('reviewCount');
    });
  });

  describe('DELETE /api/reviews/:reviewId', () => {
    it('管理者がレビューを削除できる', async () => {
      // 管理者トークン取得
      const adminToken = await getAdminToken();

      const response = await request(app)
        .delete(`/api/reviews/${reviewId}`)
        .set('Authorization', `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
    });

    it('一般ユーザーは削除できない（403エラー）', async () => {
      const response = await request(app)
        .delete(`/api/reviews/${reviewId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(403);
    });
  });
});
```

#### 5.2.3 imageUpload.test.ts

```typescript
describe('ImageUploadService', () => {
  describe('generateUploadUrl', () => {
    it('有効なファイル名とMIME typeで署名付きURLを生成する', async () => {
      const result = await imageUploadService.generateUploadUrl('test.jpg', 'image/jpeg');
      expect(result.uploadUrl).toContain('https://');
      expect(result.imageUrl).toMatch(/\/reviews\/[a-f0-9-]+\/test\.jpg$/);
    });

    it('無効なMIME typeでエラーをthrowする', async () => {
      await expect(
        imageUploadService.generateUploadUrl('test.pdf', 'application/pdf')
      ).rejects.toThrow('Invalid content type');
    });
  });

  describe('validateImagePath', () => {
    it('正しいS3 URLの場合trueを返す', () => {
      const url = 'https://bucket.s3.us-east-1.amazonaws.com/reviews/abc-123/image.jpg';
      expect(imageUploadService.validateImagePath(url)).toBe(true);
    });

    it('不正なURLの場合falseを返す', () => {
      expect(imageUploadService.validateImagePath('http://evil.com/hack.jpg')).toBe(false);
    });
  });
});
```

### 5.3 テストデータ準備

```typescript
// __tests__/fixtures/reviewFixtures.ts
export const validReviewData = {
  rating: 5,
  title: 'Excellent product',
  body: '<p>Highly recommend!</p>',
  images: []
};

export const xssAttackReviewData = {
  rating: 4,
  title: 'Test',
  body: '<p>Normal text</p><script>alert("XSS")</script><img src=x onerror="alert(1)">'
};

export const sanitizedExpectedBody = '<p>Normal text</p><img src="x">';
```

---

## セクション6: 実装順序

### 6.1 フェーズ1: 基盤整備（2-3日）

**目的**: データベース、モデル、エラーハンドリングの準備

1. **マイグレーション実行**
   - `migrations/001_create_reviews_table.sql` を作成・実行
   - `migrations/002_add_rating_to_products.sql` を作成・実行
   - 既存データの初期化スクリプト実行

2. **モデル定義**
   - `src/models/Review.ts` 作成
   - `src/models/Product.ts` に `averageRating`, `reviewCount` 追加

3. **エラークラス拡張**
   - `src/utils/errors.ts` に `ValidationError`, `ForbiddenError`, `NotFoundError` 追加

4. **バリデーション実装**
   - `src/utils/validator.ts` に `validateCreateReview`, `validateUploadUrl` 追加

5. **HTMLサニタイザー実装**
   - `isomorphic-dompurify` をインストール
   - `src/utils/sanitizer.ts` 作成
   - ユニットテスト作成（XSS攻撃パターンを検証）

**検証**: サニタイザーのユニットテストが全てパスすることを確認

---

### 6.2 フェーズ2: Repository層実装（2日）

**目的**: データアクセス層の実装

1. **ReviewRepository実装**
   - `src/repositories/reviewRepository.ts` 作成
   - `create`, `findByProductId`, `findById`, `delete`, `updateFlag` 実装

2. **ProductRepository拡張**
   - `src/repositories/productRepository.ts` に `updateRating`, `getRating` 追加

3. **Repository層のユニットテスト**
   - モックDB接続を使用してCRUD操作を検証
   - トランザクション処理のテスト

**検証**: Repository層のテストが全てパスすることを確認

---

### 6.3 フェーズ3: Service層実装（3日）

**目的**: ビジネスロジックとトランザクション制御の実装

1. **ImageUploadService実装**
   - `aws-sdk` v3をインストール
   - `src/services/imageUploadService.ts` 作成
   - `generateUploadUrl`, `validateImagePath` 実装
   - 環境変数設定（`.env.example` に追記）

2. **ReviewService実装**
   - `src/services/reviewService.ts` 作成
   - `createReview`, `getReviewsByProductId`, `deleteReview`, `flagReview` 実装
   - トランザクション処理の実装

3. **Service層のユニットテスト**
   - Repository層をモック化
   - HTMLサニタイズの統合テスト
   - トランザクションロールバックのテスト

**検証**: Service層のテストが全てパスすることを確認

---

### 6.4 フェーズ4: Controller層・ルーティング実装（2日）

**目的**: HTTPハンドリングとエンドポイント公開

1. **認証ミドルウェア拡張**
   - `src/middleware/auth.ts` に `requireAdmin` 追加

2. **ReviewController実装**
   - `src/controllers/reviewController.ts` 作成
   - 全エンドポイントのハンドラ実装

3. **ルーティング設定**
   - `src/routes/index.ts` にレビューエンドポイント追加
   - 依存性注入のセットアップ

4. **E2Eテスト実装**
   - `src/__tests__/review.test.ts` 作成
   - 主要フローのテスト（作成→取得→削除）
   - XSS攻撃のE2Eテスト

**検証**: E2Eテストが全てパスすることを確認

---

### 6.5 フェーズ5: フロントエンド実装（4-5日）

**目的**: React UIコンポーネントの実装

1. **画像アップロードコンポーネント**
   - 署名付きURL取得
   - クライアントサイドでのリサイズ処理（`browser-image-compression` 等を使用）
   - S3への直接アップロード

2. **レビュー投稿フォーム**
   - 星評価入力（react-stars等のライブラリ使用）
   - リッチテキストエディタ（react-quill等）
   - 画像アップロード統合

3. **レビュー一覧コンポーネント**
   - レビュー表示（sanitize済みHTMLを `dangerouslySetInnerHTML` で表示）
   - 平均評価・件数表示
   - ページネーション（将来拡張）

4. **管理者機能UI**
   - レビュー削除ボタン
   - フラグ設定トグル

**検証**: 
- フロントエンドから全機能が正常に動作することを確認
- XSSが防げていることをブラウザで検証

---

### 6.6 フェーズ6: 統合テスト・本番デプロイ準備（2日）

**目的**: 本番環境への移行準備

1. **パフォーマンステスト**
   - 大量レビューデータでのクエリ性能確認
   - インデックスの最適化

2. **セキュリティ監査**
   - OWASP ZAPを使用した脆弱性スキャン
   - SQLインジェクションテスト
   - XSSテストの再確認

3. **ドキュメント作成**
   - API仕様書（OpenAPI/Swagger形式）
   - 環境変数設定ガイド
   - デプロイ手順書

4. **本番デプロイ**
   - ステージング環境でのテスト
   - マイグレーション実行
   - 本番リリース

**検証**: 
- ステージング環境で全機能が動作することを確認
- 本番データバックアップの取得

---

## 実装チェックリスト

### バックエンド
- [ ] マイグレーションファイル作成・実行
- [ ] Review, Product モデル定義
- [ ] ReviewRepository 実装
- [ ] ProductRepository 拡張
- [ ] ImageUploadService 実装
- [ ] ReviewService 実装
- [ ] ReviewController 実装
- [ ] ルーティング設定
- [ ] HTMLサニタイザー実装
- [ ] バリデーション実装
- [ ] エラーハンドリング実装
- [ ] ユニットテスト実装（80%カバレッジ）
- [ ] E2Eテスト実装

### フロントエンド
- [ ] 画像アップロードコンポーネント
- [ ] レビュー投稿フォーム
- [ ] レビュー一覧コンポーネント
- [ ] 管理者機能UI
- [ ] XSS防御の検証

### インフラ・セキュリティ
- [ ] S3バケット設定（CORS、権限）
- [ ] 環境変数設定
- [ ] セキュリティ監査
- [ ] パフォーマンステスト
- [ ] ドキュメント作成

---

## 想定工数

| フェーズ | 工数 | 担当 |
|---------|------|------|
| フェーズ1: 基盤整備 | 2-3日 | バックエンド |
| フェーズ2: Repository層 | 2日 | バックエンド |
| フェーズ3: Service層 | 3日 | バックエンド |
| フェーズ4: Controller層 | 2日 | バックエンド |
| フェーズ5: フロントエンド | 4-5日 | フロントエンド |
| フェーズ6: 統合テスト | 2日 | 全員 |
| **合計** | **15-17日** | - |

---

## 依存パッケージ

### バックエンド新規追加
```json
{
  "dependencies": {
    "isomorphic-dompurify": "^2.14.0",
    "@aws-sdk/client-s3": "^3.620.0",
    "@aws-sdk/s3-request-presigner": "^3.620.0",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/uuid": "^10.0.0"
  }
}
```

### フロントエンド新規追加
```json
{
  "dependencies": {
    "react-quill": "^2.0.0",
    "react-stars": "^2.2.5",
    "browser-image-compression": "^2.0.2"
  }
}
```

---

## リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| XSS脆弱性の見落とし | 高 | DOMPurifyによる厳格なサニタイズ、セキュリティ監査の実施 |
| 大量レビューによる性能劣化 | 中 | 平均評価の非正規化、適切なインデックス作成、将来的にページネーション導入 |
| S3アップロード失敗時の不整合 | 中 | クライアント側でリトライ処理、アップロード完了後にレビュー作成 |
| 同時更新による評価計算のズレ | 低 | トランザクション内でのSELECT FOR UPDATE（必要に応じて） |

---

以上が商品レビュー機能追加の詳細開発計画です。この計画に従って実装を進めることで、セキュアかつ保守性の高いレビューシステムを構築できます。
