# 商品レビュー機能 開発計画書

## 1. 概要

### 1.1 目的
ECサイト「ShopNow」に商品レビュー機能を追加し、ユーザーが購入商品に対してレビューを投稿・閲覧できるようにする。

### 1.2 スコープ

**実装対象**
- レビューの投稿機能（星評価、タイトル、本文、画像最大3枚）
- 商品詳細ページへのレビュー一覧表示機能
- 平均評価の計算・表示機能
- 管理者によるレビュー削除・フラグ付け機能

**スコープ外**
- レビューの編集機能（将来対応）
- レビューへの返信・コメント機能
- レビューの並び替え・フィルタリング機能（新着順のみ実装）
- レビューのいいね/役立った機能
- 購入確認機能（購入していない商品へのレビュー投稿も許可）
- メール通知機能（`Review`モデルの`sendNotification`メソッドは実装しない）
- レビュー集計レポート機能（`Review`モデルの`generateReport`メソッドは実装しない）

### 1.3 前提条件
- Node.js環境、Express、PostgreSQLが既に構築済み
- ユーザー認証機構（`req.user`で取得可能）が実装済み
- 既存の商品管理機能が動作している
- S3互換ストレージへのアクセス設定が完了している

### 1.4 ユーザー選定事項
- バックエンド: Node.js + Express
- データベース: PostgreSQL
- 画像ストレージ: S3互換ストレージ
- フロントエンド: React + TypeScript

---

## 2. ディレクトリ/ファイル設計

### 2.1 新規作成ファイル

**バックエンド**
- `src/models/Review.ts` - レビューエンティティモデル（型定義のみ、ビジネスロジックなし）
- `src/repositories/reviewRepository.ts` - レビューDB操作層
- `src/services/reviewService.ts` - レビュービジネスロジック層
- `src/controllers/reviewController.ts` - レビューHTTPリクエスト制御層
- `src/routes/reviewRoutes.ts` - レビューAPIルート定義
- `src/services/s3Service.ts` - S3画像アップロード処理層
- `src/utils/reviewValidator.ts` - レビュー入力値検証ユーティリティ
- `src/middleware/reviewOwnership.ts` - レビュー所有権確認ミドルウェア
- `src/errors/ValidationError.ts` - バリデーションエラークラス
- `src/errors/NotFoundError.ts` - リソース未存在エラークラス（既存の可能性あり、なければ新規作成）
- `src/errors/ForbiddenError.ts` - 権限不足エラークラス
- `src/__tests__/review.test.ts` - レビュー機能統合テスト
- `src/__tests__/services/reviewService.test.ts` - レビューServiceユニットテスト
- `src/__tests__/repositories/reviewRepository.test.ts` - レビューRepositoryユニットテスト

**フロントエンド**
- `src/components/Review/ReviewForm.tsx` - レビュー投稿フォームコンポーネント
- `src/components/Review/ReviewList.tsx` - レビュー一覧表示コンポーネント
- `src/components/Review/ReviewItem.tsx` - 個別レビュー表示コンポーネント
- `src/components/Review/StarRating.tsx` - 星評価表示コンポーネント
- `src/components/Review/ImageUpload.tsx` - 画像アップロードコンポーネント
- `src/hooks/useReviews.ts` - レビューデータ取得カスタムフック
- `src/types/review.ts` - レビュー型定義
- `src/api/reviewApi.ts` - レビューAPI通信ユーティリティ
- `src/utils/sanitizeHtml.ts` - HTMLサニタイズユーティリティ
- `src/__tests__/components/Review/ReviewForm.test.tsx` - ReviewFormコンポーネントテスト
- `src/__tests__/components/Review/ReviewList.test.tsx` - ReviewListコンポーネントテスト

**データベース**
- `migrations/20260206_create_reviews_table.sql` - reviewsテーブル作成マイグレーション

### 2.2 修正ファイル

**バックエンド**
- `src/routes/index.ts`
  - 影響範囲: レビュールート（`/api/reviews`）を追加
  - 修正内容: `import reviewRoutes from './reviewRoutes'` と `app.use('/api/reviews', reviewRoutes)` を追加

- `src/app.ts`
  - 影響範囲: なし（既存のルート読み込み機構で対応可能と想定）

- `src/middleware/errorHandler.ts`
  - 影響範囲: ValidationError、ForbiddenErrorの処理追加
  - 修正内容: `ValidationError`発生時に400、`ForbiddenError`発生時に403を返す分岐追加

**フロントエンド**
- `src/pages/ProductDetailPage.tsx` （存在すると仮定）
  - 影響範囲: レビューセクション追加
  - 修正内容: `<ReviewList productId={productId} />` コンポーネントをレンダリング

- `package.json`
  - 影響範囲: 依存ライブラリ追加
  - 追加内容:
    - `aws-sdk@^2.1543.0` （S3アップロード用）
    - `dompurify@^3.0.9` （HTMLサニタイズ用）
    - `@types/dompurify@^3.0.5` （型定義）
    - `react-quill@^2.0.0` （リッチテキストエディタ）
    - `@types/react-quill@^2.0.0` （型定義）

### 2.3 ディレクトリ構成（変更後）

```
src/
├── controllers/
│   ├── productController.ts
│   ├── userController.ts
│   ├── orderController.ts
│   └── reviewController.ts ★新規
├── services/
│   ├── productService.ts
│   ├── userService.ts
│   ├── orderService.ts
│   ├── reviewService.ts ★新規
│   └── s3Service.ts ★新規
├── repositories/
│   ├── productRepository.ts
│   ├── userRepository.ts
│   ├── orderRepository.ts
│   └── reviewRepository.ts ★新規
├── models/
│   ├── Product.ts
│   ├── User.ts
│   ├── Order.ts
│   └── Review.ts ★新規
├── middleware/
│   ├── auth.ts
│   ├── errorHandler.ts ★修正
│   └── reviewOwnership.ts ★新規
├── routes/
│   ├── index.ts ★修正
│   └── reviewRoutes.ts ★新規
├── utils/
│   ├── validator.ts
│   └── reviewValidator.ts ★新規
├── errors/ ★新規ディレクトリ
│   ├── ValidationError.ts ★新規
│   ├── NotFoundError.ts ★新規（既存なら流用）
│   └── ForbiddenError.ts ★新規
├── __tests__/
│   ├── product.test.ts
│   ├── user.test.ts
│   ├── order.test.ts
│   ├── review.test.ts ★新規
│   ├── services/
│   │   └── reviewService.test.ts ★新規
│   └── repositories/
│       └── reviewRepository.test.ts ★新規
└── app.ts
```

**フロントエンド**
```
src/
├── components/
│   └── Review/ ★新規ディレクトリ
│       ├── ReviewForm.tsx ★新規
│       ├── ReviewList.tsx ★新規
│       ├── ReviewItem.tsx ★新規
│       ├── StarRating.tsx ★新規
│       └── ImageUpload.tsx ★新規
├── hooks/
│   └── useReviews.ts ★新規
├── types/
│   └── review.ts ★新規
├── api/
│   └── reviewApi.ts ★新規
├── utils/
│   └── sanitizeHtml.ts ★新規
├── pages/
│   └── ProductDetailPage.tsx ★修正
└── __tests__/
    └── components/
        └── Review/ ★新規ディレクトリ
            ├── ReviewForm.test.tsx ★新規
            └── ReviewList.test.tsx ★新規
```

---

## 3. アーキテクチャ設計

### 3.1 全体構成

**データフロー（レビュー投稿）**
```
[ユーザー] → [ReviewForm.tsx]
          → [画像選択] → [ImageUpload.tsx] → [reviewApi.uploadImage()] → [S3Service.uploadImage()] → [S3]
          → [レビュー投稿] → [reviewApi.createReview()] → [POST /api/reviews]
          → [auth middleware（認証確認）]
          → [ReviewController.createReview()]
          → [ReviewService.createReview()]
            → [reviewValidator.validateReviewInput()（バリデーション）]
            → [ProductRepository.findById()（商品存在確認）]
            → [ReviewRepository.create()（DB保存）]
          ← [Response { data: Review }]
          ← [ReviewForm.tsx（成功表示）]
          → [ReviewList.tsx（再取得してリスト更新）]
```

**データフロー（レビュー一覧表示）**
```
[ユーザー] → [ProductDetailPage.tsx] → [ReviewList.tsx]
          → [useReviews(productId)（カスタムフック）]
          → [reviewApi.getProductReviews()] → [GET /api/products/:productId/reviews]
          → [ReviewController.getProductReviews()]
          → [ReviewService.getProductReviews()]
            → [ReviewRepository.findByProductId()（全件取得）]
            → [ReviewService.calculateAverageRating()（平均計算）]
          ← [Response { data: Review[], averageRating: number, totalCount: number }]
          ← [ReviewList.tsx（レビュー表示）]
            → [ReviewItem.tsx × N（個別レビュー）]
              → [sanitizeHtml()（HTMLサニタイズ）]
              → [StarRating.tsx（星評価表示）]
```

**データフロー（レビュー削除）**
```
[管理者] → [ReviewItem.tsx（削除ボタン）]
        → [reviewApi.deleteReview()] → [DELETE /api/reviews/:reviewId]
        → [auth middleware（認証確認）]
        → [ReviewController.deleteReview()]
        → [ReviewService.deleteReview()]
          → [ReviewRepository.findById()（存在確認）]
          → [ReviewRepository.delete()（論理削除またはハードデリート）]
        ← [Response { success: true }]
        ← [ReviewList.tsx（再取得してリスト更新）]
```

### 3.2 主要コンポーネント

#### 3.2.1 ReviewController（責務: HTTPリクエスト制御）
- **単一責務**: HTTPリクエストの受信、パラメータ抽出、Serviceへのビジネスロジック委譲、HTTPレスポンス返却
- **依存先**: ReviewService
- **提供機能**:
  - `createReview(req, res, next)`: レビュー作成エンドポイント
  - `getProductReviews(req, res, next)`: 商品別レビュー一覧取得エンドポイント
  - `deleteReview(req, res, next)`: レビュー削除エンドポイント
  - `flagReview(req, res, next)`: レビューフラグ付けエンドポイント

#### 3.2.2 ReviewService（責務: ビジネスロジック）
- **単一責務**: レビュー機能のビジネスルール適用、複数リポジトリの調整、データ整合性保証
- **依存先**: ReviewRepository, ProductRepository
- **提供機能**:
  - `createReview(data)`: レビュー作成ビジネスロジック（商品存在確認、バリデーション、保存）
  - `getProductReviews(productId)`: 商品別レビュー取得+平均評価計算
  - `calculateAverageRating(reviews)`: 平均評価計算ロジック
  - `deleteReview(reviewId, userId, isAdmin)`: レビュー削除ビジネスロジック（権限確認）
  - `flagReview(reviewId, userId, isAdmin)`: レビューフラグ付けビジネスロジック（権限確認）

#### 3.2.3 ReviewRepository（責務: DB操作）
- **単一責務**: reviewsテーブルへのCRUD操作
- **依存先**: PostgreSQL DB接続
- **提供機能**:
  - `create(reviewData)`: レビューレコード挿入
  - `findById(reviewId)`: ID指定レビュー取得
  - `findByProductId(productId)`: 商品ID指定レビュー一覧取得（新着順ソート）
  - `delete(reviewId)`: レビュー削除（物理削除）
  - `updateFlag(reviewId, flagged)`: フラグ状態更新

#### 3.2.4 S3Service（責務: 画像ストレージ操作）
- **単一責務**: S3へのファイルアップロード・URL生成
- **依存先**: AWS SDK S3クライアント
- **提供機能**:
  - `uploadImage(file, fileName)`: 画像をS3にアップロードし、公開URLを返す
  - `deleteImage(fileName)`: 画像削除（将来対応）

#### 3.2.5 ReviewForm.tsx（責務: レビュー投稿UI）
- **単一責務**: レビュー入力フォームの表示、バリデーション、送信処理
- **依存先**: reviewApi, ImageUpload.tsx
- **提供機能**: ユーザー入力受付、クライアント側バリデーション、API送信

#### 3.2.6 ReviewList.tsx（責務: レビュー一覧表示）
- **単一責務**: レビュー一覧とメタ情報（平均評価、件数）の表示
- **依存先**: useReviews, ReviewItem.tsx, StarRating.tsx
- **提供機能**: レビューデータ取得、一覧レンダリング

### 3.3 データモデル

#### 3.3.1 Reviewエンティティ（TypeScript型）
```typescript
export interface Review {
  id: string;                // UUID
  productId: string;         // UUID（products.id外部キー）
  userId: string;            // UUID（users.id外部キー）
  rating: number;            // 1-5の整数
  title: string;             // 最大200文字
  body: string;              // HTMLリッチテキスト
  images: string[];          // S3 URLの配列、最大3要素
  flagged: boolean;          // 不適切フラグ
  createdAt: Date;
  updatedAt: Date;
}
```

**バリデーションルール**
- `id`: UUID v4形式、必須
- `productId`: UUID v4形式、必須、products.idに存在すること
- `userId`: UUID v4形式、必須、users.idに存在すること
- `rating`: 整数、必須、1以上5以下
- `title`: 文字列、必須、1文字以上200文字以下、空白文字のみ不可
- `body`: 文字列、必須、1文字以上10,000文字以下、空白文字のみ不可
- `images`: 配列、任意、最大3要素、各要素はHTTPS URLパターン
- `flagged`: 真偽値、デフォルトfalse
- `createdAt`: タイムスタンプ、自動設定
- `updatedAt`: タイムスタンプ、自動設定

#### 3.3.2 DBスキーマ
```sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title VARCHAR(200) NOT NULL CHECK (LENGTH(TRIM(title)) > 0),
  body TEXT NOT NULL CHECK (LENGTH(TRIM(body)) > 0 AND LENGTH(body) <= 10000),
  images TEXT[] DEFAULT '{}',
  flagged BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- インデックス設計
CREATE INDEX idx_reviews_product_id ON reviews(product_id);
-- 理由: 商品詳細ページでのレビュー一覧取得（WHERE product_id = $1）が頻繁に発生するため

CREATE INDEX idx_reviews_user_id ON reviews(user_id);
-- 理由: ユーザーマイページでのレビュー一覧取得（将来対応）に備えるため

CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
-- 理由: 新着順ソート（ORDER BY created_at DESC）のパフォーマンス向上のため

CREATE INDEX idx_reviews_flagged ON reviews(flagged) WHERE flagged = true;
-- 理由: 管理者による不適切レビュー一覧（WHERE flagged = true）取得のため（パーティャルインデックス）
```

**外部キー制約の動作**
- `ON DELETE CASCADE`: 商品またはユーザーが削除されたら、関連レビューも自動削除
- 理由: 孤立したレビューデータを残さないため

### 3.4 エラーハンドリング方針

#### 3.4.1 エラー分類と対応

**バリデーションエラー（400 Bad Request）**
- 発生条件: 必須フィールド欠如、型不正、範囲外の値、フォーマット不正
- 例: `rating`が6、`title`が空文字、`images`が4枚
- ハンドリング:
  - `reviewValidator.validateReviewInput()`でバリデーション実行
  - 不正時に`ValidationError`をthrow
  - `errorHandler`で400レスポンス返却
  ```json
  { "error": "ValidationError", "message": "rating must be between 1 and 5", "field": "rating" }
  ```

**リソース未存在エラー（404 Not Found）**
- 発生条件: 指定された`productId`または`reviewId`が存在しない
- 例: 存在しない商品へのレビュー投稿、削除済みレビューへのアクセス
- ハンドリング:
  - Repository層で該当レコードがnullの場合、`NotFoundError`をthrow
  - `errorHandler`で404レスポンス返却
  ```json
  { "error": "NotFoundError", "message": "Product not found" }
  ```

**権限不足エラー（403 Forbidden）**
- 発生条件: 管理者権限がないユーザーがレビュー削除・フラグ付けを試行
- ハンドリング:
  - `ReviewService.deleteReview()`で`isAdmin`チェック
  - 権限なしの場合、`ForbiddenError`をthrow
  - `errorHandler`で403レスポンス返却
  ```json
  { "error": "ForbiddenError", "message": "Admin access required" }
  ```

**認証エラー（401 Unauthorized）**
- 発生条件: 未ログインユーザーがレビュー投稿・削除を試行
- ハンドリング:
  - `auth`ミドルウェアで`req.user`不在時にエラー
  - 既存の認証機構が処理（本実装ではスコープ外）

**S3アップロードエラー（500 Internal Server Error）**
- 発生条件: S3接続失敗、ディスク容量不足、ネットワークタイムアウト
- ハンドリング:
  - `S3Service.uploadImage()`でAWS SDKエラーをcatch
  - 汎用エラーとして500レスポンス返却
  ```json
  { "error": "InternalServerError", "message": "Failed to upload image" }
  ```

**DBエラー（500 Internal Server Error）**
- 発生条件: DB接続失敗、外部キー制約違反、トランザクションタイムアウト
- ハンドリング:
  - Repository層でDB例外をcatch
  - 汎用エラーとして500レスポンス返却（詳細はログに記録）

#### 3.4.2 異常系フロー

**レビュー投稿失敗時のロールバック**
```
1. ユーザーが画像3枚+レビュー本文を送信
2. ImageUpload.tsxで画像3枚を順次S3にアップロード成功（URL取得）
3. reviewApi.createReview()でレビュー投稿APIコール
4. ReviewService.createReview()でバリデーション失敗（titleが空）
5. ValidationErrorをthrow → 400レスポンス
6. **問題**: S3に既にアップロード済みの3枚の画像が孤立ファイルとして残る
7. **対策**: 本実装では孤立ファイルの自動削除は実装しない（スコープ外）。将来、定期的なクリーンアップバッチを実装する想定
```

**並行アクセス時の平均評価計算**
```
1. ユーザーAがレビュー投稿（rating: 5）→ 平均評価4.5に更新
2. 同時刻にユーザーBがレビュー投稿（rating: 3）→ 平均評価4.2に更新
3. **問題**: 平均評価の計算がバックエンドで毎回全件再計算のため、レースコンディションは発生しない
4. **根拠**: ReviewService.getProductReviews()で毎回全レビューを取得してcalculateAverageRating()を実行するため、常に最新の平均値が返却される
```

---

## 4. 実装詳細仕様

### 4.1 ReviewController

#### 責務
HTTPリクエストの解析、認証情報の取得、ReviewServiceへの処理委譲、HTTPレスポンスの生成。エラーハンドリングはExpressの`next()`で統一的に処理。

#### インターフェース

```typescript
export class ReviewController {
  constructor(private reviewService: ReviewService) {}

  /**
   * レビュー作成エンドポイント
   * @route POST /api/reviews
   * @access 認証必須（authミドルウェア）
   * @param req.body { productId: string, rating: number, title: string, body: string, images: string[] }
   * @param req.user { id: string, ... } 認証済みユーザー情報
   * @returns 201 { data: Review }
   * @throws ValidationError (400), NotFoundError (404)
   */
  async createReview(req: Request, res: Response, next: NextFunction): Promise<void>;

  /**
   * 商品別レビュー一覧取得
   * @route GET /api/products/:productId/reviews
   * @access 公開（認証不要）
   * @param req.params.productId 商品ID（UUID）
   * @returns 200 { data: Review[], averageRating: number, totalCount: number }
   * @throws NotFoundError (404) 商品が存在しない場合
   */
  async getProductReviews(req: Request, res: Response, next: NextFunction): Promise<void>;

  /**
   * レビュー削除
   * @route DELETE /api/reviews/:reviewId
   * @access 管理者のみ（authミドルウェア + 管理者チェック）
   * @param req.params.reviewId レビューID（UUID）
   * @param req.user { id: string, isAdmin: boolean }
   * @returns 200 { success: true }
   * @throws NotFoundError (404), ForbiddenError (403)
   */
  async deleteReview(req: Request, res: Response, next: NextFunction): Promise<void>;

  /**
   * レビューフラグ付け
   * @route PATCH /api/reviews/:reviewId/flag
   * @access 管理者のみ（authミドルウェア + 管理者チェック）
   * @param req.params.reviewId レビューID（UUID）
   * @param req.body { flagged: boolean }
   * @param req.user { id: string, isAdmin: boolean }
   * @returns 200 { data: Review }
   * @throws NotFoundError (404), ForbiddenError (403)
   */
  async flagReview(req: Request, res: Response, next: NextFunction): Promise<void>;
}
```

#### 内部ロジック

**createReview**
```typescript
async createReview(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    // 1. リクエストボディからパラメータ抽出
    const { productId, rating, title, body, images } = req.body;
    const userId = req.user.id; // authミドルウェアで設定済み

    // 2. ReviewServiceに処理委譲
    const review = await this.reviewService.createReview({
      productId,
      userId,
      rating,
      title,
      body,
      images: images || [], // imagesがundefinedの場合は空配列
    });

    // 3. 201レスポンス返却
    res.status(201).json({ data: review });
  } catch (error) {
    next(error); // エラーハンドラーに委譲
  }
}
```

**getProductReviews**
```typescript
async getProductReviews(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    // 1. パスパラメータから商品ID取得
    const productId = req.params.productId;

    // 2. ReviewServiceからレビュー一覧+メタ情報取得
    const result = await this.reviewService.getProductReviews(productId);

    // 3. 200レスポンス返却
    res.json(result);
  } catch (error) {
    next(error);
  }
}
```

**deleteReview**
```typescript
async deleteReview(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    // 1. パスパラメータからレビューID取得
    const reviewId = req.params.reviewId;
    const userId = req.user.id;
    const isAdmin = req.user.isAdmin || false; // isAdminフラグ（デフォルトfalse）

    // 2. ReviewServiceに削除処理委譲
    await this.reviewService.deleteReview(reviewId, userId, isAdmin);

    // 3. 200レスポンス返却
    res.json({ success: true });
  } catch (error) {
    next(error);
  }
}
```

**flagReview**
```typescript
async flagReview(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    const reviewId = req.params.reviewId;
    const { flagged } = req.body;
    const isAdmin = req.user.isAdmin || false;

    // 管理者チェック
    if (!isAdmin) {
      throw new ForbiddenError('Admin access required');
    }

    const review = await this.reviewService.flagReview(reviewId, flagged);
    res.json({ data: review });
  } catch (error) {
    next(error);
  }
}
```

#### 依存関係
- `ReviewService` - ビジネスロジック層（コンストラクタ注入）
- `Request.user` - 認証ミドルウェアで設定されるユーザー情報（型: `{ id: string, isAdmin?: boolean }`）
- Express型定義（`express`パッケージ v4.18.2）

#### エッジケース
- `req.user`が未定義: authミドルウェアで事前チェック済み（本Controller内では考慮不要）
- `req.body`が不正なJSON: Expressのbody-parserで400エラー返却済み（本Controller内では考慮不要）
- `productId`がUUID形式でない: ReviewServiceのバリデーションでValidationError発生
- `images`配列が4枚以上: ReviewServiceのバリデーションでValidationError発生

---

### 4.2 ReviewService

#### 責務
レビュー機能のビジネスルール適用。商品存在確認、バリデーション、平均評価計算、権限確認を担当。複数リポジトリの調整役。

#### インターフェース

```typescript
export class ReviewService {
  constructor(
    private reviewRepository: ReviewRepository,
    private productRepository: ProductRepository
  ) {}

  /**
   * レビュー作成
   * @param data { productId: string, userId: string, rating: number, title: string, body: string, images: string[] }
   * @returns Promise<Review>
   * @throws ValidationError バリデーション失敗時
   * @throws NotFoundError 商品が存在しない時
   */
  async createReview(data: CreateReviewInput): Promise<Review>;

  /**
   * 商品別レビュー一覧取得+平均評価計算
   * @param productId string UUID
   * @returns Promise<{ data: Review[], averageRating: number, totalCount: number }>
   * @throws NotFoundError 商品が存在しない時
   */
  async getProductReviews(productId: string): Promise<GetProductReviewsOutput>;

  /**
   * 平均評価計算
   * @param reviews Review[] レビュー配列
   * @returns number 平均評価（小数第1位まで）、レビュー0件の場合は0
   */
  calculateAverageRating(reviews: Review[]): number;

  /**
   * レビュー削除
   * @param reviewId string UUID
   * @param userId string 削除リクエストユーザーID
   * @param isAdmin boolean 管理者フラグ
   * @returns Promise<void>
   * @throws NotFoundError レビューが存在しない時
   * @throws ForbiddenError 管理者権限なしの時
   */
  async deleteReview(reviewId: string, userId: string, isAdmin: boolean): Promise<void>;

  /**
   * レビューフラグ付け
   * @param reviewId string UUID
   * @param flagged boolean フラグ状態
   * @returns Promise<Review> 更新後のレビュー
   * @throws NotFoundError レビューが存在しない時
   */
  async flagReview(reviewId: string, flagged: boolean): Promise<Review>;
}
```

**型定義**
```typescript
interface CreateReviewInput {
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
}

interface GetProductReviewsOutput {
  data: Review[];
  averageRating: number;
  totalCount: number;
}
```

#### 内部ロジック

**createReview**
```typescript
async createReview(data: CreateReviewInput): Promise<Review> {
  // 1. バリデーション実行
  const errors = reviewValidator.validateReviewInput(data);
  if (errors.length > 0) {
    throw new ValidationError(errors[0].message, errors[0].field);
  }

  // 2. 商品存在確認
  const product = await this.productRepository.findById(data.productId);
  if (!product) {
    throw new NotFoundError('Product not found');
  }

  // 3. レビュー保存
  const review = await this.reviewRepository.create({
    productId: data.productId,
    userId: data.userId,
    rating: data.rating,
    title: data.title,
    body: data.body,
    images: data.images,
    flagged: false, // 初期値
  });

  return review;
}
```

**getProductReviews**
```typescript
async getProductReviews(productId: string): Promise<GetProductReviewsOutput> {
  // 1. 商品存在確認
  const product = await this.productRepository.findById(productId);
  if (!product) {
    throw new NotFoundError('Product not found');
  }

  // 2. レビュー一覧取得（新着順）
  const reviews = await this.reviewRepository.findByProductId(productId);

  // 3. 平均評価計算
  const averageRating = this.calculateAverageRating(reviews);

  return {
    data: reviews,
    averageRating,
    totalCount: reviews.length,
  };
}
```

**calculateAverageRating**
```typescript
calculateAverageRating(reviews: Review[]): number {
  if (reviews.length === 0) {
    return 0; // レビュー0件の場合は0を返す
  }

  const sum = reviews.reduce((acc, review) => acc + review.rating, 0);
  const average = sum / reviews.length;

  // 小数第1位で四捨五入
  return Math.round(average * 10) / 10;
}
```

**deleteReview**
```typescript
async deleteReview(reviewId: string, userId: string, isAdmin: boolean): Promise<void> {
  // 1. レビュー存在確認
  const review = await this.reviewRepository.findById(reviewId);
  if (!review) {
    throw new NotFoundError('Review not found');
  }

  // 2. 管理者権限確認
  if (!isAdmin) {
    throw new ForbiddenError('Admin access required');
  }

  // 3. レビュー削除
  await this.reviewRepository.delete(reviewId);
}
```

**flagReview**
```typescript
async flagReview(reviewId: string, flagged: boolean): Promise<Review> {
  // 1. レビュー存在確認
  const review = await this.reviewRepository.findById(reviewId);
  if (!review) {
    throw new NotFoundError('Review not found');
  }

  // 2. フラグ状態更新
  const updatedReview = await this.reviewRepository.updateFlag(reviewId, flagged);
  return updatedReview;
}
```

#### 依存関係
- `ReviewRepository` - レビューDB操作層（コンストラクタ注入）
- `ProductRepository` - 商品DB操作層（コンストラクタ注入）
- `reviewValidator` - バリデーションユーティリティ（静的インポート）
- カスタムエラー: `ValidationError`, `NotFoundError`, `ForbiddenError`

#### エッジケース
- **並行レビュー投稿**: 同一商品に複数ユーザーが同時投稿 → DB制約で保証、問題なし
- **削除済み商品へのレビュー表示**: 外部キー`ON DELETE CASCADE`で自動削除されるため、孤立レビューは存在しない
- **レビュー0件の平均評価**: `calculateAverageRating([])`は0を返す
- **ratingが1.5のような小数**: バリデーションで整数チェックを実施、ValidationError発生
- **imagesが空配列**: バリデーション通過（画像は任意のため）

---

### 4.3 ReviewRepository

#### 責務
reviewsテーブルへのCRUD操作。SQL実行とオブジェクト変換のみ担当。ビジネスロジックは含まない。

#### インターフェース

```typescript
export class ReviewRepository {
  constructor(private db: Database) {} // Database型は既存のDB接続オブジェクト

  /**
   * レビュー作成
   * @param data Omit<Review, 'id' | 'createdAt' | 'updatedAt'>
   * @returns Promise<Review>
   */
  async create(data: CreateReviewData): Promise<Review>;

  /**
   * ID指定レビュー取得
   * @param reviewId string UUID
   * @returns Promise<Review | null>
   */
  async findById(reviewId: string): Promise<Review | null>;

  /**
   * 商品ID指定レビュー一覧取得（新着順）
   * @param productId string UUID
   * @returns Promise<Review[]>
   */
  async findByProductId(productId: string): Promise<Review[]>;

  /**
   * レビュー削除（物理削除）
   * @param reviewId string UUID
   * @returns Promise<void>
   */
  async delete(reviewId: string): Promise<void>;

  /**
   * フラグ状態更新
   * @param reviewId string UUID
   * @param flagged boolean
   * @returns Promise<Review>
   */
  async updateFlag(reviewId: string, flagged: boolean): Promise<Review>;
}
```

**型定義**
```typescript
interface CreateReviewData {
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
  flagged: boolean;
}
```

#### 内部ロジック

**create**
```typescript
async create(data: CreateReviewData): Promise<Review> {
  const query = `
    INSERT INTO reviews (product_id, user_id, rating, title, body, images, flagged)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
  `;
  const values = [
    data.productId,
    data.userId,
    data.rating,
    data.title,
    data.body,
    data.images,
    data.flagged,
  ];

  const result = await this.db.query(query, values);
  return this.mapRowToReview(result.rows[0]);
}
```

**findById**
```typescript
async findById(reviewId: string): Promise<Review | null> {
  const query = `
    SELECT id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
    FROM reviews
    WHERE id = $1
  `;
  const result = await this.db.query(query, [reviewId]);

  if (result.rows.length === 0) {
    return null;
  }

  return this.mapRowToReview(result.rows[0]);
}
```

**findByProductId**
```typescript
async findByProductId(productId: string): Promise<Review[]> {
  const query = `
    SELECT id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
    FROM reviews
    WHERE product_id = $1
    ORDER BY created_at DESC
  `;
  const result = await this.db.query(query, [productId]);

  return result.rows.map(row => this.mapRowToReview(row));
}
```

**delete**
```typescript
async delete(reviewId: string): Promise<void> {
  const query = `DELETE FROM reviews WHERE id = $1`;
  await this.db.query(query, [reviewId]);
}
```

**updateFlag**
```typescript
async updateFlag(reviewId: string, flagged: boolean): Promise<Review> {
  const query = `
    UPDATE reviews
    SET flagged = $1, updated_at = NOW()
    WHERE id = $2
    RETURNING id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
  `;
  const result = await this.db.query(query, [flagged, reviewId]);
  return this.mapRowToReview(result.rows[0]);
}
```

**mapRowToReview（ヘルパーメソッド）**
```typescript
private mapRowToReview(row: any): Review {
  return {
    id: row.id,
    productId: row.product_id,
    userId: row.user_id,
    rating: row.rating,
    title: row.title,
    body: row.body,
    images: row.images || [], // PostgreSQL配列型 → JavaScript配列
    flagged: row.flagged,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at),
  };
}
```

#### 依存関係
- `Database` - PostgreSQL接続オブジェクト（既存の`db`インスタンス、型: `{ query: (sql: string, params: any[]) => Promise<{ rows: any[] }> }`）
- `pg`パッケージ v8.11.3（既存）

#### エッジケース
- **存在しないUUIDでfindById**: `null`を返す（例外を投げない）
- **存在しない商品IDでfindByProductId**: 空配列`[]`を返す
- **images配列がDBでNULLの場合**: `mapRowToReview`で空配列に変換
- **外部キー制約違反**: DB例外が発生し、上位層でInternalServerErrorとして処理
- **同時削除**: PostgreSQLのトランザクション分離レベル（READ COMMITTED）により、先に削除した方が成功、後続は削除対象なしで正常終了

---

### 4.4 S3Service

#### 責務
AWS S3へのファイルアップロード。画像ファイルの受信、S3へのPUT、公開URLの生成。

#### インターフェース

```typescript
export class S3Service {
  private s3Client: AWS.S3;
  private bucketName: string;

  constructor() {
    this.s3Client = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION || 'us-east-1',
    });
    this.bucketName = process.env.S3_BUCKET_NAME || 'shopnow-reviews';
  }

  /**
   * 画像アップロード
   * @param file Buffer ファイルバイナリ
   * @param fileName string ファイル名（拡張子含む）
   * @param contentType string MIMEタイプ（例: 'image/jpeg'）
   * @returns Promise<string> S3公開URL
   * @throws Error S3アップロード失敗時
   */
  async uploadImage(file: Buffer, fileName: string, contentType: string): Promise<string>;
}
```

#### 内部ロジック

**uploadImage**
```typescript
async uploadImage(file: Buffer, fileName: string, contentType: string): Promise<string> {
  // 1. S3キー生成（衝突回避のためUUIDプレフィックス付与）
  const key = `reviews/${uuidv4()}-${fileName}`;

  // 2. S3アップロードパラメータ設定
  const params: AWS.S3.PutObjectRequest = {
    Bucket: this.bucketName,
    Key: key,
    Body: file,
    ContentType: contentType,
    ACL: 'public-read', // 公開読み取り許可
  };

  try {
    // 3. S3にアップロード
    await this.s3Client.putObject(params).promise();

    // 4. 公開URL生成
    const url = `https://${this.bucketName}.s3.amazonaws.com/${key}`;
    return url;
  } catch (error) {
    // 5. エラーハンドリング
    throw new Error(`Failed to upload image: ${error.message}`);
  }
}
```

#### 依存関係
- `aws-sdk` v2.1543.0（新規追加）
- 環境変数:
  - `AWS_ACCESS_KEY_ID`: AWSアクセスキー（必須）
  - `AWS_SECRET_ACCESS_KEY`: AWSシークレットキー（必須）
  - `AWS_REGION`: AWSリージョン（デフォルト: 'us-east-1'）
  - `S3_BUCKET_NAME`: S3バケット名（デフォルト: 'shopnow-reviews'）
- `uuid` v9.0.0（既存と仮定）

#### エッジケース
- **環境変数未設定**: AWS SDKがエラーをthrow → InternalServerErrorとして処理
- **バケット不在**: S3が`NoSuchBucket`エラー返却 → Error例外
- **ネットワークタイムアウト**: AWS SDKのデフォルトタイムアウト（120秒）後にエラー
- **ファイル名に特殊文字**: `encodeURIComponent(fileName)`でエスケープ不要（UUIDプレフィックスで衝突回避済み）
- **同名ファイル**: UUIDプレフィックスにより衝突しない

---

### 4.5 reviewValidator

#### 責務
レビュー入力値のバリデーション。型チェック、範囲チェック、フォーマットチェックを実施し、エラーメッセージを返す。

#### インターフェース

```typescript
export const reviewValidator = {
  /**
   * レビュー入力値バリデーション
   * @param data CreateReviewInput
   * @returns ValidationErrorDetail[] エラー配列（空配列=正常）
   */
  validateReviewInput(data: CreateReviewInput): ValidationErrorDetail[];
};

interface ValidationErrorDetail {
  field: string;
  message: string;
}
```

#### 内部ロジック

**validateReviewInput**
```typescript
validateReviewInput(data: CreateReviewInput): ValidationErrorDetail[] {
  const errors: ValidationErrorDetail[] = [];

  // 1. productIdバリデーション
  if (!data.productId || !this.isUUID(data.productId)) {
    errors.push({ field: 'productId', message: 'productId must be a valid UUID' });
  }

  // 2. userIdバリデーション
  if (!data.userId || !this.isUUID(data.userId)) {
    errors.push({ field: 'userId', message: 'userId must be a valid UUID' });
  }

  // 3. ratingバリデーション
  if (typeof data.rating !== 'number' || !Number.isInteger(data.rating)) {
    errors.push({ field: 'rating', message: 'rating must be an integer' });
  } else if (data.rating < 1 || data.rating > 5) {
    errors.push({ field: 'rating', message: 'rating must be between 1 and 5' });
  }

  // 4. titleバリデーション
  if (typeof data.title !== 'string' || data.title.trim().length === 0) {
    errors.push({ field: 'title', message: 'title must be a non-empty string' });
  } else if (data.title.length > 200) {
    errors.push({ field: 'title', message: 'title must be 200 characters or less' });
  }

  // 5. bodyバリデーション
  if (typeof data.body !== 'string' || data.body.trim().length === 0) {
    errors.push({ field: 'body', message: 'body must be a non-empty string' });
  } else if (data.body.length > 10000) {
    errors.push({ field: 'body', message: 'body must be 10000 characters or less' });
  }

  // 6. imagesバリデーション
  if (!Array.isArray(data.images)) {
    errors.push({ field: 'images', message: 'images must be an array' });
  } else if (data.images.length > 3) {
    errors.push({ field: 'images', message: 'images must contain 3 or fewer URLs' });
  } else {
    data.images.forEach((url, index) => {
      if (!this.isValidURL(url)) {
        errors.push({ field: `images[${index}]`, message: `images[${index}] must be a valid HTTPS URL` });
      }
    });
  }

  return errors;
}

/**
 * UUID v4形式チェック
 */
private isUUID(value: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(value);
}

/**
 * HTTPS URLチェック
 */
private isValidURL(value: string): boolean {
  try {
    const url = new URL(value);
    return url.protocol === 'https:';
  } catch {
    return false;
  }
}
```

#### 依存関係
- 標準ライブラリのみ（外部パッケージ不要）

#### エッジケース
- **nullまたはundefined**: 型チェックで検出、エラー返却
- **ratingが1.5**: `Number.isInteger()`でfalse、エラー返却
- **titleが空白文字のみ**: `trim().length === 0`で検出
- **imagesがnull**: `Array.isArray()`でfalse、エラー返却
- **images内のURLがhttp**: `url.protocol === 'https:'`でfalse、エラー返却

---

### 4.6 ReviewForm.tsx（フロントエンド）

#### 責務
レビュー投稿フォームのUI表示、ユーザー入力受付、クライアント側バリデーション、API送信。

#### インターフェース

```typescript
interface ReviewFormProps {
  productId: string;
  onSuccess: () => void; // 投稿成功時のコールバック
}

export const ReviewForm: React.FC<ReviewFormProps> = ({ productId, onSuccess }) => { /* ... */ };
```

#### 内部ロジック

```typescript
export const ReviewForm: React.FC<ReviewFormProps> = ({ productId, onSuccess }) => {
  const [rating, setRating] = useState<number>(5);
  const [title, setTitle] = useState<string>('');
  const [body, setBody] = useState<string>(''); // リッチテキスト（HTML）
  const [images, setImages] = useState<string[]>([]); // S3 URLの配列
  const [uploading, setUploading] = useState<boolean>(false);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * 画像アップロード処理
   */
  const handleImageUpload = async (files: FileList) => {
    if (images.length + files.length > 3) {
      setError('画像は最大3枚までアップロードできます');
      return;
    }

    setUploading(true);
    setError(null);

    try {
      const uploadPromises = Array.from(files).map(async (file) => {
        // 画像形式チェック
        if (!file.type.startsWith('image/')) {
          throw new Error('画像ファイルのみアップロード可能です');
        }

        // ファイルサイズチェック（5MB上限）
        if (file.size > 5 * 1024 * 1024) {
          throw new Error('ファイルサイズは5MB以下にしてください');
        }

        // S3にアップロード
        const url = await reviewApi.uploadImage(file);
        return url;
      });

      const uploadedUrls = await Promise.all(uploadPromises);
      setImages([...images, ...uploadedUrls]);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setUploading(false);
    }
  };

  /**
   * フォーム送信処理
   */
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    setError(null);

    // クライアント側バリデーション
    if (title.trim().length === 0) {
      setError('タイトルを入力してください');
      setSubmitting(false);
      return;
    }

    if (body.trim().length === 0) {
      setError('レビュー本文を入力してください');
      setSubmitting(false);
      return;
    }

    try {
      // API送信
      await reviewApi.createReview({
        productId,
        rating,
        title,
        body,
        images,
      });

      // 成功時の処理
      onSuccess();
      
      // フォームリセット
      setRating(5);
      setTitle('');
      setBody('');
      setImages([]);
    } catch (err: any) {
      setError(err.message || 'レビューの投稿に失敗しました');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 星評価入力 */}
      <div>
        <label>評価</label>
        <StarRating value={rating} onChange={setRating} editable={true} />
      </div>

      {/* タイトル入力 */}
      <div>
        <label>タイトル</label>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          maxLength={200}
          required
        />
      </div>

      {/* 本文入力（リッチテキストエディタ） */}
      <div>
        <label>レビュー本文</label>
        <ReactQuill
          value={body}
          onChange={setBody}
          modules={{
            toolbar: [
              ['bold', 'italic', 'underline'],
              [{ list: 'ordered' }, { list: 'bullet' }],
              ['link'],
            ],
          }}
        />
      </div>

      {/* 画像アップロード */}
      <div>
        <label>画像（最大3枚）</label>
        <ImageUpload
          images={images}
          onUpload={handleImageUpload}
          onRemove={(index) => setImages(images.filter((_, i) => i !== index))}
          uploading={uploading}
        />
      </div>

      {/* エラー表示 */}
      {error && <div className="error">{error}</div>}

      {/* 送信ボタン */}
      <button type="submit" disabled={submitting || uploading}>
        {submitting ? '投稿中...' : 'レビューを投稿'}
      </button>
    </form>
  );
};
```

#### 依存関係
- `react` v18.2.0（既存）
- `react-quill` v2.0.0（新規追加、リッチテキストエディタ）
- `reviewApi` - API通信ユーティリティ
- `StarRating.tsx` - 星評価コンポーネント
- `ImageUpload.tsx` - 画像アップロードコンポーネント

#### エッジケース
- **画像4枚目アップロード試行**: `handleImageUpload`でエラーメッセージ表示、アップロード中止
- **5MB超過ファイル**: エラーメッセージ表示、アップロード中止
- **非画像ファイル**: エラーメッセージ表示、アップロード中止
- **ネットワークエラー**: `reviewApi`でエラーcatch、エラーメッセージ表示
- **空白文字のみのタイトル**: クライアント側バリデーションでエラー表示

---

### 4.7 ReviewList.tsx（フロントエンド）

#### 責務
レビュー一覧と平均評価の表示。商品IDに基づいてレビューデータを取得し、一覧レンダリング。

#### インターフェース

```typescript
interface ReviewListProps {
  productId: string;
}

export const ReviewList: React.FC<ReviewListProps> = ({ productId }) => { /* ... */ };
```

#### 内部ロジック

```typescript
export const ReviewList: React.FC<ReviewListProps> = ({ productId }) => {
  const { reviews, averageRating, totalCount, loading, error, refetch } = useReviews(productId);

  if (loading) {
    return <div>読み込み中...</div>;
  }

  if (error) {
    return <div>エラー: {error}</div>;
  }

  return (
    <div className="review-list">
      {/* ヘッダー */}
      <div className="review-header">
        <h2>レビュー ({totalCount}件)</h2>
        {totalCount > 0 && (
          <div className="average-rating">
            <span>平均評価: {averageRating.toFixed(1)}</span>
            <StarRating value={averageRating} editable={false} />
          </div>
        )}
      </div>

      {/* レビュー一覧 */}
      {reviews.length === 0 ? (
        <div className="no-reviews">まだレビューがありません</div>
      ) : (
        <div className="review-items">
          {reviews.map((review) => (
            <ReviewItem key={review.id} review={review} onDelete={refetch} />
          ))}
        </div>
      )}
    </div>
  );
};
```

#### 依存関係
- `useReviews` - レビュー取得カスタムフック
- `ReviewItem.tsx` - 個別レビューコンポーネント
- `StarRating.tsx` - 星評価コンポーネント

#### エッジケース
- **レビュー0件**: 「まだレビューがありません」メッセージ表示
- **API取得失敗**: エラーメッセージ表示
- **平均評価の表示**: `toFixed(1)`で小数第1位まで表示（例: 4.5）

---

### 4.8 sanitizeHtml.ts（フロントエンド）

#### 責務
HTMLサニタイズ処理。XSS攻撃防止のため、レビュー本文のHTMLから危険なタグ・属性を除去。

#### インターフェース

```typescript
/**
 * HTMLサニタイズ
 * @param html string 入力HTML
 * @returns string サニタイズ済みHTML
 */
export const sanitizeHtml = (html: string): string;
```

#### 内部ロジック

```typescript
import DOMPurify from 'dompurify';

export const sanitizeHtml = (html: string): string => {
  // DOMPurifyの設定
  const config = {
    ALLOWED_TAGS: ['b', 'i', 'u', 'strong', 'em', 'ul', 'ol', 'li', 'a', 'br', 'p'],
    ALLOWED_ATTR: ['href', 'target'],
    ALLOW_DATA_ATTR: false,
  };

  return DOMPurify.sanitize(html, config);
};
```

#### 依存関係
- `dompurify` v3.0.9（新規追加）
- `@types/dompurify` v3.0.5（新規追加）

#### エッジケース
- **scriptタグ**: 除去される
- **onerror属性**: 除去される
- **許可外タグ**: 除去される（例: `<iframe>`, `<object>`）
- **空HTML**: 空文字列を返す

---

### 4.9 useReviews.ts（カスタムフック）

#### 責務
レビューデータ取得ロジックのカプセル化。ローディング状態、エラー状態、再取得関数の管理。

#### インターフェース

```typescript
interface UseReviewsReturn {
  reviews: Review[];
  averageRating: number;
  totalCount: number;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useReviews = (productId: string): UseReviewsReturn;
```

#### 内部ロジック

```typescript
export const useReviews = (productId: string): UseReviewsReturn => {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [averageRating, setAverageRating] = useState<number>(0);
  const [totalCount, setTotalCount] = useState<number>(0);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchReviews = async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await reviewApi.getProductReviews(productId);
      setReviews(data.data);
      setAverageRating(data.averageRating);
      setTotalCount(data.totalCount);
    } catch (err: any) {
      setError(err.message || 'レビューの取得に失敗しました');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviews();
  }, [productId]); // productId変更時に再取得

  return {
    reviews,
    averageRating,
    totalCount,
    loading,
    error,
    refetch: fetchReviews, // 外部から再取得可能
  };
};
```

#### 依存関係
- `react` v18.2.0（既存）
- `reviewApi` - API通信ユーティリティ

#### エッジケース
- **productIdが変更された場合**: `useEffect`の依存配列により自動再取得
- **API取得失敗**: エラー状態を設定、UIでエラーメッセージ表示

---

### 4.10 reviewApi.ts（フロントエンド API通信）

#### 責務
レビューAPIエンドポイントへのHTTPリクエスト送信。認証トークン付与、エラーハンドリング。

#### インターフェース

```typescript
export const reviewApi = {
  /**
   * レビュー作成
   */
  async createReview(data: CreateReviewRequest): Promise<Review>;

  /**
   * 商品別レビュー一覧取得
   */
  async getProductReviews(productId: string): Promise<GetProductReviewsResponse>;

  /**
   * 画像アップロード
   */
  async uploadImage(file: File): Promise<string>; // S3 URLを返す

  /**
   * レビュー削除
   */
  async deleteReview(reviewId: string): Promise<void>;
};

interface CreateReviewRequest {
  productId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
}

interface GetProductReviewsResponse {
  data: Review[];
  averageRating: number;
  totalCount: number;
}
```

#### 内部ロジック

**createReview**
```typescript
async createReview(data: CreateReviewRequest): Promise<Review> {
  const response = await fetch('/api/reviews', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getAuthToken()}`, // 認証トークン取得
    },
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || 'レビューの投稿に失敗しました');
  }

  const result = await response.json();
  return result.data;
}
```

**getProductReviews**
```typescript
async getProductReviews(productId: string): Promise<GetProductReviewsResponse> {
  const response = await fetch(`/api/products/${productId}/reviews`, {
    method: 'GET',
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || 'レビューの取得に失敗しました');
  }

  return await response.json();
}
```

**uploadImage**
```typescript
async uploadImage(file: File): Promise<string> {
  const formData = new FormData();
  formData.append('image', file);

  const response = await fetch('/api/reviews/upload', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getAuthToken()}`,
    },
    body: formData,
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || '画像のアップロードに失敗しました');
  }

  const result = await response.json();
  return result.url; // S3 URL
}
```

**deleteReview**
```typescript
async deleteReview(reviewId: string): Promise<void> {
  const response = await fetch(`/api/reviews/${reviewId}`, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${getAuthToken()}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || 'レビューの削除に失敗しました');
  }
}
```

**getAuthToken（ヘルパー関数）**
```typescript
function getAuthToken(): string {
  // ローカルストレージまたはクッキーから認証トークン取得
  return localStorage.getItem('authToken') || '';
}
```

#### 依存関係
- Fetch API（ブラウザ標準）
- 認証トークン管理機構（既存と仮定）

#### エッジケース
- **認証トークン未設定**: 401エラーが返却され、エラーメッセージ表示
- **ネットワークエラー**: Fetch APIが例外をthrow、エラーメッセージ表示
- **400エラー（バリデーション失敗）**: サーバーのエラーメッセージを表示

---

## 5. ユニットテスト戦略

### 5.1 テスト方針

**既存パターンの踏襲**
- テストフレームワーク: Jest v29.5.0（既存）
- HTTPテスト: supertest v6.3.3（既存）
- モック: jest.mock()による依存モック
- テストファイル配置: `src/__tests__/`配下に配置
- 命名規則: `*.test.ts`形式

**カバレッジ目標**
- ライン: 80%以上
- 分岐: 80%以上
- 関数: 100%（全パブリックメソッド）

**テスト粒度**
- ユニットテスト: Repository, Service, Validator（単体テスト）
- 統合テスト: Controller（HTTPエンドポイントテスト）
- コンポーネントテスト: フロントエンド（React Testing Library）

### 5.2 テストケース一覧

#### 5.2.1 ReviewRepository テストケース（`src/__tests__/repositories/reviewRepository.test.ts`）

**正常系**
- `create()` - レビュー作成成功、戻り値にidとタイムスタンプが含まれることを確認
- `findById()` - 存在するIDでレビュー取得成功
- `findByProductId()` - 商品IDでレビュー一覧取得、新着順ソート確認
- `findByProductId()` - レビュー0件の場合、空配列を返す
- `delete()` - レビュー削除成功
- `updateFlag()` - フラグ状態更新成功、updated_atが更新されることを確認

**異常系**
- `findById()` - 存在しないIDでnullを返す
- `create()` - 外部キー制約違反（存在しないproductId）でDB例外発生
- `delete()` - 存在しないIDで削除実行、エラー発生しない（冪等性）

**境界値**
- `findByProductId()` - 大量レビュー（1000件）取得時のパフォーマンス確認
- `create()` - imagesが空配列の場合、正常保存

#### 5.2.2 ReviewService テストケース（`src/__tests__/services/reviewService.test.ts`）

**正常系**
- `createReview()` - 全フィールド正常でレビュー作成成功
- `createReview()` - imagesが空配列でレビュー作成成功
- `getProductReviews()` - レビュー一覧+平均評価取得成功
- `calculateAverageRating()` - [5, 4, 3]の平均が4.0になることを確認
- `calculateAverageRating()` - [5]の平均が5.0になることを確認
- `deleteReview()` - 管理者による削除成功
- `flagReview()` - フラグ付け成功

**異常系**
- `createReview()` - productIdが存在しない場合、NotFoundErrorをthrow
- `createReview()` - ratingが6の場合、ValidationErrorをthrow
- `createReview()` - titleが空文字の場合、ValidationErrorをthrow
- `createReview()` - imagesが4枚の場合、ValidationErrorをthrow
- `deleteReview()` - 非管理者による削除、ForbiddenErrorをthrow
- `deleteReview()` - 存在しないレビューID、NotFoundErrorをthrow
- `flagReview()` - 存在しないレビューID、NotFoundErrorをthrow

**境界値**
- `calculateAverageRating()` - 空配列で0を返す
- `createReview()` - titleがちょうど200文字で成功
- `createReview()` - titleが201文字でValidationErrorをthrow
- `createReview()` - bodyが10,000文字で成功
- `createReview()` - bodyが10,001文字でValidationErrorをthrow

#### 5.2.3 ReviewController テストケース（`src/__tests__/review.test.ts`）

**正常系**
- `POST /api/reviews` - 認証済みユーザーがレビュー投稿、201レスポンス
- `GET /api/products/:productId/reviews` - レビュー一覧取得、200レスポンス
- `DELETE /api/reviews/:reviewId` - 管理者がレビュー削除、200レスポンス
- `PATCH /api/reviews/:reviewId/flag` - 管理者がフラグ付け、200レスポンス

**異常系**
- `POST /api/reviews` - 未認証ユーザーがレビュー投稿、401レスポンス
- `POST /api/reviews` - ratingが6で送信、400レスポンス
- `POST /api/reviews` - 存在しないproductIdで送信、404レスポンス
- `GET /api/products/:productId/reviews` - 存在しないproductId、404レスポンス
- `DELETE /api/reviews/:reviewId` - 非管理者が削除試行、403レスポンス
- `DELETE /api/reviews/:reviewId` - 存在しないreviewId、404レスポンス

**境界値**
- `POST /api/reviews` - imagesが空配列で送信、201レスポンス
- `POST /api/reviews` - imagesが3枚で送信、201レスポンス
- `POST /api/reviews` - imagesが4枚で送信、400レスポンス

#### 5.2.4 reviewValidator テストケース（`src/__tests__/utils/reviewValidator.test.ts`）

**正常系**
- 全フィールド正常で空配列（エラーなし）を返す
- imagesが空配列で空配列を返す

**異常系**
- productIdがUUID形式でない、エラー返却
- ratingが小数、エラー返却
- ratingが0、エラー返却
- ratingが6、エラー返却
- titleが空文字、エラー返却
- titleが201文字、エラー返却
- bodyが空文字、エラー返却
- bodyが10,001文字、エラー返却
- imagesが配列でない、エラー返却
- imagesが4枚、エラー返却
- images内のURLがhttp、エラー返却

#### 5.2.5 ReviewForm.tsx テストケース（`src/__tests__/components/Review/ReviewForm.test.tsx`）

**正常系**
- フォームレンダリング、全フィールド表示確認
- レビュー投稿成功、onSuccessコールバック呼び出し確認
- 画像アップロード成功、プレビュー表示確認

**異常系**
- タイトル空で送信、エラーメッセージ表示
- 本文空で送信、エラーメッセージ表示
- 画像4枚アップロード試行、エラーメッセージ表示
- API送信失敗、エラーメッセージ表示

#### 5.2.6 ReviewList.tsx テストケース（`src/__tests__/components/Review/ReviewList.test.tsx`）

**正常系**
- レビュー一覧表示、全レビュー要素レンダリング確認
- 平均評価表示、計算値正確性確認
- レビュー0件の場合、「まだレビューがありません」表示確認

**異常系**
- API取得失敗、エラーメッセージ表示確認

### 5.3 テストデータ

**モックユーザー**
```typescript
const mockUser = {
  id: '11111111-1111-1111-1111-111111111111',
  email: 'test@example.com',
  isAdmin: false,
};

const mockAdmin = {
  id: '22222222-2222-2222-2222-222222222222',
  email: 'admin@example.com',
  isAdmin: true,
};
```

**モック商品**
```typescript
const mockProduct = {
  id: '33333333-3333-3333-3333-333333333333',
  name: 'Test Product',
  price: 1000,
};
```

**モックレビュー**
```typescript
const mockReview: Review = {
  id: '44444444-4444-4444-4444-444444444444',
  productId: '33333333-3333-3333-3333-333333333333',
  userId: '11111111-1111-1111-1111-111111111111',
  rating: 5,
  title: 'Great product!',
  body: '<p>This is a <strong>great</strong> product.</p>',
  images: ['https://example.com/image1.jpg'],
  flagged: false,
  createdAt: new Date('2026-01-01T00:00:00Z'),
  updatedAt: new Date('2026-01-01T00:00:00Z'),
};
```

**バリデーションエラーケース用データ**
```typescript
const invalidReviewData = {
  productId: 'invalid-uuid', // UUID形式違反
  userId: '11111111-1111-1111-1111-111111111111',
  rating: 6, // 範囲外
  title: '', // 空文字
  body: 'Valid body',
  images: ['http://example.com/image.jpg'], // HTTPS違反
};
```

---

## 6. 実装順序

### ステップ1: 環境セットアップ（所要時間: 30分）

**タスク内容**
- 依存ライブラリのインストール
- 環境変数の設定
- DBマイグレーション実行

**具体的作業**
```bash
# バックエンド
npm install aws-sdk@^2.1543.0

# フロントエンド
npm install dompurify@^3.0.9 @types/dompurify@^3.0.5 react-quill@^2.0.0 @types/react-quill@^2.0.0

# 環境変数設定（.env）
AWS_ACCESS_KEY_ID=<your-key>
AWS_SECRET_ACCESS_KEY=<your-secret>
AWS_REGION=us-east-1
S3_BUCKET_NAME=shopnow-reviews

# マイグレーション実行
psql -U postgres -d shopnow -f migrations/20260206_create_reviews_table.sql
```

**完了条件**
- `npm install`が全てエラーなく完了
- 環境変数が`.env`ファイルに設定済み
- `SELECT * FROM reviews LIMIT 0;`でテーブル存在確認

---

### ステップ2: エラークラス実装（所要時間: 30分）

**タスク内容**
- `ValidationError`, `NotFoundError`, `ForbiddenError`クラス作成
- `errorHandler`ミドルウェア修正

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/errors/ValidationError.ts`作成
- `/home/r-toyama/work/ai-experimental/src/errors/NotFoundError.ts`作成（既存なら確認）
- `/home/r-toyama/work/ai-experimental/src/errors/ForbiddenError.ts`作成
- `/home/r-toyama/work/ai-experimental/src/middleware/errorHandler.ts`修正

**完了条件**
- 各エラークラスが`Error`を継承し、`name`プロパティを持つ
- `errorHandler`で各エラーに対応するHTTPステータスコードを返す（ValidationError=400, NotFoundError=404, ForbiddenError=403）
- Jest単体テストで各エラークラスのインスタンス化を確認

---

### ステップ3: バリデーション実装（所要時間: 1時間）

**タスク内容**
- `reviewValidator.ts`実装
- テストケース作成・実行

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/utils/reviewValidator.ts`作成
- `/home/r-toyama/work/ai-experimental/src/__tests__/utils/reviewValidator.test.ts`作成
- 全バリデーションルールをテストケースでカバー

**完了条件**
- `npm test reviewValidator.test.ts`で全テストパス（正常系2件、異常系12件以上）
- カバレッジ100%

---

### ステップ4: Repository層実装（所要時間: 2時間）

**タスク内容**
- `Review.ts`モデル作成
- `ReviewRepository.ts`実装
- テストケース作成・実行

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/models/Review.ts`作成
- `/home/r-toyama/work/ai-experimental/src/repositories/reviewRepository.ts`作成
- `/home/r-toyama/work/ai-experimental/src/__tests__/repositories/reviewRepository.test.ts`作成
- テスト用DBセットアップ（テストデータ投入・クリーンアップ）

**完了条件**
- `npm test reviewRepository.test.ts`で全テストパス（正常系6件、異常系3件、境界値2件）
- 実際のPostgreSQLに対してCRUD操作が正常動作
- カバレッジ90%以上

---

### ステップ5: S3Service実装（所要時間: 1.5時間）

**タスク内容**
- `S3Service.ts`実装
- 画像アップロードAPIエンドポイント作成（`POST /api/reviews/upload`）
- 手動テスト（実際にS3にアップロードして確認）

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/services/s3Service.ts`作成
- `/home/r-toyama/work/ai-experimental/src/controllers/reviewController.ts`に`uploadImage`メソッド追加
- `/home/r-toyama/work/ai-experimental/src/routes/reviewRoutes.ts`に`POST /upload`ルート追加
- Postmanまたはcurlで画像アップロードテスト

**完了条件**
- 画像ファイルをPOSTし、S3 URLが返却される
- S3コンソールでファイルが`reviews/`ディレクトリに保存されていることを確認
- 公開URLでブラウザから画像アクセス可能

---

### ステップ6: Service層実装（所要時間: 2.5時間）

**タスク内容**
- `ReviewService.ts`実装
- テストケース作成・実行（Repository, ProductRepositoryをモック）

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/services/reviewService.ts`作成
- `/home/r-toyama/work/ai-experimental/src/__tests__/services/reviewService.test.ts`作成
- 依存リポジトリをjest.mock()でモック化

**完了条件**
- `npm test reviewService.test.ts`で全テストパス（正常系7件、異常系7件、境界値5件）
- カバレッジ90%以上

---

### ステップ7: Controller層実装（所要時間: 2時間）

**タスク内容**
- `ReviewController.ts`実装
- ルーティング設定
- 統合テスト作成・実行（supertest）

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/controllers/reviewController.ts`作成
- `/home/r-toyama/work/ai-experimental/src/routes/reviewRoutes.ts`作成
- `/home/r-toyama/work/ai-experimental/src/routes/index.ts`修正（レビュールート追加）
- `/home/r-toyama/work/ai-experimental/src/__tests__/review.test.ts`作成

**完了条件**
- `npm test review.test.ts`で全テストパス（正常系4件、異常系6件、境界値3件）
- 全APIエンドポイントが期待通りのステータスコードとレスポンスを返す

---

### ステップ8: フロントエンド共通実装（所要時間: 2時間）

**タスク内容**
- 型定義作成
- API通信ユーティリティ作成
- HTMLサニタイズユーティリティ作成
- カスタムフック作成

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/types/review.ts`作成
- `/home/r-toyama/work/ai-experimental/src/api/reviewApi.ts`作成
- `/home/r-toyama/work/ai-experimental/src/utils/sanitizeHtml.ts`作成
- `/home/r-toyama/work/ai-experimental/src/hooks/useReviews.ts`作成

**完了条件**
- TypeScriptコンパイルエラーなし
- `reviewApi`の各関数が正しいエンドポイントにリクエスト送信（ネットワークタブで確認）

---

### ステップ9: フロントエンドコンポーネント実装（所要時間: 4時間）

**タスク内容**
- `StarRating.tsx`作成（星評価表示）
- `ImageUpload.tsx`作成（画像アップロード）
- `ReviewItem.tsx`作成（個別レビュー表示）
- `ReviewList.tsx`作成（レビュー一覧）
- `ReviewForm.tsx`作成（レビュー投稿フォーム）
- コンポーネントテスト作成・実行

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/components/Review/StarRating.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/components/Review/ImageUpload.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/components/Review/ReviewItem.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/components/Review/ReviewList.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/components/Review/ReviewForm.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/__tests__/components/Review/ReviewForm.test.tsx`作成
- `/home/r-toyama/work/ai-experimental/src/__tests__/components/Review/ReviewList.test.tsx`作成

**完了条件**
- `npm test ReviewForm.test.tsx`で全テストパス
- `npm test ReviewList.test.tsx`で全テストパス
- ブラウザでコンポーネント単体表示確認（Storybook使用を推奨）

---

### ステップ10: 商品詳細ページ統合（所要時間: 1時間）

**タスク内容**
- `ProductDetailPage.tsx`にレビューセクション追加
- レビュー投稿→一覧更新のフロー確認

**具体的作業**
- `/home/r-toyama/work/ai-experimental/src/pages/ProductDetailPage.tsx`修正
- `<ReviewList productId={productId} />`をレンダリング
- 投稿成功時に`refetch()`を呼び出してリスト更新

**完了条件**
- 商品詳細ページでレビューセクションが表示される
- レビュー投稿後、ページリロードなしでレビュー一覧が更新される

---

### ステップ11: E2Eテスト（所要時間: 2時間）

**タスク内容**
- 手動E2Eテスト実施
- 主要シナリオの動作確認

**シナリオ**
1. ログインユーザーが商品詳細ページを表示
2. レビューフォームに入力（星5、タイトル、本文、画像2枚）
3. レビュー投稿ボタンをクリック
4. レビュー一覧に新規レビューが表示されることを確認
5. 平均評価が更新されることを確認
6. 管理者アカウントでログイン
7. 不適切なレビューにフラグを付ける
8. レビューを削除する
9. レビュー一覧から削除されたレビューが消えることを確認

**完了条件**
- 上記シナリオが全てエラーなく完了
- ネットワークタブでAPIレスポンスが期待通り
- コンソールエラーなし

---

### ステップ12: パフォーマンス・セキュリティ確認（所要時間: 1.5時間）

**タスク内容**
- SQLクエリのEXPLAIN ANALYZE実行
- XSS攻撃テスト
- 大量データ投入時の動作確認

**具体的作業**
- `EXPLAIN ANALYZE SELECT * FROM reviews WHERE product_id = '...' ORDER BY created_at DESC;`実行
- インデックスが使用されていることを確認
- レビュー本文に`<script>alert('XSS')</script>`を投稿し、サニタイズされることを確認
- 1つの商品に500件のレビューを投入し、レンダリング時間を測定（3秒以内）

**完了条件**
- 全SQLクエリがインデックスを使用（Seq Scanなし）
- XSS攻撃が成功しない（scriptタグが除去される）
- 500件レビュー表示時のレンダリング時間が3秒以内

---

### ステップ13: ドキュメント作成・レビュー依頼（所要時間: 1時間）

**タスク内容**
- API仕様書作成（OpenAPI形式）
- README更新
- プルリクエスト作成

**具体的作業**
- `docs/api/reviews.yaml`作成（OpenAPI 3.0）
- `README.md`に「レビュー機能」セクション追加
- GitHubでプルリクエスト作成、レビュー依頼

**完了条件**
- OpenAPI仕様書がSwagger UIで表示可能
- READMEに使用方法が記述されている
- プルリクエストが作成され、CI/CDパイプラインがパス

---

## 総所要時間見積もり: 23.5時間

---

## 補足: 設計判断の根拠

### なぜRepositoryパターンを採用するか
**根拠**: 既存コードベースが`ProductRepository`, `UserRepository`, `OrderRepository`でRepositoryパターンを使用しているため、一貫性維持のため同パターンを採用。

### なぜ平均評価をバックエンドで毎回計算するか
**根拠**: FR-3に「バックエンドでも全レビューから毎回計算」と明記されているため。パフォーマンスが問題になる場合は、将来的にproductsテーブルにaverage_ratingカラムを追加し、レビュー投稿時に非同期更新する方式に変更を検討。

### なぜ画像アップロードを先行実行するか
**根拠**: レビュー投稿失敗時に孤立S3ファイルが残る問題があるが、要件に「画像のクリーンアップ機能」が含まれていないため、現状は許容。将来的に定期クリーンアップバッチで対応。

### なぜHTMLリッチテキストをそのまま保存するか
**根拠**: FR-1に「HTMLリッチテキストで入力可能」、FR-2に「HTMLとしてそのまま表示」と明記されているため。XSS対策はフロントエンドの`sanitizeHtml()`で実施。

### なぜレビュー削除を物理削除にするか
**根拠**: DBスキーマに論理削除フラグ（deleted_at等）が定義されていないため。将来的に削除履歴が必要になる場合は、論理削除に変更を検討。

### なぜインデックスを3つ作成するか
**根拠**:
- `idx_reviews_product_id`: 商品詳細ページでの頻繁なWHERE検索のため
- `idx_reviews_user_id`: ユーザーマイページ機能（将来対応）に備えるため
- `idx_reviews_created_at`: 新着順ソートのパフォーマンス向上のため
- `idx_reviews_flagged`: 管理者画面での不適切レビュー一覧（WHERE flagged = true）のため（パーティャルインデックスで容量節約）

---

以上で開発計画書は完了です。この計画書に従って実装を進めることで、ブレなく機能を完成させることができます。
