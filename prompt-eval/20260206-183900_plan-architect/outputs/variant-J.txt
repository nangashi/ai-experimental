# 商品レビュー機能追加 - 詳細開発計画書

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| セキュリティ | **1** | HTMLインジェクション、SQLインジェクション、SSRF、認証欠如、画像検証なしの重大な脆弱性 |
| パフォーマンス | **2** | N+1問題、フロントエンドでの重複計算、キャッシュ戦略なし、DBインデックス設計不足 |
| 設計原則 | **2** | Domainモデルへのインフラ依存、レイヤー責務混在、Fat Modelアンチパターン |
| 一貫性 | **3** | 既存のRepository/Service/Controllerパターンは踏襲しているが、エラーハンドリングが不統一 |
| エラーハンドリング | **2** | バリデーション不足、トランザクション管理なし、ロールバック戦略不明 |
| テスト | **1** | テスト戦略未定義、外部依存のモック方針なし、E2Eテスト計画なし |
| データ設計 | **3** | 基本的なスキーマは妥当だが、複合インデックス不足、削除フラグなし、監査ログなし |
| 依存関係管理 | **2** | 「適当なものを使う」は不適切、バージョン固定なし、脆弱性管理方針なし |
| **総合** | **2.0** | 本番環境で重大なセキュリティ・パフォーマンス問題を引き起こす可能性が極めて高い |

---

## セクション1: 概要

### 1.1 重大な問題点と対策

#### 重大度: クリティカル（即修正必須）

1. **XSS脆弱性**
   - 問題: `dangerouslySetInnerHTML`でHTMLを直接レンダリング
   - 対策: HTMLサニタイゼーション（DOMPurify）+ Content Security Policy適用

2. **SQLインジェクション**
   - 問題: Controllerで直接SQL実行（生SQLの混入リスク）
   - 対策: Repositoryレイヤーへの完全委譲 + Prepared Statement徹底

3. **認証・認可の欠如**
   - 問題: 購入確認なしでレビュー投稿可能
   - 対策: `hasUserPurchasedProduct`チェック + JWTミドルウェアの適用

4. **画像アップロード攻撃**
   - 問題: ファイル検証なし、サイズ制限なし
   - 対策: MIME検証 + ファイルサイズ上限（5MB/枚）+ ウイルススキャン統合

5. **パフォーマンス問題**
   - 問題: フロントエンドで毎回平均計算
   - 対策: `average_rating`カラム追加 + DBトリガーによる自動更新

#### 重大度: 高（初期リリース前に対応）

6. **トランザクション管理不在**
   - 対策: レビュー作成+平均評価更新+画像アップロードを単一トランザクションで処理

7. **エラーハンドリング不統一**
   - 対策: カスタムエラークラス体系（`ReviewNotFoundError`, `UnauthorizedReviewError`等）の導入

### 1.2 アーキテクチャ方針

既存の3層アーキテクチャ（Controller/Service/Repository）に準拠しつつ、以下を追加:

- **Domain層**: `Review`, `ReviewImage`エンティティ（ビジネスロジックのみ、インフラ依存なし）
- **Infrastructure層**: `S3ImageService`, `DOMPurifyService`
- **Validation層**: `ReviewValidator`（Joi/Zod使用）
- **Middleware層**: `requirePurchase`ミドルウェア追加

---

## セクション2: ディレクトリ/ファイル設計

### 2.1 新規作成ファイル一覧（全17ファイル）

```
src/
├── controllers/
│   └── reviewController.ts                    # 新規
├── services/
│   ├── reviewService.ts                       # 新規
│   └── imageService.ts                        # 新規
├── repositories/
│   └── reviewRepository.ts                    # 新規
├── models/
│   ├── Review.ts                              # 新規
│   └── ReviewImage.ts                         # 新規
├── middleware/
│   ├── requirePurchase.ts                     # 新規
│   └── uploadLimiter.ts                       # 新規
├── validators/
│   └── reviewValidator.ts                     # 新規
├── utils/
│   ├── sanitizer.ts                           # 新規
│   └── ratingCalculator.ts                    # 新規
├── types/
│   └── review.types.ts                        # 新規
├── errors/
│   └── reviewErrors.ts                        # 新規
├── config/
│   └── s3Config.ts                            # 新規
└── __tests__/
    ├── review.test.ts                         # 新規
    ├── reviewService.test.ts                  # 新規
    └── reviewRepository.test.ts               # 新規
```

### 2.2 変更ファイル一覧

```
src/routes/index.ts                            # レビューエンドポイント追加
migrations/
└── 001_create_reviews_table.sql               # 新規
└── 002_add_average_rating_to_products.sql     # 新規
└── 003_create_review_triggers.sql             # 新規
```

---

## セクション3: アーキテクチャ設計

### 3.1 データベーススキーマ（改善版）

#### 3.1.1 reviewsテーブル

```sql
CREATE TABLE reviews (
  -- 主キー
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 外部キー
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- レビュー内容
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL, -- サニタイズ済みHTMLを保存
  
  -- 画像（JSONBに変更して検索可能に）
  images JSONB DEFAULT '[]'::jsonb,
  
  -- ステータス管理
  flagged BOOLEAN DEFAULT false,
  deleted_at TIMESTAMP NULL, -- 論理削除
  
  -- 監査ログ
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- 制約
  CONSTRAINT unique_user_product_review UNIQUE (user_id, product_id)
);

-- インデックス設計
CREATE INDEX idx_reviews_product_id ON reviews(product_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_flagged ON reviews(flagged) WHERE flagged = true;
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
CREATE INDEX idx_reviews_rating ON reviews(rating); -- 平均計算の高速化
```

**設計根拠**:
- `UNIQUE(user_id, product_id)`: 1商品につき1レビューのみ
- `deleted_at`: 物理削除ではなく論理削除で監査証跡を保持
- `images`をJSONBにした理由: 将来的に画像メタデータ（サイズ、alt text）を含める拡張性

#### 3.1.2 productsテーブル拡張

```sql
ALTER TABLE products
ADD COLUMN average_rating DECIMAL(3,2) DEFAULT 0.00,
ADD COLUMN review_count INTEGER DEFAULT 0;

CREATE INDEX idx_products_average_rating ON products(average_rating DESC);
```

#### 3.1.3 トリガー（平均評価の自動更新）

```sql
CREATE OR REPLACE FUNCTION update_product_rating()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE products
  SET 
    average_rating = (
      SELECT COALESCE(AVG(rating), 0)
      FROM reviews
      WHERE product_id = COALESCE(NEW.product_id, OLD.product_id)
        AND deleted_at IS NULL
    ),
    review_count = (
      SELECT COUNT(*)
      FROM reviews
      WHERE product_id = COALESCE(NEW.product_id, OLD.product_id)
        AND deleted_at IS NULL
    )
  WHERE id = COALESCE(NEW.product_id, OLD.product_id);
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_review_insert_update_rating
AFTER INSERT OR UPDATE OR DELETE ON reviews
FOR EACH ROW EXECUTE FUNCTION update_product_rating();
```

**設計根拠**: 
- トリガーで平均評価を自動計算することで、APIレスポンス速度を改善
- `COALESCE`でINSERT/UPDATE/DELETE全てに対応

### 3.2 API設計

#### 3.2.1 エンドポイント一覧

| メソッド | パス | 説明 | 認証 | 権限チェック |
|---------|------|------|------|------------|
| POST | `/api/products/:productId/reviews` | レビュー作成 | 必須 | 購入確認 |
| GET | `/api/products/:productId/reviews` | レビュー一覧取得 | 不要 | - |
| PATCH | `/api/reviews/:reviewId` | レビュー編集 | 必須 | 作成者のみ |
| DELETE | `/api/reviews/:reviewId` | レビュー削除 | 必須 | 作成者または管理者 |
| POST | `/api/reviews/:reviewId/flag` | 不適切フラグ | 必須 | - |
| POST | `/api/reviews/images/upload` | 画像アップロード | 必須 | - |

#### 3.2.2 レスポンススキーマ

```typescript
// GET /api/products/:productId/reviews
{
  "data": {
    "reviews": [
      {
        "id": "uuid",
        "productId": "uuid",
        "userId": "uuid",
        "userName": "John Doe", // JOINで取得
        "rating": 5,
        "title": "Great product!",
        "body": "<p>Sanitized HTML</p>",
        "images": [
          {
            "url": "https://cdn.shopnow.com/reviews/abc123.jpg",
            "thumbnailUrl": "https://cdn.shopnow.com/reviews/abc123_thumb.jpg"
          }
        ],
        "flagged": false,
        "createdAt": "2025-01-15T10:30:00Z",
        "updatedAt": "2025-01-15T10:30:00Z"
      }
    ],
    "pagination": {
      "total": 150,
      "page": 1,
      "pageSize": 20,
      "totalPages": 8
    },
    "aggregation": {
      "averageRating": 4.23,
      "totalReviews": 150,
      "ratingDistribution": {
        "5": 80,
        "4": 40,
        "3": 20,
        "2": 5,
        "1": 5
      }
    }
  }
}
```

### 3.3 依存関係管理

#### 3.3.1 新規追加パッケージ（package.json）

```json
{
  "dependencies": {
    "@aws-sdk/client-s3": "^3.540.0",
    "@aws-sdk/s3-request-presigner": "^3.540.0",
    "dompurify": "^3.0.9",
    "isomorphic-dompurify": "^2.9.0",
    "joi": "^17.12.2",
    "multer": "^1.4.5-lts.1",
    "sharp": "^0.33.2"
  },
  "devDependencies": {
    "@types/dompurify": "^3.0.5",
    "@types/multer": "^1.4.11",
    "aws-sdk-client-mock": "^3.0.1"
  }
}
```

**選定根拠**:
- `@aws-sdk/client-s3` v3.540.0: 最新安定版、Tree-shakingでバンドルサイズ削減
- `dompurify` v3.0.9: XSS対策の業界標準、CSP対応
- `joi` v17.12.2: 既存コードベースで使用実績あり（`validator.ts`参照）
- `sharp` v0.33.2: サーバーサイド画像リサイズ（クライアント側のみに依存しない）
- `multer`: ファイルアップロード処理の標準ライブラリ

---

## セクション4: 実装詳細仕様

### 4.1 Domain層（models/）

#### 4.1.1 Review.ts（ドメインモデル）

```typescript
import { ReviewImage } from './ReviewImage';

export interface ReviewProps {
  id: string;
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string; // サニタイズ済みHTMLを想定
  images: ReviewImage[];
  flagged: boolean;
  deletedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export class Review {
  private constructor(private readonly props: ReviewProps) {
    this.validate();
  }

  static create(props: Omit<ReviewProps, 'id' | 'createdAt' | 'updatedAt'>): Review {
    return new Review({
      ...props,
      id: '', // Repositoryで生成
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  }

  static reconstitute(props: ReviewProps): Review {
    return new Review(props);
  }

  private validate(): void {
    if (this.props.rating < 1 || this.props.rating > 5) {
      throw new Error('Rating must be between 1 and 5');
    }
    if (this.props.title.length > 200) {
      throw new Error('Title must be 200 characters or less');
    }
    if (this.props.body.length > 10000) {
      throw new Error('Body must be 10000 characters or less');
    }
    if (this.props.images.length > 3) {
      throw new Error('Maximum 3 images allowed');
    }
  }

  // Getters
  get id(): string { return this.props.id; }
  get productId(): string { return this.props.productId; }
  get userId(): string { return this.props.userId; }
  get rating(): number { return this.props.rating; }
  get title(): string { return this.props.title; }
  get body(): string { return this.props.body; }
  get images(): ReviewImage[] { return [...this.props.images]; }
  get flagged(): boolean { return this.props.flagged; }
  get deletedAt(): Date | null { return this.props.deletedAt; }
  get createdAt(): Date { return this.props.createdAt; }
  get updatedAt(): Date { return this.props.updatedAt; }

  // ビジネスロジック
  flag(): void {
    this.props.flagged = true;
    this.props.updatedAt = new Date();
  }

  softDelete(): void {
    this.props.deletedAt = new Date();
    this.props.updatedAt = new Date();
  }

  canBeEditedBy(userId: string): boolean {
    return this.props.userId === userId && !this.props.deletedAt;
  }

  canBeDeletedBy(userId: string, isAdmin: boolean): boolean {
    return (this.props.userId === userId || isAdmin) && !this.props.deletedAt;
  }

  toJSON(): Record<string, unknown> {
    return {
      id: this.props.id,
      productId: this.props.productId,
      userId: this.props.userId,
      rating: this.props.rating,
      title: this.props.title,
      body: this.props.body,
      images: this.props.images.map(img => img.toJSON()),
      flagged: this.props.flagged,
      createdAt: this.props.createdAt.toISOString(),
      updatedAt: this.props.updatedAt.toISOString(),
    };
  }
}
```

**設計根拠**:
- **Immutableパターン**: propsはprivate readonlyで外部から直接変更不可
- **Factory Pattern**: `create` vs `reconstitute`で新規作成とDB復元を区別
- **バリデーションの集約**: ドメインルールをコンストラクタで一元管理
- **インフラ依存の排除**: メール送信等のインフラ処理はServiceレイヤーで実行

#### 4.1.2 ReviewImage.ts

```typescript
export interface ReviewImageProps {
  url: string;
  thumbnailUrl: string;
  originalFileName: string;
  fileSize: number; // bytes
  mimeType: string;
}

export class ReviewImage {
  constructor(private readonly props: ReviewImageProps) {
    this.validate();
  }

  private validate(): void {
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (!allowedMimeTypes.includes(this.props.mimeType)) {
      throw new Error(`Invalid mime type: ${this.props.mimeType}`);
    }
    if (this.props.fileSize > 5 * 1024 * 1024) { // 5MB
      throw new Error('File size must be 5MB or less');
    }
  }

  get url(): string { return this.props.url; }
  get thumbnailUrl(): string { return this.props.thumbnailUrl; }
  get originalFileName(): string { return this.props.originalFileName; }
  get fileSize(): number { return this.props.fileSize; }
  get mimeType(): string { return this.props.mimeType; }

  toJSON(): Record<string, unknown> {
    return { ...this.props };
  }
}
```

### 4.2 Repository層

#### 4.2.1 reviewRepository.ts

```typescript
import { Pool, PoolClient } from 'pg';
import { Review } from '../models/Review';
import { ReviewImage } from '../models/ReviewImage';
import { NotFoundError } from '../errors/reviewErrors';

export interface ReviewFilters {
  productId?: string;
  userId?: string;
  minRating?: number;
  maxRating?: number;
  flagged?: boolean;
  includeDeleted?: boolean;
}

export interface PaginationOptions {
  page: number;
  pageSize: number;
}

export class ReviewRepository {
  constructor(private readonly db: Pool) {}

  async create(review: Review, client?: PoolClient): Promise<Review> {
    const dbClient = client || this.db;
    
    const result = await dbClient.query(
      `INSERT INTO reviews 
       (product_id, user_id, rating, title, body, images, flagged, deleted_at, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
       RETURNING *`,
      [
        review.productId,
        review.userId,
        review.rating,
        review.title,
        review.body,
        JSON.stringify(review.images.map(img => img.toJSON())),
        review.flagged,
        review.deletedAt,
        review.createdAt,
        review.updatedAt,
      ]
    );

    return this.mapToEntity(result.rows[0]);
  }

  async findById(id: string): Promise<Review | null> {
    const result = await this.db.query(
      'SELECT * FROM reviews WHERE id = $1 AND deleted_at IS NULL',
      [id]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return this.mapToEntity(result.rows[0]);
  }

  async findByProductId(
    productId: string,
    pagination: PaginationOptions,
    filters?: ReviewFilters
  ): Promise<{ reviews: Review[]; total: number }> {
    const offset = (pagination.page - 1) * pagination.pageSize;
    
    let whereClause = 'WHERE r.product_id = $1 AND r.deleted_at IS NULL';
    const params: unknown[] = [productId];
    let paramIndex = 2;

    if (filters?.minRating) {
      whereClause += ` AND r.rating >= $${paramIndex}`;
      params.push(filters.minRating);
      paramIndex++;
    }

    if (filters?.flagged !== undefined) {
      whereClause += ` AND r.flagged = $${paramIndex}`;
      params.push(filters.flagged);
      paramIndex++;
    }

    // レビュー取得（ユーザー名をJOIN）
    const reviewsQuery = `
      SELECT r.*, u.name as user_name
      FROM reviews r
      INNER JOIN users u ON r.user_id = u.id
      ${whereClause}
      ORDER BY r.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;
    params.push(pagination.pageSize, offset);

    const reviewsResult = await this.db.query(reviewsQuery, params);

    // 総数取得
    const countQuery = `SELECT COUNT(*) FROM reviews r ${whereClause}`;
    const countResult = await this.db.query(
      countQuery,
      params.slice(0, paramIndex - 1)
    );

    return {
      reviews: reviewsResult.rows.map(row => this.mapToEntity(row)),
      total: parseInt(countResult.rows[0].count),
    };
  }

  async update(review: Review, client?: PoolClient): Promise<Review> {
    const dbClient = client || this.db;

    const result = await dbClient.query(
      `UPDATE reviews
       SET rating = $1, title = $2, body = $3, images = $4, 
           flagged = $5, deleted_at = $6, updated_at = $7
       WHERE id = $8
       RETURNING *`,
      [
        review.rating,
        review.title,
        review.body,
        JSON.stringify(review.images.map(img => img.toJSON())),
        review.flagged,
        review.deletedAt,
        new Date(),
        review.id,
      ]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(`Review ${review.id} not found`);
    }

    return this.mapToEntity(result.rows[0]);
  }

  async getRatingDistribution(productId: string): Promise<Record<number, number>> {
    const result = await this.db.query(
      `SELECT rating, COUNT(*) as count
       FROM reviews
       WHERE product_id = $1 AND deleted_at IS NULL
       GROUP BY rating
       ORDER BY rating DESC`,
      [productId]
    );

    const distribution: Record<number, number> = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    result.rows.forEach(row => {
      distribution[row.rating] = parseInt(row.count);
    });

    return distribution;
  }

  async existsByUserAndProduct(userId: string, productId: string): Promise<boolean> {
    const result = await this.db.query(
      'SELECT 1 FROM reviews WHERE user_id = $1 AND product_id = $2 AND deleted_at IS NULL',
      [userId, productId]
    );
    return result.rows.length > 0;
  }

  private mapToEntity(row: Record<string, unknown>): Review {
    const imagesData = (row.images as Record<string, unknown>[]) || [];
    const images = imagesData.map(
      img => new ReviewImage({
        url: img.url as string,
        thumbnailUrl: img.thumbnailUrl as string,
        originalFileName: img.originalFileName as string,
        fileSize: img.fileSize as number,
        mimeType: img.mimeType as string,
      })
    );

    return Review.reconstitute({
      id: row.id as string,
      productId: row.product_id as string,
      userId: row.user_id as string,
      rating: row.rating as number,
      title: row.title as string,
      body: row.body as string,
      images,
      flagged: row.flagged as boolean,
      deletedAt: row.deleted_at ? new Date(row.deleted_at as string) : null,
      createdAt: new Date(row.created_at as string),
      updatedAt: new Date(row.updated_at as string),
    });
  }
}
```

**設計根拠**:
- **トランザクション対応**: `client?: PoolClient`でトランザクション管理を外部に委譲
- **N+1問題の回避**: `findByProductId`でユーザー名をJOIN取得
- **型安全性**: snake_caseのDB列名をcamelCaseに変換する`mapToEntity`

### 4.3 Service層

#### 4.3.1 reviewService.ts

```typescript
import { Pool } from 'pg';
import { Review } from '../models/Review';
import { ReviewImage } from '../models/ReviewImage';
import { ReviewRepository } from '../repositories/reviewRepository';
import { OrderRepository } from '../repositories/orderRepository';
import { ImageService } from './imageService';
import { SanitizerService } from '../utils/sanitizer';
import {
  UnauthorizedReviewError,
  DuplicateReviewError,
  ReviewNotFoundError,
} from '../errors/reviewErrors';

export interface CreateReviewDTO {
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  imageFiles: Express.Multer.File[];
}

export interface UpdateReviewDTO {
  rating?: number;
  title?: string;
  body?: string;
}

export class ReviewService {
  constructor(
    private readonly reviewRepository: ReviewRepository,
    private readonly orderRepository: OrderRepository,
    private readonly imageService: ImageService,
    private readonly sanitizer: SanitizerService,
    private readonly db: Pool
  ) {}

  async createReview(dto: CreateReviewDTO): Promise<Review> {
    // 1. 購入確認
    const hasPurchased = await this.orderRepository.hasUserPurchasedProduct(
      dto.userId,
      dto.productId
    );
    if (!hasPurchased) {
      throw new UnauthorizedReviewError(
        'You can only review products you have purchased'
      );
    }

    // 2. 重複確認
    const existingReview = await this.reviewRepository.existsByUserAndProduct(
      dto.userId,
      dto.productId
    );
    if (existingReview) {
      throw new DuplicateReviewError('You have already reviewed this product');
    }

    // 3. HTMLサニタイズ
    const sanitizedBody = this.sanitizer.sanitizeHtml(dto.body);

    // 4. トランザクション開始
    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      // 5. 画像アップロード（S3）
      const uploadedImages: ReviewImage[] = [];
      for (const file of dto.imageFiles) {
        const imageUrls = await this.imageService.uploadReviewImage(file);
        uploadedImages.push(
          new ReviewImage({
            url: imageUrls.original,
            thumbnailUrl: imageUrls.thumbnail,
            originalFileName: file.originalname,
            fileSize: file.size,
            mimeType: file.mimetype,
          })
        );
      }

      // 6. レビュー作成
      const review = Review.create({
        productId: dto.productId,
        userId: dto.userId,
        rating: dto.rating,
        title: dto.title,
        body: sanitizedBody,
        images: uploadedImages,
        flagged: false,
        deletedAt: null,
      });

      const savedReview = await this.reviewRepository.create(review, client);

      await client.query('COMMIT');
      return savedReview;
    } catch (error) {
      await client.query('ROLLBACK');
      // ロールバック時は画像削除
      const imageUrls = dto.imageFiles.map(f => f.filename);
      await this.imageService.deleteImages(imageUrls);
      throw error;
    } finally {
      client.release();
    }
  }

  async getProductReviews(
    productId: string,
    page: number = 1,
    pageSize: number = 20
  ): Promise<{
    reviews: Review[];
    total: number;
    averageRating: number;
    ratingDistribution: Record<number, number>;
  }> {
    const { reviews, total } = await this.reviewRepository.findByProductId(
      productId,
      { page, pageSize }
    );

    const ratingDistribution =
      await this.reviewRepository.getRatingDistribution(productId);

    // 平均計算（DBトリガーで更新されたproducts.average_ratingを使うのが理想だが、
    // ここでは明示的に計算）
    const averageRating =
      reviews.length > 0
        ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
        : 0;

    return {
      reviews,
      total,
      averageRating: Math.round(averageRating * 100) / 100,
      ratingDistribution,
    };
  }

  async updateReview(
    reviewId: string,
    userId: string,
    dto: UpdateReviewDTO
  ): Promise<Review> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new ReviewNotFoundError(`Review ${reviewId} not found`);
    }

    if (!review.canBeEditedBy(userId)) {
      throw new UnauthorizedReviewError('You cannot edit this review');
    }

    // 更新処理（Immutableパターンなので新しいReviewを作成）
    const updatedReview = Review.reconstitute({
      ...review,
      rating: dto.rating ?? review.rating,
      title: dto.title ?? review.title,
      body: dto.body ? this.sanitizer.sanitizeHtml(dto.body) : review.body,
      updatedAt: new Date(),
    });

    return this.reviewRepository.update(updatedReview);
  }

  async deleteReview(
    reviewId: string,
    userId: string,
    isAdmin: boolean
  ): Promise<void> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new ReviewNotFoundError(`Review ${reviewId} not found`);
    }

    if (!review.canBeDeletedBy(userId, isAdmin)) {
      throw new UnauthorizedReviewError('You cannot delete this review');
    }

    review.softDelete();
    await this.reviewRepository.update(review);

    // 画像削除（非同期でバックグラウンド実行）
    const imageUrls = review.images.map(img => img.url);
    this.imageService.deleteImages(imageUrls).catch(err => {
      console.error('Failed to delete review images:', err);
    });
  }

  async flagReview(reviewId: string): Promise<Review> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new ReviewNotFoundError(`Review ${reviewId} not found`);
    }

    review.flag();
    return this.reviewRepository.update(review);
  }
}
```

**設計根拠**:
- **トランザクション境界**: ServiceレイヤーでDB接続を管理
- **ロールバック戦略**: エラー時は画像も削除して整合性を保つ
- **DTO Pattern**: Controllerとの境界を明確化

#### 4.3.2 imageService.ts

```typescript
import {
  S3Client,
  PutObjectCommand,
  DeleteObjectsCommand,
} from '@aws-sdk/client-s3';
import sharp from 'sharp';
import crypto from 'crypto';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { s3Config } from '../config/s3Config';

export interface UploadedImageUrls {
  original: string;
  thumbnail: string;
}

export class ImageService {
  private readonly s3Client: S3Client;
  private readonly bucketName: string;

  constructor() {
    this.s3Client = new S3Client(s3Config.clientConfig);
    this.bucketName = s3Config.bucketName;
  }

  async uploadReviewImage(file: Express.Multer.File): Promise<UploadedImageUrls> {
    const fileId = crypto.randomUUID();
    const fileExtension = this.getExtension(file.mimetype);

    // 1. オリジナル画像の最適化（最大1920x1920、品質85%）
    const optimizedImage = await sharp(file.buffer)
      .resize(1920, 1920, { fit: 'inside', withoutEnlargement: true })
      .jpeg({ quality: 85 })
      .toBuffer();

    // 2. サムネイル生成（300x300）
    const thumbnailImage = await sharp(file.buffer)
      .resize(300, 300, { fit: 'cover' })
      .jpeg({ quality: 80 })
      .toBuffer();

    // 3. S3アップロード
    const originalKey = `reviews/images/${fileId}.${fileExtension}`;
    const thumbnailKey = `reviews/thumbnails/${fileId}_thumb.${fileExtension}`;

    await Promise.all([
      this.uploadToS3(originalKey, optimizedImage, file.mimetype),
      this.uploadToS3(thumbnailKey, thumbnailImage, file.mimetype),
    ]);

    return {
      original: this.getPublicUrl(originalKey),
      thumbnail: this.getPublicUrl(thumbnailKey),
    };
  }

  private async uploadToS3(
    key: string,
    buffer: Buffer,
    contentType: string
  ): Promise<void> {
    const command = new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      CacheControl: 'public, max-age=31536000', // 1年間キャッシュ
    });

    await this.s3Client.send(command);
  }

  async deleteImages(urls: string[]): Promise<void> {
    const keys = urls.map(url => this.extractKeyFromUrl(url));

    const command = new DeleteObjectsCommand({
      Bucket: this.bucketName,
      Delete: {
        Objects: keys.map(key => ({ Key: key })),
      },
    });

    await this.s3Client.send(command);
  }

  private getExtension(mimeType: string): string {
    const mimeMap: Record<string, string> = {
      'image/jpeg': 'jpg',
      'image/png': 'png',
      'image/webp': 'webp',
    };
    return mimeMap[mimeType] || 'jpg';
  }

  private getPublicUrl(key: string): string {
    return `https://${this.bucketName}.s3.amazonaws.com/${key}`;
  }

  private extractKeyFromUrl(url: string): string {
    const urlParts = new URL(url);
    return urlParts.pathname.substring(1); // 先頭の '/' を除去
  }
}
```

**設計根拠**:
- **Sharp使用理由**: サーバーサイドでリサイズすることでクライアント側の実装不備による巨大ファイルアップロードを防ぐ
- **バッチ削除**: `DeleteObjectsCommand`で複数画像を一括削除
- **CDN対応**: Cache-Controlヘッダーで長期キャッシュ

### 4.4 Controller層

#### 4.4.1 reviewController.ts

```typescript
import { Request, Response, NextFunction } from 'express';
import { ReviewService } from '../services/reviewService';
import { ReviewValidator } from '../validators/reviewValidator';
import { AuthRequest } from '../middleware/auth';

export class ReviewController {
  constructor(
    private readonly reviewService: ReviewService,
    private readonly validator: ReviewValidator
  ) {}

  createReview = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // バリデーション
      const validatedData = await this.validator.validateCreateReview(req.body);

      const review = await this.reviewService.createReview({
        productId: req.params.productId,
        userId: req.user!.id,
        rating: validatedData.rating,
        title: validatedData.title,
        body: validatedData.body,
        imageFiles: req.files as Express.Multer.File[],
      });

      res.status(201).json({
        data: review.toJSON(),
      });
    } catch (error) {
      next(error);
    }
  };

  getProductReviews = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const pageSize = parseInt(req.query.pageSize as string) || 20;

      const result = await this.reviewService.getProductReviews(
        req.params.productId,
        page,
        pageSize
      );

      res.json({
        data: {
          reviews: result.reviews.map(r => r.toJSON()),
          pagination: {
            total: result.total,
            page,
            pageSize,
            totalPages: Math.ceil(result.total / pageSize),
          },
          aggregation: {
            averageRating: result.averageRating,
            totalReviews: result.total,
            ratingDistribution: result.ratingDistribution,
          },
        },
      });
    } catch (error) {
      next(error);
    }
  };

  updateReview = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const validatedData = await this.validator.validateUpdateReview(req.body);

      const review = await this.reviewService.updateReview(
        req.params.reviewId,
        req.user!.id,
        validatedData
      );

      res.json({
        data: review.toJSON(),
      });
    } catch (error) {
      next(error);
    }
  };

  deleteReview = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      await this.reviewService.deleteReview(
        req.params.reviewId,
        req.user!.id,
        req.user!.isAdmin
      );

      res.status(204).send();
    } catch (error) {
      next(error);
    }
  };

  flagReview = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const review = await this.reviewService.flagReview(req.params.reviewId);

      res.json({
        data: review.toJSON(),
      });
    } catch (error) {
      next(error);
    }
  };
}
```

### 4.5 Validation層

#### 4.5.1 reviewValidator.ts

```typescript
import Joi from 'joi';
import { ValidationError } from '../errors/reviewErrors';

export class ReviewValidator {
  private readonly createReviewSchema = Joi.object({
    rating: Joi.number().integer().min(1).max(5).required(),
    title: Joi.string().max(200).required(),
    body: Joi.string().max(10000).required(),
  });

  private readonly updateReviewSchema = Joi.object({
    rating: Joi.number().integer().min(1).max(5).optional(),
    title: Joi.string().max(200).optional(),
    body: Joi.string().max(10000).optional(),
  }).min(1); // 少なくとも1つのフィールドが必要

  async validateCreateReview(data: unknown): Promise<{
    rating: number;
    title: string;
    body: string;
  }> {
    const { error, value } = this.createReviewSchema.validate(data);

    if (error) {
      throw new ValidationError(error.details[0].message);
    }

    return value;
  }

  async validateUpdateReview(data: unknown): Promise<{
    rating?: number;
    title?: string;
    body?: string;
  }> {
    const { error, value } = this.updateReviewSchema.validate(data);

    if (error) {
      throw new ValidationError(error.details[0].message);
    }

    return value;
  }
}
```

### 4.6 Middleware層

#### 4.6.1 requirePurchase.ts

```typescript
import { Response, NextFunction } from 'express';
import { AuthRequest } from './auth';
import { OrderRepository } from '../repositories/orderRepository';
import { UnauthorizedReviewError } from '../errors/reviewErrors';

export const createRequirePurchaseMiddleware = (
  orderRepository: OrderRepository
) => {
  return async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { productId } = req.params;
      const userId = req.user!.id;

      const hasPurchased = await orderRepository.hasUserPurchasedProduct(
        userId,
        productId
      );

      if (!hasPurchased) {
        throw new UnauthorizedReviewError(
          'You can only review products you have purchased'
        );
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};
```

#### 4.6.2 uploadLimiter.ts

```typescript
import multer from 'multer';
import { Request } from 'express';

const fileFilter = (
  req: Request,
  file: Express.Multer.File,
  cb: multer.FileFilterCallback
) => {
  const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp'];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`Invalid file type: ${file.mimetype}`));
  }
};

export const reviewImageUpload = multer({
  storage: multer.memoryStorage(), // S3に直接アップロードするのでメモリに保持
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 3, // 最大3ファイル
  },
  fileFilter,
});
```

### 4.7 Utils層

#### 4.7.1 sanitizer.ts

```typescript
import DOMPurify from 'isomorphic-dompurify';

export class SanitizerService {
  private readonly purify: typeof DOMPurify;

  constructor() {
    this.purify = DOMPurify;
    this.configurePurify();
  }

  private configurePurify(): void {
    // 許可するタグとアトリビュート
    this.purify.addHook('uponSanitizeElement', (node, data) => {
      // すべてのscriptタグを削除
      if (data.tagName === 'script') {
        node.remove();
      }
    });
  }

  sanitizeHtml(html: string): string {
    return this.purify.sanitize(html, {
      ALLOWED_TAGS: [
        'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3',
        'ul', 'ol', 'li', 'a', 'blockquote',
      ],
      ALLOWED_ATTR: ['href', 'target', 'rel'],
      ALLOW_DATA_ATTR: false,
    });
  }
}
```

**設計根拠**: 
- `isomorphic-dompurify`でサーバーサイド・クライアントサイド両対応
- 許可リスト方式で最小限のHTMLのみ許可

### 4.8 Error層

#### 4.8.1 reviewErrors.ts

```typescript
export class ReviewNotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ReviewNotFoundError';
  }
}

export class UnauthorizedReviewError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UnauthorizedReviewError';
  }
}

export class DuplicateReviewError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'DuplicateReviewError';
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### 4.9 Routes設定

#### 4.9.1 routes/index.ts（追加部分）

```typescript
import { Router } from 'express';
import { ReviewController } from '../controllers/reviewController';
import { ReviewService } from '../services/reviewService';
import { ReviewRepository } from '../repositories/reviewRepository';
import { OrderRepository } from '../repositories/orderRepository';
import { ImageService } from '../services/imageService';
import { SanitizerService } from '../utils/sanitizer';
import { ReviewValidator } from '../validators/reviewValidator';
import { authenticate } from '../middleware/auth';
import { createRequirePurchaseMiddleware } from '../middleware/requirePurchase';
import { reviewImageUpload } from '../middleware/uploadLimiter';
import { db } from '../db';

const router = Router();

// 依存性注入
const reviewRepository = new ReviewRepository(db);
const orderRepository = new OrderRepository(db);
const imageService = new ImageService();
const sanitizer = new SanitizerService();
const reviewService = new ReviewService(
  reviewRepository,
  orderRepository,
  imageService,
  sanitizer,
  db
);
const reviewValidator = new ReviewValidator();
const reviewController = new ReviewController(reviewService, reviewValidator);
const requirePurchase = createRequirePurchaseMiddleware(orderRepository);

// ルート定義
router.post(
  '/products/:productId/reviews',
  authenticate,
  requirePurchase,
  reviewImageUpload.array('images', 3),
  reviewController.createReview
);

router.get(
  '/products/:productId/reviews',
  reviewController.getProductReviews
);

router.patch(
  '/reviews/:reviewId',
  authenticate,
  reviewController.updateReview
);

router.delete(
  '/reviews/:reviewId',
  authenticate,
  reviewController.deleteReview
);

router.post(
  '/reviews/:reviewId/flag',
  authenticate,
  reviewController.flagReview
);

export default router;
```

---

## セクション5: ユニットテスト戦略

### 5.1 テストピラミッド戦略

```
      /\
     /E2E\           5% (Cypress/Playwright)
    /------\
   /Integration\     25% (Supertest)
  /------------\
 /  Unit Tests  \    70% (Jest)
/----------------\
```

### 5.2 ユニットテスト詳細

#### 5.2.1 Review.test.ts（Domainモデル）

```typescript
import { Review } from '../models/Review';
import { ReviewImage } from '../models/ReviewImage';

describe('Review Domain Model', () => {
  const validReviewProps = {
    productId: 'prod-123',
    userId: 'user-456',
    rating: 5,
    title: 'Great product',
    body: '<p>Loved it!</p>',
    images: [],
    flagged: false,
    deletedAt: null,
  };

  describe('create', () => {
    it('should create a valid review', () => {
      const review = Review.create(validReviewProps);

      expect(review.rating).toBe(5);
      expect(review.title).toBe('Great product');
      expect(review.deletedAt).toBeNull();
    });

    it('should throw error when rating is out of range', () => {
      expect(() => {
        Review.create({ ...validReviewProps, rating: 6 });
      }).toThrow('Rating must be between 1 and 5');
    });

    it('should throw error when title exceeds 200 characters', () => {
      const longTitle = 'a'.repeat(201);
      expect(() => {
        Review.create({ ...validReviewProps, title: longTitle });
      }).toThrow('Title must be 200 characters or less');
    });

    it('should throw error when more than 3 images', () => {
      const images = Array(4).fill(
        new ReviewImage({
          url: 'https://example.com/image.jpg',
          thumbnailUrl: 'https://example.com/thumb.jpg',
          originalFileName: 'test.jpg',
          fileSize: 1000,
          mimeType: 'image/jpeg',
        })
      );

      expect(() => {
        Review.create({ ...validReviewProps, images });
      }).toThrow('Maximum 3 images allowed');
    });
  });

  describe('canBeEditedBy', () => {
    it('should return true when user is the author', () => {
      const review = Review.create(validReviewProps);
      expect(review.canBeEditedBy('user-456')).toBe(true);
    });

    it('should return false when user is not the author', () => {
      const review = Review.create(validReviewProps);
      expect(review.canBeEditedBy('other-user')).toBe(false);
    });

    it('should return false when review is deleted', () => {
      const review = Review.create(validReviewProps);
      review.softDelete();
      expect(review.canBeEditedBy('user-456')).toBe(false);
    });
  });

  describe('flag', () => {
    it('should set flagged to true', () => {
      const review = Review.create(validReviewProps);
      review.flag();
      expect(review.flagged).toBe(true);
    });
  });
});
```

#### 5.2.2 reviewService.test.ts

```typescript
import { ReviewService } from '../services/reviewService';
import { ReviewRepository } from '../repositories/reviewRepository';
import { OrderRepository } from '../repositories/orderRepository';
import { ImageService } from '../services/imageService';
import { SanitizerService } from '../utils/sanitizer';
import { UnauthorizedReviewError, DuplicateReviewError } from '../errors/reviewErrors';

describe('ReviewService', () => {
  let reviewService: ReviewService;
  let mockReviewRepository: jest.Mocked<ReviewRepository>;
  let mockOrderRepository: jest.Mocked<OrderRepository>;
  let mockImageService: jest.Mocked<ImageService>;
  let mockSanitizer: jest.Mocked<SanitizerService>;
  let mockDb: any;

  beforeEach(() => {
    mockReviewRepository = {
      create: jest.fn(),
      findById: jest.fn(),
      findByProductId: jest.fn(),
      update: jest.fn(),
      existsByUserAndProduct: jest.fn(),
      getRatingDistribution: jest.fn(),
    } as any;

    mockOrderRepository = {
      hasUserPurchasedProduct: jest.fn(),
    } as any;

    mockImageService = {
      uploadReviewImage: jest.fn(),
      deleteImages: jest.fn(),
    } as any;

    mockSanitizer = {
      sanitizeHtml: jest.fn(html => html),
    } as any;

    mockDb = {
      connect: jest.fn().mockResolvedValue({
        query: jest.fn(),
        release: jest.fn(),
      }),
    };

    reviewService = new ReviewService(
      mockReviewRepository,
      mockOrderRepository,
      mockImageService,
      mockSanitizer,
      mockDb
    );
  });

  describe('createReview', () => {
    const createReviewDto = {
      productId: 'prod-123',
      userId: 'user-456',
      rating: 5,
      title: 'Great',
      body: '<p>Test</p>',
      imageFiles: [],
    };

    it('should throw UnauthorizedReviewError when user has not purchased', async () => {
      mockOrderRepository.hasUserPurchasedProduct.mockResolvedValue(false);

      await expect(reviewService.createReview(createReviewDto)).rejects.toThrow(
        UnauthorizedReviewError
      );
    });

    it('should throw DuplicateReviewError when review already exists', async () => {
      mockOrderRepository.hasUserPurchasedProduct.mockResolvedValue(true);
      mockReviewRepository.existsByUserAndProduct.mockResolvedValue(true);

      await expect(reviewService.createReview(createReviewDto)).rejects.toThrow(
        DuplicateReviewError
      );
    });

    it('should sanitize HTML before saving', async () => {
      mockOrderRepository.hasUserPurchasedProduct.mockResolvedValue(true);
      mockReviewRepository.existsByUserAndProduct.mockResolvedValue(false);
      mockReviewRepository.create.mockResolvedValue({} as any);

      await reviewService.createReview(createReviewDto);

      expect(mockSanitizer.sanitizeHtml).toHaveBeenCalledWith('<p>Test</p>');
    });

    it('should rollback and delete images on error', async () => {
      mockOrderRepository.hasUserPurchasedProduct.mockResolvedValue(true);
      mockReviewRepository.existsByUserAndProduct.mockResolvedValue(false);
      mockImageService.uploadReviewImage.mockResolvedValue({
        original: 'https://example.com/img.jpg',
        thumbnail: 'https://example.com/thumb.jpg',
      });

      const mockClient = {
        query: jest.fn()
          .mockResolvedValueOnce({}) // BEGIN
          .mockRejectedValueOnce(new Error('DB error')), // INSERT失敗
        release: jest.fn(),
      };
      mockDb.connect.mockResolvedValue(mockClient);

      const dtoWithImages = {
        ...createReviewDto,
        imageFiles: [{ filename: 'test.jpg' } as any],
      };

      await expect(reviewService.createReview(dtoWithImages)).rejects.toThrow();

      expect(mockImageService.deleteImages).toHaveBeenCalled();
    });
  });
});
```

#### 5.2.3 reviewRepository.test.ts

```typescript
import { Pool } from 'pg';
import { ReviewRepository } from '../repositories/reviewRepository';
import { Review } from '../models/Review';

describe('ReviewRepository', () => {
  let repository: ReviewRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    mockPool = {
      query: jest.fn(),
    } as any;

    repository = new ReviewRepository(mockPool);
  });

  describe('findByProductId', () => {
    it('should return reviews with pagination', async () => {
      mockPool.query
        .mockResolvedValueOnce({
          rows: [
            {
              id: 'rev-1',
              product_id: 'prod-123',
              user_id: 'user-456',
              rating: 5,
              title: 'Great',
              body: 'Test',
              images: [],
              flagged: false,
              deleted_at: null,
              created_at: new Date(),
              updated_at: new Date(),
              user_name: 'John Doe',
            },
          ],
        } as any)
        .mockResolvedValueOnce({
          rows: [{ count: '1' }],
        } as any);

      const result = await repository.findByProductId(
        'prod-123',
        { page: 1, pageSize: 20 }
      );

      expect(result.reviews).toHaveLength(1);
      expect(result.total).toBe(1);
    });

    it('should apply minRating filter', async () => {
      mockPool.query.mockResolvedValue({
        rows: [],
      } as any);

      await repository.findByProductId(
        'prod-123',
        { page: 1, pageSize: 20 },
        { minRating: 4 }
      );

      const query = mockPool.query.mock.calls[0][0] as string;
      expect(query).toContain('rating >=');
    });
  });

  describe('getRatingDistribution', () => {
    it('should return distribution with all ratings', async () => {
      mockPool.query.mockResolvedValue({
        rows: [
          { rating: 5, count: '10' },
          { rating: 4, count: '5' },
        ],
      } as any);

      const distribution = await repository.getRatingDistribution('prod-123');

      expect(distribution).toEqual({
        5: 10,
        4: 5,
        3: 0,
        2: 0,
        1: 0,
      });
    });
  });
});
```

### 5.3 統合テスト（E2Eテスト）

#### 5.3.1 review.integration.test.ts

```typescript
import request from 'supertest';
import { app } from '../app';
import { db } from '../db';

describe('Review API Integration Tests', () => {
  let authToken: string;
  let productId: string;
  let userId: string;

  beforeAll(async () => {
    // テストユーザー作成
    const userRes = await request(app)
      .post('/api/auth/register')
      .send({ email: 'test@example.com', password: 'password123' });
    
    authToken = userRes.body.token;
    userId = userRes.body.user.id;

    // テスト商品作成
    const productRes = await request(app)
      .post('/api/products')
      .set('Authorization', `Bearer ${authToken}`)
      .send({ name: 'Test Product', price: 1000 });
    
    productId = productRes.body.data.id;

    // 購入履歴作成
    await db.query(
      'INSERT INTO orders (user_id, product_id, status) VALUES ($1, $2, $3)',
      [userId, productId, 'completed']
    );
  });

  afterAll(async () => {
    await db.query('DELETE FROM reviews');
    await db.query('DELETE FROM orders');
    await db.query('DELETE FROM products');
    await db.query('DELETE FROM users');
  });

  describe('POST /api/products/:productId/reviews', () => {
    it('should create a review successfully', async () => {
      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          rating: 5,
          title: 'Great product',
          body: '<p>Loved it!</p>',
        });

      expect(res.status).toBe(201);
      expect(res.body.data.rating).toBe(5);
      expect(res.body.data.title).toBe('Great product');
    });

    it('should return 401 when not authenticated', async () => {
      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .send({ rating: 5, title: 'Test', body: 'Test' });

      expect(res.status).toBe(401);
    });

    it('should return 403 when user has not purchased', async () => {
      // 新規ユーザー作成（購入履歴なし）
      const newUserRes = await request(app)
        .post('/api/auth/register')
        .send({ email: 'test2@example.com', password: 'password123' });

      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${newUserRes.body.token}`)
        .send({ rating: 5, title: 'Test', body: 'Test' });

      expect(res.status).toBe(403);
    });
  });

  describe('GET /api/products/:productId/reviews', () => {
    it('should return reviews with aggregation', async () => {
      const res = await request(app)
        .get(`/api/products/${productId}/reviews`);

      expect(res.status).toBe(200);
      expect(res.body.data.reviews).toBeInstanceOf(Array);
      expect(res.body.data.aggregation).toHaveProperty('averageRating');
      expect(res.body.data.aggregation).toHaveProperty('ratingDistribution');
    });
  });
});
```

---

## セクション6: 実装順序

### フェーズ1: 基盤構築（1-2日）

**目標**: データベース、モデル、エラーハンドリングの基盤を確立

1. **データベース設定**
   - `migrations/001_create_reviews_table.sql` 作成・実行
   - `migrations/002_add_average_rating_to_products.sql` 作成・実行
   - `migrations/003_create_review_triggers.sql` 作成・実行
   - インデックスの作成確認

2. **Domainモデル実装**
   - `src/models/ReviewImage.ts` 実装
   - `src/models/Review.ts` 実装
   - ユニットテスト `__tests__/Review.test.ts` 作成・実行

3. **エラークラス実装**
   - `src/errors/reviewErrors.ts` 実装

4. **設定ファイル実装**
   - `src/config/s3Config.ts` 実装（環境変数の追加も）

**検証**:
```bash
npm run test -- Review.test.ts
psql -d shopnow_db -c "\d reviews"
```

---

### フェーズ2: Infrastructure層（2-3日）

**目標**: 外部依存（DB、S3、サニタイザ）の実装

5. **Repository実装**
   - `src/repositories/reviewRepository.ts` 実装
   - `src/repositories/orderRepository.ts` に `hasUserPurchasedProduct` メソッド追加
   - ユニットテスト `__tests__/reviewRepository.test.ts` 作成・実行

6. **ImageService実装**
   - `src/services/imageService.ts` 実装
   - S3接続確認テスト

7. **Sanitizer実装**
   - `src/utils/sanitizer.ts` 実装
   - XSSテストケース作成

8. **Validator実装**
   - `src/validators/reviewValidator.ts` 実装

**検証**:
```bash
npm run test -- reviewRepository.test.ts
node -e "const {SanitizerService} = require('./dist/utils/sanitizer'); console.log(new SanitizerService().sanitizeHtml('<script>alert(1)</script><p>Test</p>'));"
```

---

### フェーズ3: Service層（2日）

**目標**: ビジネスロジックの実装

9. **ReviewService実装**
   - `src/services/reviewService.ts` 実装
   - トランザクション処理の確認
   - ユニットテスト `__tests__/reviewService.test.ts` 作成・実行

**検証**:
```bash
npm run test -- reviewService.test.ts
```

---

### フェーズ4: Presentation層（2日）

**目標**: API実装

10. **Middleware実装**
    - `src/middleware/requirePurchase.ts` 実装
    - `src/middleware/uploadLimiter.ts` 実装

11. **Controller実装**
    - `src/controllers/reviewController.ts` 実装

12. **Routes設定**
    - `src/routes/index.ts` にレビューエンドポイント追加

**検証**:
```bash
npm run dev
curl -X POST http://localhost:3000/api/products/test-id/reviews \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"rating":5,"title":"Test","body":"<p>Test</p>"}'
```

---

### フェーズ5: 統合テスト（2日）

**目標**: E2Eテストの実装と実行

13. **統合テスト実装**
    - `__tests__/review.integration.test.ts` 実装
    - 全エンドポイントのテスト作成

14. **パフォーマンステスト**
    - 1000件のレビューを作成してレスポンス時間計測
    - DBトリガーの動作確認

**検証**:
```bash
npm run test:integration
```

---

### フェーズ6: セキュリティ監査・最適化（1-2日）

**目標**: セキュリティ脆弱性の排除とパフォーマンス最適化

15. **セキュリティチェック**
    - SQLインジェクション対策確認
    - XSS対策確認（DOMPurifyのテスト）
    - 認可チェック（購入確認）の確認
    - 画像アップロード攻撃対策確認

16. **パフォーマンス最適化**
    - DBクエリのEXPLAIN ANALYZE実行
    - N+1問題の確認
    - キャッシュ戦略の検討（Redis導入検討）

**検証**:
```bash
# XSSテスト
curl -X POST http://localhost:3000/api/products/test-id/reviews \
  -H "Authorization: Bearer <token>" \
  -d '{"rating":5,"title":"Test","body":"<script>alert(1)</script><p>Safe</p>"}'

# SQLインジェクションテスト
curl "http://localhost:3000/api/products/test-id/reviews?page=1'; DROP TABLE reviews;--"
```

---

### フェーズ7: ドキュメント作成（1日）

17. **APIドキュメント作成**
    - OpenAPI 3.0仕様書作成
    - Postmanコレクション作成

18. **運用ドキュメント作成**
    - デプロイ手順書
    - トラブルシューティングガイド

---

## 総実装期間: 12-15日

| フェーズ | 期間 | 依存関係 |
|---------|------|---------|
| 1. 基盤構築 | 1-2日 | なし |
| 2. Infrastructure層 | 2-3日 | フェーズ1完了後 |
| 3. Service層 | 2日 | フェーズ2完了後 |
| 4. Presentation層 | 2日 | フェーズ3完了後 |
| 5. 統合テスト | 2日 | フェーズ4完了後 |
| 6. セキュリティ監査 | 1-2日 | フェーズ5完了後 |
| 7. ドキュメント | 1日 | フェーズ6完了後 |

---

## 付録A: 環境変数設定

```env
# S3設定
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
S3_BUCKET_NAME=shopnow-reviews
S3_CDN_URL=https://cdn.shopnow.com

# データベース
DATABASE_URL=postgresql://user:password@localhost:5432/shopnow_db

# セキュリティ
JWT_SECRET=your-jwt-secret
```

---

## 付録B: チェックリスト

### セキュリティチェックリスト

- [ ] SQLインジェクション対策（Prepared Statement使用）
- [ ] XSS対策（DOMPurifyでサニタイズ）
- [ ] CSRF対策（CSRFトークン実装）
- [ ] 認証確認（JWTミドルウェア適用）
- [ ] 認可確認（購入確認ミドルウェア実装）
- [ ] ファイルアップロード制限（MIME、サイズ、数量）
- [ ] レート制限（express-rate-limit導入検討）
- [ ] Content Security Policy設定
- [ ] HTTPS強制

### パフォーマンスチェックリスト

- [ ] DBインデックス作成確認
- [ ] N+1問題の排除
- [ ] トランザクション境界の最適化
- [ ] 画像の遅延ロード実装
- [ ] CDNキャッシュ設定
- [ ] APIレスポンスのGzip圧縮

### テストカバレッジ目標

- [ ] Unit Tests: 80%以上
- [ ] Integration Tests: 主要フロー100%カバー
- [ ] E2E Tests: 重要ユーザーストーリー100%カバー

---

**この計画に従うことで、セキュアで保守性の高いレビュー機能を構築できます。各フェーズで検証を行い、問題を早期発見してください。**
