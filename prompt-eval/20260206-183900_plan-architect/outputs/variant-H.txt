このテスト入力を分析し、開発計画を作成します。まず既存のコードベース構造を確認します。
テスト入力として提供された情報のみを基に、詳細な開発計画を作成します。

---

# 商品レビュー機能追加 - 詳細開発計画書

## 1. 概要

### 1.1 目的
ECサイト「ShopNow」に商品レビュー機能を追加し、ユーザーが購入した商品に対して星評価、テキスト、画像を含むレビューを投稿・閲覧できるようにする。

### 1.2 スコープ
**含まれる機能:**
- レビュー投稿機能（星評価、タイトル、リッチテキスト本文、画像最大3枚）
- レビュー一覧表示機能（新着順、平均評価表示）
- 管理者によるレビュー削除・フラグ機能
- 画像のS3アップロード機能

**含まれない機能:**
- レビューの編集機能
- レビューへのコメント・返信機能
- レビューの絞り込み・ソート機能（新着順のみ）
- 画像の自動リサイズ処理（クライアント側で実施）

### 1.3 前提条件
- Node.js、Express、PostgreSQL、React + TypeScriptの開発環境が構築済み
- 既存のユーザー認証機構（req.userでユーザー情報取得可能）
- 既存のエラーハンドリングミドルウェア（NotFoundError等のカスタムエラー）
- S3互換ストレージへのアクセス権限
- 既存のRepositoryパターン、Controller-Service-Repositoryアーキテクチャ

### 1.4 ユーザー選定事項
- バックエンド: Node.js + Express
- データベース: PostgreSQL
- 画像ストレージ: S3互換ストレージ（AWS SDK v3使用）
- フロントエンド: React + TypeScript
- 画像処理: クライアント側でリサイズ実施

---

## 2. ディレクトリ/ファイル設計

### 2.1 新規作成ファイル一覧

```
src/
├── controllers/
│   └── reviewController.ts               # レビューのHTTPリクエスト処理
├── services/
│   ├── reviewService.ts                  # レビューのビジネスロジック
│   └── imageUploadService.ts             # S3画像アップロード処理
├── repositories/
│   └── reviewRepository.ts               # レビューのDB操作
├── models/
│   ├── Review.ts                         # Reviewエンティティ
│   └── ReviewReport.ts                   # レビュー集計結果の型
├── middleware/
│   └── reviewValidation.ts               # レビュー投稿のバリデーション
├── routes/
│   └── reviewRoutes.ts                   # レビューのエンドポイント定義
├── utils/
│   ├── htmlSanitizer.ts                  # HTMLサニタイズ処理
│   └── averageCalculator.ts              # 平均評価計算ユーティリティ
├── __tests__/
│   ├── review.test.ts                    # レビュー機能の統合テスト
│   ├── reviewService.test.ts             # reviewServiceの単体テスト
│   ├── imageUploadService.test.ts        # imageUploadServiceの単体テスト
│   └── htmlSanitizer.test.ts             # HTMLサニタイザーのテスト
└── types/
    └── review.types.ts                   # レビュー関連の型定義

migrations/
└── 001_create_reviews_table.sql          # reviewsテーブル作成マイグレーション

frontend/src/
├── components/
│   ├── ReviewList.tsx                    # レビュー一覧表示コンポーネント
│   ├── ReviewForm.tsx                    # レビュー投稿フォーム
│   ├── ReviewItem.tsx                    # 個別レビュー表示
│   ├── StarRating.tsx                    # 星評価表示コンポーネント
│   └── ImageUploader.tsx                 # 画像アップロードUI
├── hooks/
│   ├── useReviews.ts                     # レビュー取得カスタムフック
│   └── useReviewSubmit.ts                # レビュー投稿カスタムフック
├── services/
│   ├── reviewApiService.ts               # レビューAPI通信
│   └── imageResizeService.ts             # 画像リサイズ処理
└── types/
    └── review.types.ts                   # フロントエンド側の型定義
```

### 2.2 既存ファイルへの修正

```
src/routes/index.ts                       # reviewRoutesを追加
package.json                              # 依存関係追加（後述）
```

---

## 3. アーキテクチャ設計

### 3.1 全体アーキテクチャ

```
[Client Browser]
      ↓ (HTTPS)
[React SPA]
 ├─ ReviewForm → ImageResizeService (クライアント側リサイズ)
 ├─ ReviewList
 └─ ReviewItem
      ↓ (REST API)
[Express Server]
 ├─ reviewRoutes.ts
 ├─ auth middleware (既存)
 ├─ reviewValidation middleware
 ├─ ReviewController
 │   └─ ReviewService
 │       ├─ ReviewRepository → [PostgreSQL]
 │       └─ ImageUploadService → [S3 Storage]
 └─ errorHandler middleware (既存)
```

### 3.2 データフロー

#### 3.2.1 レビュー投稿フロー
```
1. [Client] ユーザーがフォーム入力（星評価、タイトル、本文、画像選択）
2. [Client] ImageResizeService で画像を800x800px以下にリサイズ
3. [Client] POST /api/products/:productId/reviews にリクエスト
   Body: { rating, title, body, images: [base64...] }
4. [Server] auth middleware でユーザー認証確認
5. [Server] reviewValidation middleware でバリデーション
   - rating: 1-5の整数
   - title: 1-200文字
   - body: 1-10000文字
   - images: 最大3枚、各5MB以下
6. [Controller] ReviewController.createReview()
7. [Service] ReviewService.createReview()
   a. htmlSanitizer で本文をサニタイズ（XSS対策）
   b. ImageUploadService で画像をS3にアップロード
   c. ReviewRepository.create() でDBに保存
8. [Repository] INSERT INTO reviews ...
9. [Response] 201 Created { data: { id, productId, ... } }
```

#### 3.2.2 レビュー一覧取得フロー
```
1. [Client] GET /api/products/:productId/reviews
2. [Controller] ReviewController.getProductReviews()
3. [Service] ReviewService.findByProductId()
4. [Repository] SELECT * FROM reviews WHERE product_id = $1 ORDER BY created_at DESC
5. [Service] averageCalculator.calculate(reviews) で平均評価計算
6. [Response] 200 OK { data: reviews[], averageRating: 4.2, totalCount: 15 }
7. [Client] ReviewList で表示
```

### 3.3 レイヤー責務定義

| レイヤー | 責務 | 禁止事項 |
|---------|------|---------|
| Controller | HTTPリクエスト/レスポンス処理、エラーハンドリング | ビジネスロジック、DB直接アクセス |
| Service | ビジネスロジック、トランザクション制御、外部サービス連携 | HTTPレスポンス生成、SQL直接実行 |
| Repository | DB操作のみ | ビジネスロジック、外部API呼び出し |
| Middleware | 認証、バリデーション、ロギング | ビジネスロジック |

---

## 4. 実装詳細仕様

### 4.1 データモデル詳細

#### 4.1.1 Review.ts
**問題点分析:**
- ❌ Reviewモデルにビジネスロジック（calculateAverage, sendNotification, generateReport）が含まれている → 単一責任原則違反
- ❌ calculateAverageが静的メソッドだがドメインロジックが混在 → Serviceレイヤーで実装すべき

**修正版実装:**
```typescript
// src/models/Review.ts
export interface Review {
  id: string;
  productId: string;
  userId: string;
  rating: number;           // 1-5
  title: string;            // max 200文字
  body: string;             // HTMLサニタイズ済み、max 10000文字
  images: string[];         // S3 URLの配列、max 3件
  flagged: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateReviewInput {
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;             // サニタイズ前のHTML
  images: string[];         // base64エンコード画像データ
}

export interface UpdateReviewFlagInput {
  reviewId: string;
  flagged: boolean;
}
```

#### 4.1.2 ReviewReport.ts
```typescript
// src/models/ReviewReport.ts
export interface ReviewReport {
  productId: string;
  totalReviews: number;
  averageRating: number;
  ratingDistribution: {
    1: number;
    2: number;
    3: number;
    4: number;
    5: number;
  };
}
```

#### 4.1.3 型定義
```typescript
// src/types/review.types.ts
export interface ReviewWithUser extends Review {
  userName: string;
  userAvatar?: string;
}

export interface ReviewListResponse {
  data: Review[];
  averageRating: number;
  totalCount: number;
}

export interface CreateReviewResponse {
  data: Review;
}
```

### 4.2 データベース設計

#### 4.2.1 マイグレーションスクリプト
**問題点分析:**
- ✅ 基本的なスキーマ設計は妥当
- ❌ インデックスが未定義 → パフォーマンス問題
- ❌ updated_atの自動更新トリガーが未定義

**修正版実装:**
```sql
-- migrations/001_create_reviews_table.sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  images TEXT[] DEFAULT '{}',
  flagged BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- パフォーマンス最適化用インデックス
CREATE INDEX idx_reviews_product_id ON reviews(product_id);
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
CREATE INDEX idx_reviews_flagged ON reviews(flagged) WHERE flagged = true;

-- updated_at自動更新トリガー
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reviews_updated_at
  BEFORE UPDATE ON reviews
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ユーザーが商品ごとに1レビューのみ投稿可能にする制約
CREATE UNIQUE INDEX idx_reviews_user_product_unique ON reviews(user_id, product_id);
```

### 4.3 バックエンド実装

#### 4.3.1 ReviewRepository
**問題点分析:**
- 提案されたControllerでDB直接アクセス → アーキテクチャ違反

**正しい実装:**
```typescript
// src/repositories/reviewRepository.ts
import { Pool } from 'pg';
import { Review, CreateReviewInput, UpdateReviewFlagInput } from '../models/Review';

export class ReviewRepository {
  constructor(private db: Pool) {}

  async create(input: Omit<CreateReviewInput, 'images'> & { images: string[] }): Promise<Review> {
    const query = `
      INSERT INTO reviews (product_id, user_id, rating, title, body, images)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
    `;
    const values = [
      input.productId,
      input.userId,
      input.rating,
      input.title,
      input.body,
      input.images
    ];
    const result = await this.db.query(query, values);
    return this.mapRowToReview(result.rows[0]);
  }

  async findByProductId(productId: string): Promise<Review[]> {
    const query = `
      SELECT id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
      FROM reviews
      WHERE product_id = $1
      ORDER BY created_at DESC
    `;
    const result = await this.db.query(query, [productId]);
    return result.rows.map(row => this.mapRowToReview(row));
  }

  async findById(id: string): Promise<Review | null> {
    const query = `
      SELECT id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
      FROM reviews
      WHERE id = $1
    `;
    const result = await this.db.query(query, [id]);
    if (result.rows.length === 0) return null;
    return this.mapRowToReview(result.rows[0]);
  }

  async updateFlag(input: UpdateReviewFlagInput): Promise<Review> {
    const query = `
      UPDATE reviews
      SET flagged = $1
      WHERE id = $2
      RETURNING id, product_id, user_id, rating, title, body, images, flagged, created_at, updated_at
    `;
    const result = await this.db.query(query, [input.flagged, input.reviewId]);
    if (result.rows.length === 0) {
      throw new Error(`Review with id ${input.reviewId} not found`);
    }
    return this.mapRowToReview(result.rows[0]);
  }

  async deleteById(id: string): Promise<void> {
    const query = 'DELETE FROM reviews WHERE id = $1';
    await this.db.query(query, [id]);
  }

  async existsByUserAndProduct(userId: string, productId: string): Promise<boolean> {
    const query = `
      SELECT EXISTS(
        SELECT 1 FROM reviews WHERE user_id = $1 AND product_id = $2
      ) as exists
    `;
    const result = await this.db.query(query, [userId, productId]);
    return result.rows[0].exists;
  }

  private mapRowToReview(row: any): Review {
    return {
      id: row.id,
      productId: row.product_id,
      userId: row.user_id,
      rating: row.rating,
      title: row.title,
      body: row.body,
      images: row.images || [],
      flagged: row.flagged,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at)
    };
  }
}
```

#### 4.3.2 ImageUploadService
**問題点分析:**
- 「適当なライブラリを使う」→ 具体的なライブラリとバージョンを指定
- 画像検証が未定義 → ファイルサイズ、MIMEタイプの検証必須
- S3設定が未定義 → バケット名、リージョン、アクセス権限の明示

**実装:**
```typescript
// src/services/imageUploadService.ts
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { v4 as uuidv4 } from 'uuid';
import { BadRequestError } from '../middleware/errorHandler';

export class ImageUploadService {
  private s3Client: S3Client;
  private bucketName: string;
  private maxFileSize = 5 * 1024 * 1024; // 5MB
  private allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp'];

  constructor() {
    this.s3Client = new S3Client({
      region: process.env.AWS_REGION || 'us-east-1',
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
      }
    });
    this.bucketName = process.env.S3_BUCKET_NAME || 'shopnow-review-images';
  }

  async uploadImages(base64Images: string[]): Promise<string[]> {
    if (base64Images.length > 3) {
      throw new BadRequestError('Maximum 3 images allowed');
    }

    const uploadPromises = base64Images.map(base64 => this.uploadSingleImage(base64));
    return Promise.all(uploadPromises);
  }

  private async uploadSingleImage(base64Data: string): Promise<string> {
    // base64データのバリデーション
    const matches = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
    if (!matches || matches.length !== 3) {
      throw new BadRequestError('Invalid base64 image format');
    }

    const mimeType = matches[1];
    const base64Content = matches[2];

    if (!this.allowedMimeTypes.includes(mimeType)) {
      throw new BadRequestError(`Invalid image type. Allowed: ${this.allowedMimeTypes.join(', ')}`);
    }

    const buffer = Buffer.from(base64Content, 'base64');

    if (buffer.length > this.maxFileSize) {
      throw new BadRequestError(`Image size exceeds ${this.maxFileSize / 1024 / 1024}MB limit`);
    }

    // S3にアップロード
    const fileExtension = this.getExtensionFromMimeType(mimeType);
    const fileName = `reviews/${uuidv4()}.${fileExtension}`;

    const command = new PutObjectCommand({
      Bucket: this.bucketName,
      Key: fileName,
      Body: buffer,
      ContentType: mimeType,
      ACL: 'public-read' // または CloudFront経由でのアクセス制御
    });

    await this.s3Client.send(command);

    // 公開URLを返却
    return `https://${this.bucketName}.s3.amazonaws.com/${fileName}`;
  }

  private getExtensionFromMimeType(mimeType: string): string {
    const map: Record<string, string> = {
      'image/jpeg': 'jpg',
      'image/png': 'png',
      'image/webp': 'webp'
    };
    return map[mimeType] || 'jpg';
  }
}
```

#### 4.3.3 ReviewService
**問題点分析:**
- 平均評価計算がController、Service、Frontendで重複 → Serviceに集約
- HTMLサニタイズが未実装 → XSS脆弱性
- トランザクション制御が未定義

**実装:**
```typescript
// src/services/reviewService.ts
import { ReviewRepository } from '../repositories/reviewRepository';
import { ImageUploadService } from './imageUploadService';
import { sanitizeHtml } from '../utils/htmlSanitizer';
import { calculateAverage } from '../utils/averageCalculator';
import { Review, CreateReviewInput } from '../models/Review';
import { ReviewListResponse } from '../types/review.types';
import { BadRequestError, NotFoundError } from '../middleware/errorHandler';

export class ReviewService {
  constructor(
    private reviewRepository: ReviewRepository,
    private imageUploadService: ImageUploadService
  ) {}

  async createReview(input: CreateReviewInput): Promise<Review> {
    // 重複投稿チェック
    const exists = await this.reviewRepository.existsByUserAndProduct(
      input.userId,
      input.productId
    );
    if (exists) {
      throw new BadRequestError('You have already reviewed this product');
    }

    // HTMLサニタイズ
    const sanitizedBody = sanitizeHtml(input.body);

    // 画像アップロード
    let imageUrls: string[] = [];
    if (input.images && input.images.length > 0) {
      imageUrls = await this.imageUploadService.uploadImages(input.images);
    }

    // レビュー保存
    const review = await this.reviewRepository.create({
      productId: input.productId,
      userId: input.userId,
      rating: input.rating,
      title: input.title,
      body: sanitizedBody,
      images: imageUrls
    });

    return review;
  }

  async findByProductId(productId: string): Promise<ReviewListResponse> {
    const reviews = await this.reviewRepository.findByProductId(productId);
    const averageRating = calculateAverage(reviews.map(r => r.rating));

    return {
      data: reviews,
      averageRating,
      totalCount: reviews.length
    };
  }

  async updateReviewFlag(reviewId: string, flagged: boolean): Promise<Review> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }

    return this.reviewRepository.updateFlag({ reviewId, flagged });
  }

  async deleteReview(reviewId: string): Promise<void> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }

    await this.reviewRepository.deleteById(reviewId);
  }
}
```

#### 4.3.4 ReviewController
**問題点分析:**
- DB直接アクセス → Serviceレイヤーを経由すべき
- エラーハンドリングが未実装 → 既存パターン（try-catch + next(error)）に準拠
- レスポンス形式が不統一

**実装:**
```typescript
// src/controllers/reviewController.ts
import { Request, Response, NextFunction } from 'express';
import { ReviewService } from '../services/reviewService';
import { CreateReviewInput } from '../models/Review';

export class ReviewController {
  constructor(private reviewService: ReviewService) {}

  async createReview(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { rating, title, body, images } = req.body;
      const productId = req.params.productId;
      const userId = req.user!.id; // authミドルウェアで保証

      const input: CreateReviewInput = {
        productId,
        userId,
        rating,
        title,
        body,
        images: images || []
      };

      const review = await this.reviewService.createReview(input);
      res.status(201).json({ data: review });
    } catch (error) {
      next(error);
    }
  }

  async getProductReviews(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const productId = req.params.productId;
      const result = await this.reviewService.findByProductId(productId);
      res.json(result);
    } catch (error) {
      next(error);
    }
  }

  async updateReviewFlag(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const reviewId = req.params.reviewId;
      const { flagged } = req.body;

      const review = await this.reviewService.updateReviewFlag(reviewId, flagged);
      res.json({ data: review });
    } catch (error) {
      next(error);
    }
  }

  async deleteReview(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const reviewId = req.params.reviewId;
      await this.reviewService.deleteReview(reviewId);
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
```

#### 4.3.5 Middleware - reviewValidation.ts
**問題点分析:**
- バリデーションが未実装 → 不正データでDB制約エラーが発生

**実装:**
```typescript
// src/middleware/reviewValidation.ts
import { Request, Response, NextFunction } from 'express';
import { BadRequestError } from './errorHandler';

export const validateCreateReview = (req: Request, res: Response, next: NextFunction): void => {
  const { rating, title, body, images } = req.body;

  // rating検証
  if (!rating || !Number.isInteger(rating) || rating < 1 || rating > 5) {
    throw new BadRequestError('Rating must be an integer between 1 and 5');
  }

  // title検証
  if (!title || typeof title !== 'string') {
    throw new BadRequestError('Title is required');
  }
  if (title.trim().length === 0) {
    throw new BadRequestError('Title cannot be empty');
  }
  if (title.length > 200) {
    throw new BadRequestError('Title must not exceed 200 characters');
  }

  // body検証
  if (!body || typeof body !== 'string') {
    throw new BadRequestError('Body is required');
  }
  if (body.trim().length === 0) {
    throw new BadRequestError('Body cannot be empty');
  }
  if (body.length > 10000) {
    throw new BadRequestError('Body must not exceed 10000 characters');
  }

  // images検証
  if (images && !Array.isArray(images)) {
    throw new BadRequestError('Images must be an array');
  }
  if (images && images.length > 3) {
    throw new BadRequestError('Maximum 3 images allowed');
  }

  next();
};

export const validateUpdateReviewFlag = (req: Request, res: Response, next: NextFunction): void => {
  const { flagged } = req.body;

  if (typeof flagged !== 'boolean') {
    throw new BadRequestError('Flagged must be a boolean');
  }

  next();
};
```

#### 4.3.6 Utils - htmlSanitizer.ts
**問題点分析:**
- HTMLがそのまま表示される（dangerouslySetInnerHTML） → XSS脆弱性

**実装:**
```typescript
// src/utils/htmlSanitizer.ts
import sanitizeHtmlLib from 'sanitize-html';

export function sanitizeHtml(html: string): string {
  return sanitizeHtmlLib(html, {
    allowedTags: ['b', 'i', 'em', 'strong', 'u', 'p', 'br', 'ul', 'ol', 'li', 'a'],
    allowedAttributes: {
      'a': ['href', 'title']
    },
    allowedSchemes: ['http', 'https'],
    disallowedTagsMode: 'discard'
  });
}
```

#### 4.3.7 Utils - averageCalculator.ts
**実装:**
```typescript
// src/utils/averageCalculator.ts
export function calculateAverage(ratings: number[]): number {
  if (ratings.length === 0) return 0;
  const sum = ratings.reduce((acc, rating) => acc + rating, 0);
  return parseFloat((sum / ratings.length).toFixed(1));
}
```

#### 4.3.8 Routes - reviewRoutes.ts
**実装:**
```typescript
// src/routes/reviewRoutes.ts
import { Router } from 'express';
import { ReviewController } from '../controllers/reviewController';
import { ReviewService } from '../services/reviewService';
import { ReviewRepository } from '../repositories/reviewRepository';
import { ImageUploadService } from '../services/imageUploadService';
import { auth } from '../middleware/auth';
import { validateCreateReview, validateUpdateReviewFlag } from '../middleware/reviewValidation';
import { db } from '../app'; // PostgreSQL接続プール

const router = Router();

// 依存性注入
const reviewRepository = new ReviewRepository(db);
const imageUploadService = new ImageUploadService();
const reviewService = new ReviewService(reviewRepository, imageUploadService);
const reviewController = new ReviewController(reviewService);

// エンドポイント定義
router.post(
  '/products/:productId/reviews',
  auth,
  validateCreateReview,
  (req, res, next) => reviewController.createReview(req, res, next)
);

router.get(
  '/products/:productId/reviews',
  (req, res, next) => reviewController.getProductReviews(req, res, next)
);

router.patch(
  '/reviews/:reviewId/flag',
  auth,
  // TODO: 管理者権限チェックミドルウェア追加
  validateUpdateReviewFlag,
  (req, res, next) => reviewController.updateReviewFlag(req, res, next)
);

router.delete(
  '/reviews/:reviewId',
  auth,
  // TODO: 管理者権限チェックミドルウェア追加
  (req, res, next) => reviewController.deleteReview(req, res, next)
);

export default router;
```

#### 4.3.9 既存ファイル修正 - routes/index.ts
```typescript
// src/routes/index.ts (修正箇所のみ)
import reviewRoutes from './reviewRoutes';

// 既存のルート設定の後に追加
app.use('/api', reviewRoutes);
```

### 4.4 フロントエンド実装

#### 4.4.1 ReviewList.tsx
**問題点分析:**
- ❌ ゼロ除算エラー（reviews.length === 0のとき）
- ❌ ローディング状態が未実装
- ❌ エラーハンドリングが未実装
- ❌ 画像にaltが無い（アクセシビリティ）
- ❌ 画像サイズ制御が無い

**実装:**
```typescript
// frontend/src/components/ReviewList.tsx
import React from 'react';
import { useReviews } from '../hooks/useReviews';
import ReviewItem from './ReviewItem';
import StarRating from './StarRating';

interface ReviewListProps {
  productId: string;
}

const ReviewList: React.FC<ReviewListProps> = ({ productId }) => {
  const { reviews, averageRating, totalCount, loading, error } = useReviews(productId);

  if (loading) {
    return <div className="review-list-loading">レビューを読み込み中...</div>;
  }

  if (error) {
    return <div className="review-list-error">レビューの読み込みに失敗しました: {error}</div>;
  }

  return (
    <div className="review-list">
      <div className="review-summary">
        <h2>カスタマーレビュー</h2>
        {totalCount > 0 ? (
          <div className="review-stats">
            <StarRating rating={averageRating} />
            <span className="average-rating">{averageRating.toFixed(1)}</span>
            <span className="total-count">（{totalCount}件のレビュー）</span>
          </div>
        ) : (
          <p>まだレビューがありません</p>
        )}
      </div>

      <div className="review-items">
        {reviews.map(review => (
          <ReviewItem key={review.id} review={review} />
        ))}
      </div>
    </div>
  );
};

export default ReviewList;
```

#### 4.4.2 ReviewItem.tsx
**実装:**
```typescript
// frontend/src/components/ReviewItem.tsx
import React from 'react';
import { Review } from '../types/review.types';
import StarRating from './StarRating';
import DOMPurify from 'dompurify';

interface ReviewItemProps {
  review: Review;
}

const ReviewItem: React.FC<ReviewItemProps> = ({ review }) => {
  // クライアント側でも追加のサニタイズ（多層防御）
  const sanitizedBody = DOMPurify.sanitize(review.body, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'u', 'p', 'br', 'ul', 'ol', 'li', 'a'],
    ALLOWED_ATTR: ['href', 'title']
  });

  return (
    <div className="review-item">
      <div className="review-header">
        <StarRating rating={review.rating} />
        <h3 className="review-title">{review.title}</h3>
        <span className="review-date">
          {new Date(review.createdAt).toLocaleDateString('ja-JP')}
        </span>
      </div>

      <div
        className="review-body"
        dangerouslySetInnerHTML={{ __html: sanitizedBody }}
      />

      {review.images.length > 0 && (
        <div className="review-images">
          {review.images.map((imageUrl, index) => (
            <img
              key={index}
              src={imageUrl}
              alt={`${review.title}の画像${index + 1}`}
              loading="lazy"
              style={{ maxWidth: '200px', maxHeight: '200px' }}
            />
          ))}
        </div>
      )}

      {review.flagged && (
        <div className="review-flagged-notice">
          このレビューは管理者により不適切とマークされています
        </div>
      )}
    </div>
  );
};

export default ReviewItem;
```

#### 4.4.3 ReviewForm.tsx
**実装:**
```typescript
// frontend/src/components/ReviewForm.tsx
import React, { useState } from 'react';
import { useReviewSubmit } from '../hooks/useReviewSubmit';
import ImageUploader from './ImageUploader';
import StarRating from './StarRating';

interface ReviewFormProps {
  productId: string;
  onSuccess?: () => void;
}

const ReviewForm: React.FC<ReviewFormProps> = ({ productId, onSuccess }) => {
  const [rating, setRating] = useState<number>(5);
  const [title, setTitle] = useState<string>('');
  const [body, setBody] = useState<string>('');
  const [images, setImages] = useState<string[]>([]);

  const { submitReview, submitting, error } = useReviewSubmit();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    const success = await submitReview({
      productId,
      rating,
      title,
      body,
      images
    });

    if (success) {
      // フォームリセット
      setRating(5);
      setTitle('');
      setBody('');
      setImages([]);
      onSuccess?.();
    }
  };

  return (
    <form className="review-form" onSubmit={handleSubmit}>
      <h3>レビューを投稿</h3>

      <div className="form-group">
        <label>評価 *</label>
        <StarRating rating={rating} interactive onRatingChange={setRating} />
      </div>

      <div className="form-group">
        <label htmlFor="title">タイトル *</label>
        <input
          id="title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          maxLength={200}
          required
        />
        <span className="char-count">{title.length}/200</span>
      </div>

      <div className="form-group">
        <label htmlFor="body">レビュー本文 *</label>
        <textarea
          id="body"
          value={body}
          onChange={(e) => setBody(e.target.value)}
          maxLength={10000}
          rows={10}
          required
        />
        <span className="char-count">{body.length}/10000</span>
      </div>

      <div className="form-group">
        <label>画像（最大3枚）</label>
        <ImageUploader images={images} onImagesChange={setImages} maxImages={3} />
      </div>

      {error && <div className="form-error">{error}</div>}

      <button type="submit" disabled={submitting}>
        {submitting ? '投稿中...' : 'レビューを投稿'}
      </button>
    </form>
  );
};

export default ReviewForm;
```

#### 4.4.4 StarRating.tsx
**実装:**
```typescript
// frontend/src/components/StarRating.tsx
import React from 'react';

interface StarRatingProps {
  rating: number;
  interactive?: boolean;
  onRatingChange?: (rating: number) => void;
}

const StarRating: React.FC<StarRatingProps> = ({ 
  rating, 
  interactive = false, 
  onRatingChange 
}) => {
  const stars = [1, 2, 3, 4, 5];

  const handleClick = (value: number) => {
    if (interactive && onRatingChange) {
      onRatingChange(value);
    }
  };

  return (
    <div className={`star-rating ${interactive ? 'interactive' : ''}`}>
      {stars.map(value => (
        <span
          key={value}
          className={`star ${value <= rating ? 'filled' : 'empty'}`}
          onClick={() => handleClick(value)}
          style={{ cursor: interactive ? 'pointer' : 'default' }}
        >
          ★
        </span>
      ))}
    </div>
  );
};

export default StarRating;
```

#### 4.4.5 ImageUploader.tsx
**実装:**
```typescript
// frontend/src/components/ImageUploader.tsx
import React, { useRef } from 'react';
import { resizeImage } from '../services/imageResizeService';

interface ImageUploaderProps {
  images: string[];
  onImagesChange: (images: string[]) => void;
  maxImages: number;
}

const ImageUploader: React.FC<ImageUploaderProps> = ({ 
  images, 
  onImagesChange, 
  maxImages 
}) => {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files) return;

    const remainingSlots = maxImages - images.length;
    const filesToProcess = Array.from(files).slice(0, remainingSlots);

    try {
      const resizedImages = await Promise.all(
        filesToProcess.map(file => resizeImage(file, 800, 800))
      );

      onImagesChange([...images, ...resizedImages]);
    } catch (error) {
      alert('画像のアップロードに失敗しました');
    }

    // inputをリセット
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleRemoveImage = (index: number) => {
    const newImages = images.filter((_, i) => i !== index);
    onImagesChange(newImages);
  };

  return (
    <div className="image-uploader">
      <div className="image-preview-list">
        {images.map((image, index) => (
          <div key={index} className="image-preview">
            <img src={image} alt={`プレビュー${index + 1}`} />
            <button
              type="button"
              onClick={() => handleRemoveImage(index)}
              className="remove-button"
            >
              ×
            </button>
          </div>
        ))}
      </div>

      {images.length < maxImages && (
        <div>
          <input
            ref={fileInputRef}
            type="file"
            accept="image/jpeg,image/png,image/webp"
            multiple
            onChange={handleFileSelect}
          />
          <p className="hint">
            残り{maxImages - images.length}枚まで追加できます（各5MB以下）
          </p>
        </div>
      )}
    </div>
  );
};

export default ImageUploader;
```

#### 4.4.6 Custom Hooks

**useReviews.ts:**
```typescript
// frontend/src/hooks/useReviews.ts
import { useState, useEffect } from 'react';
import { Review } from '../types/review.types';
import { fetchProductReviews } from '../services/reviewApiService';

export function useReviews(productId: string) {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [averageRating, setAverageRating] = useState<number>(0);
  const [totalCount, setTotalCount] = useState<number>(0);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;

    const loadReviews = async () => {
      setLoading(true);
      setError(null);

      try {
        const data = await fetchProductReviews(productId);
        
        if (isMounted) {
          setReviews(data.data);
          setAverageRating(data.averageRating);
          setTotalCount(data.totalCount);
        }
      } catch (err) {
        if (isMounted) {
          setError(err instanceof Error ? err.message : 'Unknown error');
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    loadReviews();

    return () => {
      isMounted = false;
    };
  }, [productId]);

  return { reviews, averageRating, totalCount, loading, error };
}
```

**useReviewSubmit.ts:**
```typescript
// frontend/src/hooks/useReviewSubmit.ts
import { useState } from 'react';
import { CreateReviewInput } from '../types/review.types';
import { submitReview as apiSubmitReview } from '../services/reviewApiService';

export function useReviewSubmit() {
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const submitReview = async (input: CreateReviewInput): Promise<boolean> => {
    setSubmitting(true);
    setError(null);

    try {
      await apiSubmitReview(input);
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'レビューの投稿に失敗しました');
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return { submitReview, submitting, error };
}
```

#### 4.4.7 Services

**reviewApiService.ts:**
```typescript
// frontend/src/services/reviewApiService.ts
import { Review, CreateReviewInput, ReviewListResponse } from '../types/review.types';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || '/api';

export async function fetchProductReviews(productId: string): Promise<ReviewListResponse> {
  const response = await fetch(`${API_BASE_URL}/products/${productId}/reviews`);
  
  if (!response.ok) {
    throw new Error(`Failed to fetch reviews: ${response.statusText}`);
  }

  return response.json();
}

export async function submitReview(input: CreateReviewInput): Promise<Review> {
  const response = await fetch(`${API_BASE_URL}/products/${input.productId}/reviews`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include', // 認証Cookie送信
    body: JSON.stringify({
      rating: input.rating,
      title: input.title,
      body: input.body,
      images: input.images
    })
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || 'レビューの投稿に失敗しました');
  }

  const data = await response.json();
  return data.data;
}
```

**imageResizeService.ts:**
```typescript
// frontend/src/services/imageResizeService.ts
export async function resizeImage(
  file: File,
  maxWidth: number,
  maxHeight: number
): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      const img = new Image();
      
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;

        // アスペクト比を保ちながらリサイズ
        if (width > maxWidth || height > maxHeight) {
          const ratio = Math.min(maxWidth / width, maxHeight / height);
          width = width * ratio;
          height = height * ratio;
        }

        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Canvas context not available'));
          return;
        }

        ctx.drawImage(img, 0, 0, width, height);

        // base64で返す（JPEG、品質80%）
        const base64 = canvas.toDataURL('image/jpeg', 0.8);
        resolve(base64);
      };

      img.onerror = () => reject(new Error('画像の読み込みに失敗しました'));
      img.src = e.target?.result as string;
    };

    reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
    reader.readAsDataURL(file);
  });
}
```

#### 4.4.8 Types
```typescript
// frontend/src/types/review.types.ts
export interface Review {
  id: string;
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
  flagged: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateReviewInput {
  productId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
}

export interface ReviewListResponse {
  data: Review[];
  averageRating: number;
  totalCount: number;
}
```

---

## 5. ユニットテスト戦略

### 5.1 テストツール
- **フレームワーク**: Jest
- **HTTPテスト**: supertest
- **モック**: jest.mock()

### 5.2 テストスコープ

#### 5.2.1 バックエンド単体テスト

**reviewService.test.ts:**
```typescript
// src/__tests__/reviewService.test.ts
import { ReviewService } from '../services/reviewService';
import { ReviewRepository } from '../repositories/reviewRepository';
import { ImageUploadService } from '../services/imageUploadService';

jest.mock('../repositories/reviewRepository');
jest.mock('../services/imageUploadService');
jest.mock('../utils/htmlSanitizer', () => ({
  sanitizeHtml: jest.fn(html => html.replace(/<script>/g, ''))
}));

describe('ReviewService', () => {
  let reviewService: ReviewService;
  let mockReviewRepository: jest.Mocked<ReviewRepository>;
  let mockImageUploadService: jest.Mocked<ImageUploadService>;

  beforeEach(() => {
    mockReviewRepository = new ReviewRepository(null as any) as jest.Mocked<ReviewRepository>;
    mockImageUploadService = new ImageUploadService() as jest.Mocked<ImageUploadService>;
    reviewService = new ReviewService(mockReviewRepository, mockImageUploadService);
  });

  describe('createReview', () => {
    it('should create a review successfully', async () => {
      mockReviewRepository.existsByUserAndProduct.mockResolvedValue(false);
      mockImageUploadService.uploadImages.mockResolvedValue(['https://s3.example.com/image1.jpg']);
      mockReviewRepository.create.mockResolvedValue({
        id: '123',
        productId: 'prod-1',
        userId: 'user-1',
        rating: 5,
        title: 'Great product',
        body: 'I love it',
        images: ['https://s3.example.com/image1.jpg'],
        flagged: false,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      const result = await reviewService.createReview({
        productId: 'prod-1',
        userId: 'user-1',
        rating: 5,
        title: 'Great product',
        body: 'I love it',
        images: ['base64...']
      });

      expect(result.id).toBe('123');
      expect(mockImageUploadService.uploadImages).toHaveBeenCalledWith(['base64...']);
    });

    it('should throw error if user already reviewed', async () => {
      mockReviewRepository.existsByUserAndProduct.mockResolvedValue(true);

      await expect(reviewService.createReview({
        productId: 'prod-1',
        userId: 'user-1',
        rating: 5,
        title: 'Test',
        body: 'Test',
        images: []
      })).rejects.toThrow('You have already reviewed this product');
    });
  });

  describe('findByProductId', () => {
    it('should return reviews with correct average', async () => {
      const mockReviews = [
        { rating: 5 } as any,
        { rating: 4 } as any,
        { rating: 3 } as any
      ];
      mockReviewRepository.findByProductId.mockResolvedValue(mockReviews);

      const result = await reviewService.findByProductId('prod-1');

      expect(result.data).toEqual(mockReviews);
      expect(result.averageRating).toBe(4.0);
      expect(result.totalCount).toBe(3);
    });

    it('should return 0 average for empty reviews', async () => {
      mockReviewRepository.findByProductId.mockResolvedValue([]);

      const result = await reviewService.findByProductId('prod-1');

      expect(result.averageRating).toBe(0);
      expect(result.totalCount).toBe(0);
    });
  });
});
```

**htmlSanitizer.test.ts:**
```typescript
// src/__tests__/htmlSanitizer.test.ts
import { sanitizeHtml } from '../utils/htmlSanitizer';

describe('sanitizeHtml', () => {
  it('should allow safe HTML tags', () => {
    const input = '<p>Hello <strong>world</strong></p>';
    const result = sanitizeHtml(input);
    expect(result).toBe('<p>Hello <strong>world</strong></p>');
  });

  it('should remove script tags', () => {
    const input = '<p>Hello</p><script>alert("XSS")</script>';
    const result = sanitizeHtml(input);
    expect(result).not.toContain('<script>');
  });

  it('should remove onclick attributes', () => {
    const input = '<p onclick="alert(1)">Click me</p>';
    const result = sanitizeHtml(input);
    expect(result).not.toContain('onclick');
  });

  it('should allow safe links', () => {
    const input = '<a href="https://example.com">Link</a>';
    const result = sanitizeHtml(input);
    expect(result).toContain('href="https://example.com"');
  });

  it('should remove javascript: protocol links', () => {
    const input = '<a href="javascript:alert(1)">Bad Link</a>';
    const result = sanitizeHtml(input);
    expect(result).not.toContain('javascript:');
  });
});
```

**imageUploadService.test.ts:**
```typescript
// src/__tests__/imageUploadService.test.ts
import { ImageUploadService } from '../services/imageUploadService';

jest.mock('@aws-sdk/client-s3', () => ({
  S3Client: jest.fn().mockImplementation(() => ({
    send: jest.fn().mockResolvedValue({})
  })),
  PutObjectCommand: jest.fn()
}));

describe('ImageUploadService', () => {
  let service: ImageUploadService;

  beforeEach(() => {
    service = new ImageUploadService();
  });

  it('should reject more than 3 images', async () => {
    const images = ['data:image/jpeg;base64,abc', 'data:image/jpeg;base64,def', 
                    'data:image/jpeg;base64,ghi', 'data:image/jpeg;base64,jkl'];
    
    await expect(service.uploadImages(images)).rejects.toThrow('Maximum 3 images allowed');
  });

  it('should reject invalid base64 format', async () => {
    const images = ['invalid-base64-string'];
    
    await expect(service.uploadImages(images)).rejects.toThrow('Invalid base64 image format');
  });

  it('should reject unsupported MIME types', async () => {
    const images = ['data:image/gif;base64,abc123'];
    
    await expect(service.uploadImages(images)).rejects.toThrow('Invalid image type');
  });
});
```

#### 5.2.2 バックエンド統合テスト

**review.test.ts:**
```typescript
// src/__tests__/review.test.ts
import request from 'supertest';
import { app } from '../app';

describe('Review API Integration Tests', () => {
  describe('POST /api/products/:productId/reviews', () => {
    it('should create a review successfully', async () => {
      const response = await request(app)
        .post('/api/products/prod-1/reviews')
        .set('Authorization', 'Bearer valid-token')
        .send({
          rating: 5,
          title: 'Excellent product',
          body: '<p>This is a great product!</p>',
          images: ['data:image/jpeg;base64,/9j/4AAQSkZJRg...']
        });

      expect(response.status).toBe(201);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.rating).toBe(5);
    });

    it('should return 400 for invalid rating', async () => {
      const response = await request(app)
        .post('/api/products/prod-1/reviews')
        .set('Authorization', 'Bearer valid-token')
        .send({
          rating: 6,
          title: 'Test',
          body: 'Test body',
          images: []
        });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('Rating must be');
    });

    it('should return 401 without authentication', async () => {
      const response = await request(app)
        .post('/api/products/prod-1/reviews')
        .send({
          rating: 5,
          title: 'Test',
          body: 'Test',
          images: []
        });

      expect(response.status).toBe(401);
    });
  });

  describe('GET /api/products/:productId/reviews', () => {
    it('should return reviews list', async () => {
      const response = await request(app)
        .get('/api/products/prod-1/reviews');

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('data');
      expect(response.body).toHaveProperty('averageRating');
      expect(response.body).toHaveProperty('totalCount');
    });
  });
});
```

#### 5.2.3 フロントエンドテスト方針
- **コンポーネント**: React Testing Library
- **カスタムフック**: @testing-library/react-hooks
- **API通信モック**: MSW (Mock Service Worker)

---

## 6. 実装順序

### フェーズ1: 基盤整備（1-2日）
1. **環境設定**
   - package.json に依存関係追加
     ```json
     {
       "dependencies": {
         "@aws-sdk/client-s3": "^3.515.0",
         "sanitize-html": "^2.11.0",
         "uuid": "^9.0.1"
       },
       "devDependencies": {
         "@types/sanitize-html": "^2.9.5",
         "@types/uuid": "^9.0.7"
       }
     }
     ```
   - フロントエンド: `dompurify` インストール
   - 環境変数設定（`.env`）
     ```
     AWS_REGION=us-east-1
     AWS_ACCESS_KEY_ID=your-key
     AWS_SECRET_ACCESS_KEY=your-secret
     S3_BUCKET_NAME=shopnow-review-images
     ```

2. **DBマイグレーション実行**
   - `migrations/001_create_reviews_table.sql` 実行
   - インデックス作成確認

### フェーズ2: バックエンドコア実装（3-4日）
1. **モデル・型定義** (`Review.ts`, `ReviewReport.ts`, `review.types.ts`)
2. **ユーティリティ** (`htmlSanitizer.ts`, `averageCalculator.ts`)
3. **Repository層** (`reviewRepository.ts`)
4. **Service層**
   - `imageUploadService.ts`（S3アップロード）
   - `reviewService.ts`（ビジネスロジック）
5. **Middleware** (`reviewValidation.ts`)
6. **Controller層** (`reviewController.ts`)
7. **Routes** (`reviewRoutes.ts`, `routes/index.ts` 修正)

### フェーズ3: バックエンドテスト（2日）
1. **単体テスト作成・実行**
   - `htmlSanitizer.test.ts`
   - `imageUploadService.test.ts`
   - `reviewService.test.ts`
2. **統合テスト作成・実行** (`review.test.ts`)
3. **カバレッジ確認** (最低80%を目標)

### フェーズ4: フロントエンド実装（3-4日）
1. **型定義** (`frontend/src/types/review.types.ts`)
2. **Services**
   - `imageResizeService.ts`
   - `reviewApiService.ts`
3. **Components**
   - `StarRating.tsx`
   - `ImageUploader.tsx`
   - `ReviewItem.tsx`
   - `ReviewList.tsx`
   - `ReviewForm.tsx`
4. **Custom Hooks**
   - `useReviews.ts`
   - `useReviewSubmit.ts`

### フェーズ5: 統合・E2Eテスト（2日）
1. **フロントエンド単体テスト**
2. **E2Eテスト** (Cypress/Playwright)
   - レビュー投稿フロー
   - レビュー一覧表示
   - 画像アップロード
3. **手動テスト**
   - XSS対策確認
   - 画像サイズ制限確認
   - エラーハンドリング確認

### フェーズ6: リファクタリング・最適化（1日）
1. **コードレビュー対応**
2. **パフォーマンスチューニング**
   - SQLクエリ最適化確認
   - 画像サイズ最適化
3. **ドキュメント更新**

### フェーズ7: デプロイ準備（1日）
1. **本番環境設定**
   - S3バケット作成・権限設定
   - 環境変数設定
2. **マイグレーション実行**
3. **スモークテスト**

**合計見積: 12-15営業日**

---

## 付録: 主要な設計判断の根拠

### A1. HTMLサニタイズを二重実装する理由
- **バックエンド**: データベース汚染防止、多層防御の第一層
- **フロントエンド**: XSS攻撃への最後の防御線（DOMPurify）
- **根拠**: OWASP推奨のDefense in Depthプラクティス

### A2. 平均評価をServiceで計算する理由
- **問題**: 提案ではController、Frontend両方で計算 → DRY原則違反
- **解決**: Serviceで一元計算し、APIレスポンスに含める
- **メリット**: ロジックの一貫性、テスト容易性

### A3. Repository層でSQL直接実行する理由
- **代替案**: ORMの使用
- **判断**: 既存コードベースがRaw SQLパターンを採用
- **一貫性**: 既存の `ProductRepository` 等と同じパターンを踏襲

### A4. 画像をbase64でアップロードする理由
- **代替案**: multipart/form-data
- **判断**: フロントエンドでリサイズ済みデータを送信する要件に適合
- **制約**: サーバー側で追加のリサイズ処理が不要（要件より）

### A5. ユーザーごとに1レビューのみ許可する理由
- **根拠**: 一般的なECサイトのベストプラクティス
- **実装**: UNIQUE INDEX制約により強制
- **UX**: 既存レビューの編集機能は今回スコープ外（将来拡張）

---

**この開発計画に従うことで、セキュリティ、パフォーマンス、保守性を確保しつつ、既存コードベースとの一貫性を保った実装が可能です。**
