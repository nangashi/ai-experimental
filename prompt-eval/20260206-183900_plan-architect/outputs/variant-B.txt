# 商品レビュー機能追加 - 詳細開発計画書

## 1. 概要

### 1.1 目的
ECサイト「ShopNow」に商品レビュー機能を追加し、ユーザーが購入した商品に対する評価・コメントを投稿・閲覧できるようにする。

### 1.2 スコープ
- **対象機能**:
  - ユーザーによるレビュー投稿（星評価、タイトル、本文、画像）
  - 商品詳細ページでのレビュー一覧表示
  - 平均評価の計算・表示
  - 管理者によるレビュー削除・フラグ付与
- **対象外**:
  - レビューへの返信機能
  - レビューの編集機能
  - レビューの並び替え・フィルタリング
  - 購入履歴との連携（購入者のみ投稿可能にする制限）

### 1.3 前提条件
- Node.js 16以上、PostgreSQL 13以上が利用可能
- 既存のユーザー認証機構（JWT/Session）が稼働中
- S3互換ストレージへのアクセス権限が設定済み
- フロントエンドのビルド環境（React + TypeScript）が構築済み

### 1.4 制約事項
- **セキュリティリスク**: HTMLリッチテキストをそのまま表示する要件があるため、XSS攻撃のリスクが高い
- **パフォーマンス懸念**: 平均評価をリクエストごとに全レビューから計算する設計は、レビュー数が増加すると性能劣化を引き起こす
- **データ整合性**: 画像URLの配列をTEXT[]型で保存する設計は、URLの検証・管理が困難

---

## 2. ディレクトリ/ファイル設計

### 2.1 新規作成ファイル一覧

#### バックエンド
```
src/
├── controllers/
│   └── reviewController.ts          # レビューCRUD操作のコントローラー
├── services/
│   ├── reviewService.ts             # レビュービジネスロジック
│   └── imageUploadService.ts        # S3画像アップロード処理
├── repositories/
│   └── reviewRepository.ts          # レビューDB操作
├── models/
│   └── Review.ts                    # レビューエンティティ
├── middleware/
│   ├── reviewValidator.ts           # レビュー入力検証
│   └── adminAuth.ts                 # 管理者権限チェック
├── utils/
│   ├── htmlSanitizer.ts             # HTMLサニタイズ処理
│   └── s3Client.ts                  # S3接続クライアント
└── __tests__/
    ├── review.test.ts               # レビューAPI統合テスト
    ├── reviewService.test.ts        # レビューサービスユニットテスト
    └── htmlSanitizer.test.ts        # サニタイズ関数テスト
```

#### フロントエンド
```
client/src/
├── components/
│   ├── ReviewList.tsx               # レビュー一覧コンポーネント
│   ├── ReviewForm.tsx               # レビュー投稿フォーム
│   ├── ReviewItem.tsx               # レビュー個別表示
│   ├── StarRating.tsx               # 星評価表示/入力
│   └── ImageUploader.tsx            # 画像アップロード
├── hooks/
│   ├── useReviews.ts                # レビュー取得カスタムフック
│   └── useImageUpload.ts            # 画像アップロードフック
├── services/
│   └── reviewApi.ts                 # レビューAPI呼び出し
├── types/
│   └── review.ts                    # レビュー型定義
└── __tests__/
    ├── ReviewList.test.tsx
    ├── ReviewForm.test.tsx
    └── reviewApi.test.ts
```

#### データベース
```
migrations/
└── 001_create_reviews_table.sql     # レビューテーブル作成マイグレーション
```

### 2.2 修正対象ファイル

```
src/routes/index.ts                  # レビューエンドポイント追加
src/app.ts                           # 必要に応じてミドルウェア追加
client/src/pages/ProductDetail.tsx   # レビューコンポーネント組み込み（想定）
```

---

## 3. アーキテクチャ設計

### 3.1 全体構成

```
┌─────────────┐
│  Frontend   │
│ (React/TS)  │
└──────┬──────┘
       │ HTTPS/REST API
       ↓
┌──────────────────────────────────────┐
│         Backend (Express)            │
│  ┌────────────┐  ┌────────────────┐ │
│  │ Controller │→ │    Service     │ │
│  └────────────┘  └────┬───────────┘ │
│                       │              │
│  ┌────────────────────┼────────┐    │
│  │  Repository        ↓        │    │
│  │  ┌─────────────────────┐   │    │
│  │  │  PostgreSQL         │   │    │
│  │  │  ┌──────────────┐   │   │    │
│  │  │  │ reviews table│   │   │    │
│  │  │  └──────────────┘   │   │    │
│  │  └─────────────────────┘   │    │
│  └─────────────────────────────┘    │
│         ↓                            │
│  ┌────────────────┐                 │
│  │ S3 Compatible  │                 │
│  │    Storage     │                 │
│  └────────────────┘                 │
└──────────────────────────────────────┘
```

### 3.2 データモデル

#### 3.2.1 Review Entity（修正版）

**問題点**: 提供された設計案では、Reviewモデルに複数の責務（データ保持、平均計算、通知送信、レポート生成）が混在している。

**改善版**:
```typescript
// models/Review.ts
export class Review {
  id: string;
  productId: string;
  userId: string;
  rating: number;           // 1-5
  title: string;            // 最大200文字
  body: string;             // HTMLリッチテキスト（サニタイズ済み）
  images: string[];         // S3 URL配列（最大3件）
  flagged: boolean;         // 不適切フラグ
  createdAt: Date;
  updatedAt: Date;

  // バリデーションのみモデルに持たせる
  validate(): void {
    if (this.rating < 1 || this.rating > 5) {
      throw new ValidationError('Rating must be between 1 and 5');
    }
    if (!this.title || this.title.length > 200) {
      throw new ValidationError('Title must be 1-200 characters');
    }
    if (!this.body || this.body.length > 10000) {
      throw new ValidationError('Body must be 1-10000 characters');
    }
    if (this.images.length > 3) {
      throw new ValidationError('Maximum 3 images allowed');
    }
  }
}

// 平均計算はServiceレイヤーに移動
// 通知送信は専用のNotificationServiceに分離
// レポート生成は専用のReportServiceに分離
```

#### 3.2.2 DBスキーマ（最終版）

```sql
-- migrations/001_create_reviews_table.sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  images TEXT[] DEFAULT '{}',  -- S3 URL配列
  flagged BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- パフォーマンス最適化用インデックス
  CONSTRAINT unique_user_product_review UNIQUE (user_id, product_id)  -- 1商品1ユーザー1レビュー制限
);

CREATE INDEX idx_reviews_product_id ON reviews(product_id);
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
CREATE INDEX idx_reviews_flagged ON reviews(flagged) WHERE flagged = true;

-- 平均評価キャッシュテーブル（パフォーマンス改善）
CREATE TABLE product_review_stats (
  product_id UUID PRIMARY KEY REFERENCES products(id) ON DELETE CASCADE,
  average_rating NUMERIC(3,2),  -- 例: 4.35
  review_count INTEGER DEFAULT 0,
  updated_at TIMESTAMP DEFAULT NOW()
);

-- レビュー追加/更新/削除時に統計を更新するトリガー
CREATE OR REPLACE FUNCTION update_review_stats()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    UPDATE product_review_stats
    SET average_rating = (SELECT AVG(rating) FROM reviews WHERE product_id = OLD.product_id),
        review_count = (SELECT COUNT(*) FROM reviews WHERE product_id = OLD.product_id),
        updated_at = NOW()
    WHERE product_id = OLD.product_id;
    RETURN OLD;
  ELSE
    INSERT INTO product_review_stats (product_id, average_rating, review_count)
    VALUES (
      NEW.product_id,
      (SELECT AVG(rating) FROM reviews WHERE product_id = NEW.product_id),
      (SELECT COUNT(*) FROM reviews WHERE product_id = NEW.product_id)
    )
    ON CONFLICT (product_id) DO UPDATE
    SET average_rating = (SELECT AVG(rating) FROM reviews WHERE product_id = NEW.product_id),
        review_count = (SELECT COUNT(*) FROM reviews WHERE product_id = NEW.product_id),
        updated_at = NOW();
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_review_stats
AFTER INSERT OR UPDATE OR DELETE ON reviews
FOR EACH ROW EXECUTE FUNCTION update_review_stats();
```

### 3.3 API設計

#### 3.3.1 エンドポイント一覧

| メソッド | パス | 説明 | 認証 |
|---------|------|------|------|
| POST | /api/products/:productId/reviews | レビュー投稿 | 必須 |
| GET | /api/products/:productId/reviews | レビュー一覧取得 | 不要 |
| GET | /api/products/:productId/reviews/stats | 平均評価・件数取得 | 不要 |
| DELETE | /api/reviews/:reviewId | レビュー削除 | 管理者 |
| PATCH | /api/reviews/:reviewId/flag | レビューフラグ付与 | 管理者 |
| POST | /api/reviews/upload-image | 画像アップロード | 必須 |

#### 3.3.2 リクエスト/レスポンス仕様

**POST /api/products/:productId/reviews**
```typescript
// Request
{
  rating: number;        // 1-5
  title: string;         // 1-200文字
  body: string;          // HTMLリッチテキスト
  images: string[];      // S3 URL配列（最大3件、事前に/upload-imageで取得）
}

// Response (201)
{
  data: {
    id: string;
    productId: string;
    userId: string;
    rating: number;
    title: string;
    body: string;         // サニタイズ済みHTML
    images: string[];
    flagged: boolean;
    createdAt: string;
    updatedAt: string;
    user: {               // JOINで取得
      id: string;
      name: string;
      avatar?: string;
    }
  }
}
```

**GET /api/products/:productId/reviews**
```typescript
// Query Parameters
{
  limit?: number;        // デフォルト50、最大100
  offset?: number;       // デフォルト0
}

// Response (200)
{
  data: Review[];        // 上記と同じ構造
  pagination: {
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
  }
}
```

**GET /api/products/:productId/reviews/stats**
```typescript
// Response (200)
{
  data: {
    averageRating: number;   // 例: 4.35
    reviewCount: number;
    ratingDistribution: {    // 星ごとの分布
      5: number;
      4: number;
      3: number;
      2: number;
      1: number;
    }
  }
}
```

**POST /api/reviews/upload-image**
```typescript
// Request (multipart/form-data)
{
  image: File;  // JPEG/PNG、最大5MB
}

// Response (200)
{
  data: {
    url: string;  // S3 URL
  }
}
```

### 3.4 エラーハンドリング

#### 3.4.1 カスタムエラークラス（既存パターンを踏襲）

```typescript
// 既存のエラークラスに追加
export class ImageUploadError extends Error {
  statusCode = 400;
  constructor(message: string) {
    super(message);
    this.name = 'ImageUploadError';
  }
}

export class DuplicateReviewError extends Error {
  statusCode = 409;
  constructor(message: string = 'Review already exists for this product') {
    super(message);
    this.name = 'DuplicateReviewError';
  }
}
```

#### 3.4.2 エラーレスポンス形式

```typescript
// エラーレスポンス（既存のerrorHandlerミドルウェアが処理）
{
  error: {
    message: string;
    code: string;      // 'VALIDATION_ERROR', 'NOT_FOUND', etc.
    details?: any;     // バリデーションエラー詳細など
  }
}
```

### 3.5 セキュリティ対策

#### 3.5.1 XSS対策（重要）

**問題**: 要件では「HTMLリッチテキストをそのまま表示」とあるが、これは重大なXSS脆弱性を生む。

**対策**:
```typescript
// utils/htmlSanitizer.ts
import DOMPurify from 'isomorphic-dompurify';

export class HtmlSanitizer {
  private static readonly ALLOWED_TAGS = [
    'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 
    'ul', 'ol', 'li', 'a', 'blockquote'
  ];
  
  private static readonly ALLOWED_ATTR = {
    'a': ['href', 'target', 'rel']
  };

  static sanitize(html: string): string {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: this.ALLOWED_TAGS,
      ALLOWED_ATTR: this.ALLOWED_ATTR,
      ALLOW_DATA_ATTR: false,
      ALLOW_UNKNOWN_PROTOCOLS: false,
    });
  }
}

// 使用例（Service層で適用）
const sanitizedBody = HtmlSanitizer.sanitize(reviewData.body);
```

#### 3.5.2 認証・認可

```typescript
// middleware/adminAuth.ts
export const requireAdmin = (req: Request, res: Response, next: NextFunction) => {
  if (!req.user || req.user.role !== 'admin') {
    throw new ForbiddenError('Admin access required');
  }
  next();
};
```

#### 3.5.3 画像アップロード制限

```typescript
// imageUploadService.ts
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

export class ImageUploadService {
  validateImage(file: Express.Multer.File): void {
    if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new ImageUploadError('Only JPEG, PNG, and WebP images are allowed');
    }
    if (file.size > MAX_FILE_SIZE) {
      throw new ImageUploadError('Image size must not exceed 5MB');
    }
  }
}
```

---

## 4. 実装詳細仕様

### 4.1 バックエンド実装

#### 4.1.1 ReviewRepository（データアクセス層）

```typescript
// repositories/reviewRepository.ts
import { Pool } from 'pg';
import { Review } from '../models/Review';

export class ReviewRepository {
  constructor(private db: Pool) {}

  async create(review: Omit<Review, 'id' | 'createdAt' | 'updatedAt'>): Promise<Review> {
    const result = await this.db.query(
      `INSERT INTO reviews (product_id, user_id, rating, title, body, images)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [review.productId, review.userId, review.rating, review.title, review.body, review.images]
    );
    return this.mapToReview(result.rows[0]);
  }

  async findByProductId(
    productId: string, 
    limit: number = 50, 
    offset: number = 0
  ): Promise<{ reviews: Review[]; total: number }> {
    const [reviewsResult, countResult] = await Promise.all([
      this.db.query(
        `SELECT r.*, u.id as user_id, u.name as user_name, u.avatar as user_avatar
         FROM reviews r
         JOIN users u ON r.user_id = u.id
         WHERE r.product_id = $1
         ORDER BY r.created_at DESC
         LIMIT $2 OFFSET $3`,
        [productId, limit, offset]
      ),
      this.db.query(
        'SELECT COUNT(*) FROM reviews WHERE product_id = $1',
        [productId]
      )
    ]);

    return {
      reviews: reviewsResult.rows.map(row => this.mapToReviewWithUser(row)),
      total: parseInt(countResult.rows[0].count)
    };
  }

  async getStats(productId: string): Promise<{
    averageRating: number;
    reviewCount: number;
    ratingDistribution: Record<number, number>;
  }> {
    const statsResult = await this.db.query(
      `SELECT average_rating, review_count FROM product_review_stats WHERE product_id = $1`,
      [productId]
    );

    const distributionResult = await this.db.query(
      `SELECT rating, COUNT(*) as count
       FROM reviews
       WHERE product_id = $1
       GROUP BY rating
       ORDER BY rating DESC`,
      [productId]
    );

    const distribution = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    distributionResult.rows.forEach(row => {
      distribution[row.rating] = parseInt(row.count);
    });

    return {
      averageRating: statsResult.rows[0]?.average_rating || 0,
      reviewCount: statsResult.rows[0]?.review_count || 0,
      ratingDistribution: distribution
    };
  }

  async findById(reviewId: string): Promise<Review | null> {
    const result = await this.db.query(
      'SELECT * FROM reviews WHERE id = $1',
      [reviewId]
    );
    return result.rows[0] ? this.mapToReview(result.rows[0]) : null;
  }

  async delete(reviewId: string): Promise<void> {
    await this.db.query('DELETE FROM reviews WHERE id = $1', [reviewId]);
  }

  async updateFlag(reviewId: string, flagged: boolean): Promise<Review> {
    const result = await this.db.query(
      'UPDATE reviews SET flagged = $1, updated_at = NOW() WHERE id = $2 RETURNING *',
      [flagged, reviewId]
    );
    return this.mapToReview(result.rows[0]);
  }

  async checkDuplicateReview(userId: string, productId: string): Promise<boolean> {
    const result = await this.db.query(
      'SELECT 1 FROM reviews WHERE user_id = $1 AND product_id = $2',
      [userId, productId]
    );
    return result.rows.length > 0;
  }

  private mapToReview(row: any): Review {
    return {
      id: row.id,
      productId: row.product_id,
      userId: row.user_id,
      rating: row.rating,
      title: row.title,
      body: row.body,
      images: row.images || [],
      flagged: row.flagged,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }

  private mapToReviewWithUser(row: any): Review & { user: any } {
    return {
      ...this.mapToReview(row),
      user: {
        id: row.user_id,
        name: row.user_name,
        avatar: row.user_avatar
      }
    };
  }
}
```

#### 4.1.2 ReviewService（ビジネスロジック層）

```typescript
// services/reviewService.ts
import { ReviewRepository } from '../repositories/reviewRepository';
import { HtmlSanitizer } from '../utils/htmlSanitizer';
import { ValidationError, DuplicateReviewError, NotFoundError } from '../errors';
import { Review } from '../models/Review';

export interface CreateReviewDto {
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
}

export class ReviewService {
  constructor(private reviewRepository: ReviewRepository) {}

  async createReview(dto: CreateReviewDto): Promise<Review> {
    // 重複チェック
    const isDuplicate = await this.reviewRepository.checkDuplicateReview(
      dto.userId,
      dto.productId
    );
    if (isDuplicate) {
      throw new DuplicateReviewError();
    }

    // バリデーション
    this.validateReviewData(dto);

    // HTMLサニタイズ
    const sanitizedBody = HtmlSanitizer.sanitize(dto.body);

    // 保存
    const review = await this.reviewRepository.create({
      ...dto,
      body: sanitizedBody,
      flagged: false
    });

    return review;
  }

  async getProductReviews(
    productId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<{ reviews: Review[]; pagination: any }> {
    if (limit > 100) limit = 100;
    if (limit < 1) limit = 50;
    if (offset < 0) offset = 0;

    const { reviews, total } = await this.reviewRepository.findByProductId(
      productId,
      limit,
      offset
    );

    return {
      reviews,
      pagination: {
        total,
        limit,
        offset,
        hasMore: offset + limit < total
      }
    };
  }

  async getReviewStats(productId: string) {
    return this.reviewRepository.getStats(productId);
  }

  async deleteReview(reviewId: string): Promise<void> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }
    await this.reviewRepository.delete(reviewId);
  }

  async flagReview(reviewId: string, flagged: boolean): Promise<Review> {
    const review = await this.reviewRepository.findById(reviewId);
    if (!review) {
      throw new NotFoundError('Review not found');
    }
    return this.reviewRepository.updateFlag(reviewId, flagged);
  }

  private validateReviewData(dto: CreateReviewDto): void {
    if (dto.rating < 1 || dto.rating > 5) {
      throw new ValidationError('Rating must be between 1 and 5');
    }
    if (!dto.title || dto.title.trim().length === 0) {
      throw new ValidationError('Title is required');
    }
    if (dto.title.length > 200) {
      throw new ValidationError('Title must not exceed 200 characters');
    }
    if (!dto.body || dto.body.trim().length === 0) {
      throw new ValidationError('Body is required');
    }
    if (dto.body.length > 10000) {
      throw new ValidationError('Body must not exceed 10000 characters');
    }
    if (dto.images.length > 3) {
      throw new ValidationError('Maximum 3 images allowed');
    }
    // 画像URLの形式検証
    dto.images.forEach(url => {
      if (!this.isValidImageUrl(url)) {
        throw new ValidationError(`Invalid image URL: ${url}`);
      }
    });
  }

  private isValidImageUrl(url: string): boolean {
    try {
      const parsed = new URL(url);
      return parsed.protocol === 'https:' && /\.(jpg|jpeg|png|webp)$/i.test(parsed.pathname);
    } catch {
      return false;
    }
  }
}
```

#### 4.1.3 ImageUploadService（画像アップロード）

```typescript
// services/imageUploadService.ts
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { v4 as uuidv4 } from 'uuid';
import sharp from 'sharp';
import { ImageUploadError } from '../errors';

export class ImageUploadService {
  private s3Client: S3Client;
  private bucketName: string;

  constructor() {
    this.s3Client = new S3Client({
      region: process.env.S3_REGION || 'us-east-1',
      endpoint: process.env.S3_ENDPOINT,
      credentials: {
        accessKeyId: process.env.S3_ACCESS_KEY!,
        secretAccessKey: process.env.S3_SECRET_KEY!
      }
    });
    this.bucketName = process.env.S3_BUCKET_NAME!;
  }

  async uploadImage(file: Express.Multer.File): Promise<string> {
    // バリデーション
    this.validateImage(file);

    // 画像処理（最大幅1200px、JPEG品質80%に最適化）
    const processedImage = await sharp(file.buffer)
      .resize(1200, 1200, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    // S3アップロード
    const key = `reviews/${uuidv4()}.jpg`;
    await this.s3Client.send(new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      Body: processedImage,
      ContentType: 'image/jpeg',
      CacheControl: 'public, max-age=31536000'
    }));

    // URLを返す
    return `https://${this.bucketName}.s3.amazonaws.com/${key}`;
  }

  private validateImage(file: Express.Multer.File): void {
    const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
    const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

    if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new ImageUploadError('Only JPEG, PNG, and WebP images are allowed');
    }
    if (file.size > MAX_FILE_SIZE) {
      throw new ImageUploadError('Image size must not exceed 5MB');
    }
  }
}
```

#### 4.1.4 ReviewController（コントローラー層）

```typescript
// controllers/reviewController.ts
import { Request, Response, NextFunction } from 'express';
import { ReviewService } from '../services/reviewService';
import { ImageUploadService } from '../services/imageUploadService';

export class ReviewController {
  constructor(
    private reviewService: ReviewService,
    private imageUploadService: ImageUploadService
  ) {}

  async createReview(req: Request, res: Response, next: NextFunction) {
    try {
      const { rating, title, body, images } = req.body;
      const review = await this.reviewService.createReview({
        productId: req.params.productId,
        userId: req.user!.id,  // authミドルウェアで設定済み
        rating,
        title,
        body,
        images: images || []
      });
      res.status(201).json({ data: review });
    } catch (error) {
      next(error);
    }
  }

  async getProductReviews(req: Request, res: Response, next: NextFunction) {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      
      const result = await this.reviewService.getProductReviews(
        req.params.productId,
        limit,
        offset
      );
      
      res.json(result);
    } catch (error) {
      next(error);
    }
  }

  async getReviewStats(req: Request, res: Response, next: NextFunction) {
    try {
      const stats = await this.reviewService.getReviewStats(req.params.productId);
      res.json({ data: stats });
    } catch (error) {
      next(error);
    }
  }

  async deleteReview(req: Request, res: Response, next: NextFunction) {
    try {
      await this.reviewService.deleteReview(req.params.reviewId);
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }

  async flagReview(req: Request, res: Response, next: NextFunction) {
    try {
      const { flagged } = req.body;
      const review = await this.reviewService.flagReview(
        req.params.reviewId,
        flagged
      );
      res.json({ data: review });
    } catch (error) {
      next(error);
    }
  }

  async uploadImage(req: Request, res: Response, next: NextFunction) {
    try {
      if (!req.file) {
        return res.status(400).json({ error: { message: 'No image file provided' } });
      }
      const url = await this.imageUploadService.uploadImage(req.file);
      res.json({ data: { url } });
    } catch (error) {
      next(error);
    }
  }
}
```

#### 4.1.5 ルーティング設定

```typescript
// routes/index.ts（既存ファイルに追加）
import { Router } from 'express';
import multer from 'multer';
import { ReviewController } from '../controllers/reviewController';
import { ReviewService } from '../services/reviewService';
import { ReviewRepository } from '../repositories/reviewRepository';
import { ImageUploadService } from '../services/imageUploadService';
import { auth } from '../middleware/auth';
import { requireAdmin } from '../middleware/adminAuth';

// 依存性注入
const reviewRepository = new ReviewRepository(db); // dbはグローバルなPoolインスタンス
const reviewService = new ReviewService(reviewRepository);
const imageUploadService = new ImageUploadService();
const reviewController = new ReviewController(reviewService, imageUploadService);

// Multer設定（メモリストレージ）
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 5 * 1024 * 1024 }
});

const router = Router();

// レビュー関連エンドポイント
router.post(
  '/products/:productId/reviews',
  auth,  // 認証必須
  reviewController.createReview.bind(reviewController)
);

router.get(
  '/products/:productId/reviews',
  reviewController.getProductReviews.bind(reviewController)
);

router.get(
  '/products/:productId/reviews/stats',
  reviewController.getReviewStats.bind(reviewController)
);

router.delete(
  '/reviews/:reviewId',
  auth,
  requireAdmin,  // 管理者のみ
  reviewController.deleteReview.bind(reviewController)
);

router.patch(
  '/reviews/:reviewId/flag',
  auth,
  requireAdmin,
  reviewController.flagReview.bind(reviewController)
);

router.post(
  '/reviews/upload-image',
  auth,
  upload.single('image'),
  reviewController.uploadImage.bind(reviewController)
);

export default router;
```

### 4.2 フロントエンド実装

#### 4.2.1 型定義

```typescript
// types/review.ts
export interface Review {
  id: string;
  productId: string;
  userId: string;
  rating: number;
  title: string;
  body: string;
  images: string[];
  flagged: boolean;
  createdAt: string;
  updatedAt: string;
  user: {
    id: string;
    name: string;
    avatar?: string;
  };
}

export interface ReviewStats {
  averageRating: number;
  reviewCount: number;
  ratingDistribution: {
    5: number;
    4: number;
    3: number;
    2: number;
    1: number;
  };
}

export interface CreateReviewRequest {
  rating: number;
  title: string;
  body: string;
  images: string[];
}
```

#### 4.2.2 API Service

```typescript
// services/reviewApi.ts
import { Review, ReviewStats, CreateReviewRequest } from '../types/review';

const API_BASE = '/api';

export class ReviewApi {
  static async createReview(
    productId: string,
    data: CreateReviewRequest
  ): Promise<Review> {
    const response = await fetch(`${API_BASE}/products/${productId}/reviews`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include', // Cookie送信
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || 'Failed to create review');
    }

    const result = await response.json();
    return result.data;
  }

  static async getProductReviews(
    productId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<{ reviews: Review[]; pagination: any }> {
    const response = await fetch(
      `${API_BASE}/products/${productId}/reviews?limit=${limit}&offset=${offset}`
    );

    if (!response.ok) {
      throw new Error('Failed to fetch reviews');
    }

    return response.json();
  }

  static async getReviewStats(productId: string): Promise<ReviewStats> {
    const response = await fetch(`${API_BASE}/products/${productId}/reviews/stats`);

    if (!response.ok) {
      throw new Error('Failed to fetch review stats');
    }

    const result = await response.json();
    return result.data;
  }

  static async uploadImage(file: File): Promise<string> {
    const formData = new FormData();
    formData.append('image', file);

    const response = await fetch(`${API_BASE}/reviews/upload-image`, {
      method: 'POST',
      credentials: 'include',
      body: formData
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || 'Failed to upload image');
    }

    const result = await response.json();
    return result.data.url;
  }

  static async deleteReview(reviewId: string): Promise<void> {
    const response = await fetch(`${API_BASE}/reviews/${reviewId}`, {
      method: 'DELETE',
      credentials: 'include'
    });

    if (!response.ok) {
      throw new Error('Failed to delete review');
    }
  }
}
```

#### 4.2.3 カスタムフック

```typescript
// hooks/useReviews.ts
import { useState, useEffect } from 'react';
import { Review, ReviewStats } from '../types/review';
import { ReviewApi } from '../services/reviewApi';

export const useReviews = (productId: string) => {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [stats, setStats] = useState<ReviewStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadReviews = async () => {
    try {
      setLoading(true);
      const [reviewsData, statsData] = await Promise.all([
        ReviewApi.getProductReviews(productId),
        ReviewApi.getReviewStats(productId)
      ]);
      setReviews(reviewsData.reviews);
      setStats(statsData);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadReviews();
  }, [productId]);

  return { reviews, stats, loading, error, reload: loadReviews };
};

// hooks/useImageUpload.ts
import { useState } from 'react';
import { ReviewApi } from '../services/reviewApi';

export const useImageUpload = () => {
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const uploadImage = async (file: File): Promise<string | null> => {
    try {
      setUploading(true);
      setError(null);
      const url = await ReviewApi.uploadImage(file);
      return url;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Upload failed';
      setError(errorMessage);
      return null;
    } finally {
      setUploading(false);
    }
  };

  return { uploadImage, uploading, error };
};
```

#### 4.2.4 コンポーネント実装

**StarRating（星評価表示/入力）**
```typescript
// components/StarRating.tsx
import React from 'react';

interface StarRatingProps {
  rating: number;
  onChange?: (rating: number) => void;
  readonly?: boolean;
  size?: 'small' | 'medium' | 'large';
}

export const StarRating: React.FC<StarRatingProps> = ({
  rating,
  onChange,
  readonly = false,
  size = 'medium'
}) => {
  const sizeClass = {
    small: 'text-sm',
    medium: 'text-xl',
    large: 'text-3xl'
  }[size];

  return (
    <div className={`flex items-center ${sizeClass}`}>
      {[1, 2, 3, 4, 5].map(star => (
        <button
          key={star}
          type="button"
          disabled={readonly}
          onClick={() => onChange?.(star)}
          className={`${readonly ? 'cursor-default' : 'cursor-pointer hover:scale-110'} transition-transform`}
          aria-label={`Rate ${star} stars`}
        >
          <span className={star <= rating ? 'text-yellow-400' : 'text-gray-300'}>
            ★
          </span>
        </button>
      ))}
    </div>
  );
};
```

**ReviewItem（レビュー個別表示）**
```typescript
// components/ReviewItem.tsx
import React from 'react';
import { Review } from '../types/review';
import { StarRating } from './StarRating';
import DOMPurify from 'isomorphic-dompurify';

interface ReviewItemProps {
  review: Review;
  onDelete?: (reviewId: string) => void;
  isAdmin?: boolean;
}

export const ReviewItem: React.FC<ReviewItemProps> = ({
  review,
  onDelete,
  isAdmin = false
}) => {
  // XSS対策: フロントエンドでも再度サニタイズ
  const sanitizedBody = DOMPurify.sanitize(review.body, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 'ul', 'ol', 'li', 'a', 'blockquote'],
    ALLOWED_ATTR: { 'a': ['href', 'target', 'rel'] }
  });

  return (
    <div className="border rounded-lg p-4 mb-4">
      <div className="flex items-start justify-between">
        <div className="flex items-center space-x-3">
          {review.user.avatar && (
            <img
              src={review.user.avatar}
              alt={review.user.name}
              className="w-10 h-10 rounded-full"
            />
          )}
          <div>
            <p className="font-semibold">{review.user.name}</p>
            <StarRating rating={review.rating} readonly size="small" />
          </div>
        </div>
        {isAdmin && (
          <button
            onClick={() => onDelete?.(review.id)}
            className="text-red-600 hover:text-red-800"
          >
            削除
          </button>
        )}
      </div>

      <h3 className="font-bold mt-3 mb-2">{review.title}</h3>
      
      <div
        className="prose prose-sm"
        dangerouslySetInnerHTML={{ __html: sanitizedBody }}
      />

      {review.images.length > 0 && (
        <div className="flex gap-2 mt-3">
          {review.images.map((img, index) => (
            <img
              key={index}
              src={img}
              alt={`Review image ${index + 1}`}
              className="w-32 h-32 object-cover rounded"
            />
          ))}
        </div>
      )}

      <p className="text-xs text-gray-500 mt-3">
        {new Date(review.createdAt).toLocaleDateString('ja-JP')}
      </p>
    </div>
  );
};
```

**ImageUploader（画像アップロード）**
```typescript
// components/ImageUploader.tsx
import React, { useState } from 'react';
import { useImageUpload } from '../hooks/useImageUpload';

interface ImageUploaderProps {
  onImageUploaded: (url: string) => void;
  maxImages?: number;
  currentImageCount?: number;
}

export const ImageUploader: React.FC<ImageUploaderProps> = ({
  onImageUploaded,
  maxImages = 3,
  currentImageCount = 0
}) => {
  const { uploadImage, uploading, error } = useImageUpload();
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (currentImageCount >= maxImages) {
      alert(`最大${maxImages}枚まで画像をアップロードできます`);
      return;
    }

    // プレビュー表示
    const reader = new FileReader();
    reader.onload = (e) => setPreviewUrl(e.target?.result as string);
    reader.readAsDataURL(file);

    // アップロード
    const url = await uploadImage(file);
    if (url) {
      onImageUploaded(url);
      setPreviewUrl(null);
    }
  };

  return (
    <div className="space-y-2">
      <input
        type="file"
        accept="image/jpeg,image/png,image/webp"
        onChange={handleFileChange}
        disabled={uploading || currentImageCount >= maxImages}
        className="block w-full text-sm"
      />
      {uploading && <p className="text-sm text-blue-600">アップロード中...</p>}
      {error && <p className="text-sm text-red-600">{error}</p>}
      {previewUrl && (
        <img src={previewUrl} alt="Preview" className="w-32 h-32 object-cover rounded" />
      )}
    </div>
  );
};
```

**ReviewForm（レビュー投稿フォーム）**
```typescript
// components/ReviewForm.tsx
import React, { useState } from 'react';
import { StarRating } from './StarRating';
import { ImageUploader } from './ImageUploader';
import { ReviewApi } from '../services/reviewApi';
import { CreateReviewRequest } from '../types/review';

interface ReviewFormProps {
  productId: string;
  onSubmitSuccess: () => void;
}

export const ReviewForm: React.FC<ReviewFormProps> = ({
  productId,
  onSubmitSuccess
}) => {
  const [rating, setRating] = useState(5);
  const [title, setTitle] = useState('');
  const [body, setBody] = useState('');
  const [images, setImages] = useState<string[]>([]);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!title.trim() || !body.trim()) {
      setError('タイトルと本文は必須です');
      return;
    }

    try {
      setSubmitting(true);
      setError(null);

      const data: CreateReviewRequest = {
        rating,
        title: title.trim(),
        body: body.trim(),
        images
      };

      await ReviewApi.createReview(productId, data);
      
      // フォームリセット
      setRating(5);
      setTitle('');
      setBody('');
      setImages([]);
      
      onSubmitSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'レビューの投稿に失敗しました');
    } finally {
      setSubmitting(false);
    }
  };

  const handleImageUploaded = (url: string) => {
    setImages([...images, url]);
  };

  const removeImage = (index: number) => {
    setImages(images.filter((_, i) => i !== index));
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4 border rounded-lg p-6">
      <h2 className="text-xl font-bold">レビューを投稿</h2>

      {error && (
        <div className="bg-red-50 text-red-600 p-3 rounded">{error}</div>
      )}

      <div>
        <label className="block mb-2 font-semibold">評価</label>
        <StarRating rating={rating} onChange={setRating} size="large" />
      </div>

      <div>
        <label className="block mb-2 font-semibold">タイトル</label>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          maxLength={200}
          className="w-full border rounded px-3 py-2"
          placeholder="レビューのタイトル"
          required
        />
        <p className="text-xs text-gray-500 mt-1">{title.length}/200文字</p>
      </div>

      <div>
        <label className="block mb-2 font-semibold">本文</label>
        <textarea
          value={body}
          onChange={(e) => setBody(e.target.value)}
          maxLength={10000}
          rows={6}
          className="w-full border rounded px-3 py-2"
          placeholder="商品の感想を詳しく教えてください"
          required
        />
        <p className="text-xs text-gray-500 mt-1">{body.length}/10000文字</p>
      </div>

      <div>
        <label className="block mb-2 font-semibold">画像（最大3枚）</label>
        {images.length > 0 && (
          <div className="flex gap-2 mb-3">
            {images.map((img, index) => (
              <div key={index} className="relative">
                <img src={img} alt={`Upload ${index + 1}`} className="w-32 h-32 object-cover rounded" />
                <button
                  type="button"
                  onClick={() => removeImage(index)}
                  className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6"
                >
                  ×
                </button>
              </div>
            ))}
          </div>
        )}
        <ImageUploader
          onImageUploaded={handleImageUploaded}
          currentImageCount={images.length}
        />
      </div>

      <button
        type="submit"
        disabled={submitting}
        className="w-full bg-blue-600 text-white py-3 rounded font-semibold hover:bg-blue-700 disabled:bg-gray-400"
      >
        {submitting ? '投稿中...' : 'レビューを投稿'}
      </button>
    </form>
  );
};
```

**ReviewList（レビュー一覧）**
```typescript
// components/ReviewList.tsx
import React from 'react';
import { useReviews } from '../hooks/useReviews';
import { ReviewItem } from './ReviewItem';
import { StarRating } from './StarRating';

interface ReviewListProps {
  productId: string;
  isAdmin?: boolean;
}

export const ReviewList: React.FC<ReviewListProps> = ({
  productId,
  isAdmin = false
}) => {
  const { reviews, stats, loading, error, reload } = useReviews(productId);

  if (loading) {
    return <div className="text-center py-8">読み込み中...</div>;
  }

  if (error) {
    return (
      <div className="text-center py-8 text-red-600">
        エラー: {error}
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {stats && (
        <div className="bg-gray-50 rounded-lg p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-3xl font-bold">{stats.averageRating.toFixed(1)}</p>
              <StarRating rating={Math.round(stats.averageRating)} readonly size="medium" />
              <p className="text-sm text-gray-600 mt-1">{stats.reviewCount}件のレビュー</p>
            </div>
            <div className="space-y-1">
              {[5, 4, 3, 2, 1].map(star => (
                <div key={star} className="flex items-center gap-2 text-sm">
                  <span>{star}★</span>
                  <div className="w-32 bg-gray-200 rounded-full h-2">
                    <div
                      className="bg-yellow-400 h-2 rounded-full"
                      style={{
                        width: `${(stats.ratingDistribution[star] / stats.reviewCount) * 100}%`
                      }}
                    />
                  </div>
                  <span className="text-gray-600">{stats.ratingDistribution[star]}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      <div>
        <h2 className="text-2xl font-bold mb-4">レビュー一覧</h2>
        {reviews.length === 0 ? (
          <p className="text-gray-500 text-center py-8">まだレビューがありません</p>
        ) : (
          reviews.map(review => (
            <ReviewItem
              key={review.id}
              review={review}
              isAdmin={isAdmin}
              onDelete={async (id) => {
                if (confirm('このレビューを削除しますか?')) {
                  await ReviewApi.deleteReview(id);
                  reload();
                }
              }}
            />
          ))
        )}
      </div>
    </div>
  );
};
```

---

## 5. テスト戦略

### 5.1 テスト方針

- **バックエンド**: Jest + supertest で統合テスト + ユニットテスト
- **フロントエンド**: React Testing Library + Jest でコンポーネントテスト
- **カバレッジ目標**: 80%以上
- **重点テスト領域**:
  - HTMLサニタイズ処理（XSS対策）
  - バリデーション処理
  - 平均評価計算ロジック
  - 画像アップロード処理

### 5.2 バックエンドテストケース

#### 5.2.1 統合テスト（review.test.ts）

```typescript
// __tests__/review.test.ts
import request from 'supertest';
import app from '../app';
import { db } from '../db';

describe('Review API', () => {
  let authToken: string;
  let productId: string;
  let userId: string;

  beforeAll(async () => {
    // テストデータ準備
    const userResult = await db.query(
      'INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id',
      ['Test User', 'test@example.com', 'hashedpassword']
    );
    userId = userResult.rows[0].id;

    const productResult = await db.query(
      'INSERT INTO products (name, price) VALUES ($1, $2) RETURNING id',
      ['Test Product', 1000]
    );
    productId = productResult.rows[0].id;

    // ログイン（認証トークン取得）
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({ email: 'test@example.com', password: 'password' });
    authToken = loginRes.body.token;
  });

  afterAll(async () => {
    await db.query('DELETE FROM reviews');
    await db.query('DELETE FROM products');
    await db.query('DELETE FROM users');
    await db.end();
  });

  describe('POST /api/products/:productId/reviews', () => {
    it('should create a review with valid data', async () => {
      const reviewData = {
        rating: 5,
        title: 'Great product!',
        body: '<p>This is a <strong>great</strong> product.</p>',
        images: ['https://example.com/image1.jpg']
      };

      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      expect(res.status).toBe(201);
      expect(res.body.data).toMatchObject({
        rating: 5,
        title: 'Great product!',
        productId: productId,
        userId: userId
      });
      expect(res.body.data.body).toContain('<p>');
      expect(res.body.data.body).toContain('<strong>');
    });

    it('should sanitize malicious HTML', async () => {
      const reviewData = {
        rating: 5,
        title: 'Test',
        body: '<script>alert("XSS")</script><p>Safe content</p>',
        images: []
      };

      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      expect(res.status).toBe(201);
      expect(res.body.data.body).not.toContain('<script>');
      expect(res.body.data.body).toContain('<p>Safe content</p>');
    });

    it('should reject invalid rating', async () => {
      const reviewData = {
        rating: 6,
        title: 'Test',
        body: 'Test body',
        images: []
      };

      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      expect(res.status).toBe(400);
      expect(res.body.error.message).toContain('Rating must be between 1 and 5');
    });

    it('should reject duplicate review', async () => {
      const reviewData = {
        rating: 5,
        title: 'Test',
        body: 'Test body',
        images: []
      };

      // 1回目の投稿
      await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      // 2回目の投稿（重複）
      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      expect(res.status).toBe(409);
    });

    it('should reject more than 3 images', async () => {
      const reviewData = {
        rating: 5,
        title: 'Test',
        body: 'Test body',
        images: [
          'https://example.com/1.jpg',
          'https://example.com/2.jpg',
          'https://example.com/3.jpg',
          'https://example.com/4.jpg'
        ]
      };

      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(reviewData);

      expect(res.status).toBe(400);
      expect(res.body.error.message).toContain('Maximum 3 images');
    });

    it('should require authentication', async () => {
      const res = await request(app)
        .post(`/api/products/${productId}/reviews`)
        .send({ rating: 5, title: 'Test', body: 'Test', images: [] });

      expect(res.status).toBe(401);
    });
  });

  describe('GET /api/products/:productId/reviews', () => {
    beforeEach(async () => {
      // テストレビューを3件作成
      for (let i = 0; i < 3; i++) {
        await db.query(
          `INSERT INTO reviews (product_id, user_id, rating, title, body)
           VALUES ($1, $2, $3, $4, $5)`,
          [productId, userId, 5, `Review ${i}`, `Body ${i}`]
        );
      }
    });

    it('should return all reviews for a product', async () => {
      const res = await request(app)
        .get(`/api/products/${productId}/reviews`);

      expect(res.status).toBe(200);
      expect(res.body.reviews).toHaveLength(3);
      expect(res.body.pagination.total).toBe(3);
    });

    it('should support pagination', async () => {
      const res = await request(app)
        .get(`/api/products/${productId}/reviews?limit=2&offset=1`);

      expect(res.status).toBe(200);
      expect(res.body.reviews).toHaveLength(2);
      expect(res.body.pagination.offset).toBe(1);
    });
  });

  describe('GET /api/products/:productId/reviews/stats', () => {
    beforeEach(async () => {
      // 評価分布のテストデータ作成
      await db.query(
        `INSERT INTO reviews (product_id, user_id, rating, title, body)
         VALUES ($1, $2, 5, 'Title', 'Body'), ($1, $2, 4, 'Title', 'Body'), ($1, $2, 5, 'Title', 'Body')`,
        [productId, userId]
      );
    });

    it('should return correct average rating', async () => {
      const res = await request(app)
        .get(`/api/products/${productId}/reviews/stats`);

      expect(res.status).toBe(200);
      expect(res.body.data.averageRating).toBeCloseTo(4.67, 1);
      expect(res.body.data.reviewCount).toBe(3);
      expect(res.body.data.ratingDistribution).toMatchObject({
        5: 2,
        4: 1,
        3: 0,
        2: 0,
        1: 0
      });
    });
  });

  describe('DELETE /api/reviews/:reviewId', () => {
    let reviewId: string;
    let adminToken: string;

    beforeEach(async () => {
      // レビュー作成
      const reviewResult = await db.query(
        `INSERT INTO reviews (product_id, user_id, rating, title, body)
         VALUES ($1, $2, 5, 'Title', 'Body') RETURNING id`,
        [productId, userId]
      );
      reviewId = reviewResult.rows[0].id;

      // 管理者ログイン
      const adminRes = await request(app)
        .post('/api/auth/login')
        .send({ email: 'admin@example.com', password: 'adminpass' });
      adminToken = adminRes.body.token;
    });

    it('should delete review as admin', async () => {
      const res = await request(app)
        .delete(`/api/reviews/${reviewId}`)
        .set('Authorization', `Bearer ${adminToken}`);

      expect(res.status).toBe(204);

      // 削除確認
      const checkRes = await request(app)
        .get(`/api/products/${productId}/reviews`);
      expect(checkRes.body.reviews.find((r: any) => r.id === reviewId)).toBeUndefined();
    });

    it('should reject non-admin user', async () => {
      const res = await request(app)
        .delete(`/api/reviews/${reviewId}`)
        .set('Authorization', `Bearer ${authToken}`); // 通常ユーザー

      expect(res.status).toBe(403);
    });
  });
});
```

#### 5.2.2 ユニットテスト（htmlSanitizer.test.ts）

```typescript
// __tests__/htmlSanitizer.test.ts
import { HtmlSanitizer } from '../utils/htmlSanitizer';

describe('HtmlSanitizer', () => {
  it('should allow safe HTML tags', () => {
    const input = '<p>This is <strong>bold</strong> and <em>italic</em>.</p>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).toBe(input);
  });

  it('should remove script tags', () => {
    const input = '<p>Safe content</p><script>alert("XSS")</script>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).not.toContain('<script>');
    expect(output).toContain('<p>Safe content</p>');
  });

  it('should remove event handlers', () => {
    const input = '<p onclick="alert(\'XSS\')">Click me</p>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).not.toContain('onclick');
  });

  it('should sanitize malicious links', () => {
    const input = '<a href="javascript:alert(\'XSS\')">Click</a>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).not.toContain('javascript:');
  });

  it('should allow safe links', () => {
    const input = '<a href="https://example.com" target="_blank" rel="noopener">Link</a>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).toContain('href="https://example.com"');
    expect(output).toContain('target="_blank"');
  });

  it('should remove iframe tags', () => {
    const input = '<p>Content</p><iframe src="evil.com"></iframe>';
    const output = HtmlSanitizer.sanitize(input);
    expect(output).not.toContain('<iframe>');
  });
});
```

### 5.3 フロントエンドテストケース

```typescript
// __tests__/ReviewForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ReviewForm } from '../components/ReviewForm';
import { ReviewApi } from '../services/reviewApi';

jest.mock('../services/reviewApi');

describe('ReviewForm', () => {
  const mockOnSubmitSuccess = jest.fn();
  const productId = 'product-123';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render form elements', () => {
    render(<ReviewForm productId={productId} onSubmitSuccess={mockOnSubmitSuccess} />);
    
    expect(screen.getByLabelText(/評価/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/タイトル/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/本文/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /投稿/i })).toBeInTheDocument();
  });

  it('should submit review with valid data', async () => {
    (ReviewApi.createReview as jest.Mock).mockResolvedValue({});

    render(<ReviewForm productId={productId} onSubmitSuccess={mockOnSubmitSuccess} />);

    fireEvent.change(screen.getByLabelText(/タイトル/i), {
      target: { value: 'Great product' }
    });
    fireEvent.change(screen.getByLabelText(/本文/i), {
      target: { value: 'This product is amazing!' }
    });
    fireEvent.click(screen.getByRole('button', { name: /投稿/i }));

    await waitFor(() => {
      expect(ReviewApi.createReview).toHaveBeenCalledWith(productId, {
        rating: 5,
        title: 'Great product',
        body: 'This product is amazing!',
        images: []
      });
      expect(mockOnSubmitSuccess).toHaveBeenCalled();
    });
  });

  it('should show error for empty fields', async () => {
    render(<ReviewForm productId={productId} onSubmitSuccess={mockOnSubmitSuccess} />);

    fireEvent.click(screen.getByRole('button', { name: /投稿/i }));

    await waitFor(() => {
      expect(screen.getByText(/タイトルと本文は必須です/i)).toBeInTheDocument();
    });
  });

  it('should handle API errors', async () => {
    (ReviewApi.createReview as jest.Mock).mockRejectedValue(
      new Error('Network error')
    );

    render(<ReviewForm productId={productId} onSubmitSuccess={mockOnSubmitSuccess} />);

    fireEvent.change(screen.getByLabelText(/タイトル/i), {
      target: { value: 'Test' }
    });
    fireEvent.change(screen.getByLabelText(/本文/i), {
      target: { value: 'Test body' }
    });
    fireEvent.click(screen.getByRole('button', { name: /投稿/i }));

    await waitFor(() => {
      expect(screen.getByText(/レビューの投稿に失敗しました/i)).toBeInTheDocument();
    });
  });
});
```

---

## 6. 実装順序

### Phase 1: 基盤整備（2日）

**目的**: データベース、エラーハンドリング、ユーティリティの準備

1. **DBマイグレーション実行**
   - `migrations/001_create_reviews_table.sql` を作成
   - マイグレーション実行（reviews テーブル + product_review_stats テーブル + トリガー）
   - インデックス作成確認

2. **カスタムエラークラス追加**
   - `ImageUploadError`, `DuplicateReviewError` を既存エラーに追加

3. **HTMLサニタイザー実装**
   - `utils/htmlSanitizer.ts` を作成
   - DOMPurifyライブラリインストール: `npm install isomorphic-dompurify`
   - ユニットテスト作成: `__tests__/htmlSanitizer.test.ts`
   - **テスト実行**: `npm test htmlSanitizer.test.ts`

4. **S3クライアント設定**
   - `utils/s3Client.ts` を作成
   - AWS SDK インストール: `npm install @aws-sdk/client-s3`
   - 環境変数設定（S3_REGION, S3_ENDPOINT, S3_ACCESS_KEY, S3_SECRET_KEY, S3_BUCKET_NAME）

### Phase 2: バックエンドコア機能（3日）

**目的**: レビュー投稿・取得のコア機能実装

5. **モデル定義**
   - `models/Review.ts` を作成
   - バリデーションメソッド実装

6. **Repository層実装**
   - `repositories/reviewRepository.ts` を作成
   - CRUD操作メソッド実装（create, findByProductId, getStats, delete, updateFlag）
   - SQL構文のテスト（手動またはDB直接確認）

7. **Service層実装**
   - `services/reviewService.ts` を作成
   - ビジネスロジック実装（重複チェック、バリデーション、サニタイズ）
   - ユニットテスト作成: `__tests__/reviewService.test.ts`
   - **テスト実行**: `npm test reviewService.test.ts`

8. **画像アップロード実装**
   - `services/imageUploadService.ts` を作成
   - sharpライブラリインストール: `npm install sharp`
   - 画像リサイズ・最適化処理実装
   - ユニットテスト作成

9. **Controller層実装**
   - `controllers/reviewController.ts` を作成
   - 各エンドポイントのハンドラー実装

10. **ルーティング設定**
    - `routes/index.ts` にレビューエンドポイント追加
    - Multerミドルウェア設定: `npm install multer @types/multer`
    - 認証ミドルウェア適用

11. **管理者認証ミドルウェア**
    - `middleware/adminAuth.ts` を作成
    - requireAdmin 関数実装

### Phase 3: バックエンド統合テスト（2日）

**目的**: API全体の動作確認

12. **統合テスト実装**
    - `__tests__/review.test.ts` を作成
    - 全エンドポイントのテストケース実装（正常系・異常系）
    - **テスト実行**: `npm test review.test.ts`

13. **手動動作確認**
    - Postman/curlでAPI呼び出しテスト
    - 各種エラーケースの確認
    - S3画像アップロード確認

### Phase 4: フロントエンド実装（3日）

**目的**: React コンポーネント実装

14. **型定義**
    - `types/review.ts` を作成

15. **API Service実装**
    - `services/reviewApi.ts` を作成
    - 全APIエンドポイントのラッパー関数実装

16. **カスタムフック実装**
    - `hooks/useReviews.ts` を作成
    - `hooks/useImageUpload.ts` を作成

17. **基本コンポーネント実装**
    - `components/StarRating.tsx` を作成
    - `components/ImageUploader.tsx` を作成

18. **レビュー表示コンポーネント**
    - `components/ReviewItem.tsx` を作成（DOMPurifyインストール: `npm install dompurify @types/dompurify`）
    - `components/ReviewList.tsx` を作成

19. **レビュー投稿コンポーネント**
    - `components/ReviewForm.tsx` を作成

20. **商品詳細ページ統合**
    - 既存の `ProductDetail.tsx` にレビューコンポーネント組み込み

### Phase 5: フロントエンドテスト（2日）

**目的**: コンポーネントの動作確認

21. **コンポーネントテスト実装**
    - `__tests__/ReviewForm.test.tsx` を作成
    - `__tests__/ReviewList.test.tsx` を作成
    - `__tests__/reviewApi.test.ts` を作成
    - **テスト実行**: `npm test`

22. **E2Eテスト（手動）**
    - ブラウザでレビュー投稿フロー確認
    - 画像アップロード確認
    - レビュー一覧表示確認
    - モバイル表示確認

### Phase 6: 最終調整・デプロイ準備（1日）

**目的**: 品質保証とリリース準備

23. **パフォーマンステスト**
    - 大量レビューデータでの動作確認
    - クエリパフォーマンス測定（EXPLAIN ANALYZE）
    - 必要に応じてインデックス追加

24. **セキュリティレビュー**
    - XSS対策の再確認（サニタイズ処理の動作テスト）
    - 認証・認可の確認
    - SQL Injection対策確認（パラメータ化クエリ使用確認）

25. **ドキュメント作成**
    - API仕様書更新
    - デプロイ手順書作成
    - 運用マニュアル作成

26. **デプロイ**
    - ステージング環境デプロイ
    - 本番環境デプロイ
    - 動作確認

---

## 7. リスク管理と改善提案

### 7.1 設計上の重大な問題点

#### 問題1: XSS脆弱性
- **現状**: 要件では「HTMLをそのまま表示」と指定されている
- **リスク**: 悪意のあるスクリプト実行によるセッション盗聴、個人情報漏洩
- **対策**: 本計画ではDOMPurifyによる厳格なサニタイズを実装済み
- **推奨**: 可能であれば、リッチテキストの代わりにMarkdown形式を採用することを検討

#### 問題2: パフォーマンス問題
- **現状**: 平均評価を毎回全レビューから計算
- **リスク**: レビュー数が数千件を超えると応答時間が数秒単位で増加
- **対策**: 本計画では `product_review_stats` テーブルとトリガーでキャッシュ化を実装
- **推奨**: 将来的にはRedisなどのインメモリキャッシュも検討

#### 問題3: データモデルの責務混在
- **現状**: 提供されたReviewモデルに複数の責務が混在
- **対策**: 本計画ではSingle Responsibility Principleに基づき責務を分離

### 7.2 今後の拡張性

**将来的な機能追加候補**:
- レビューへの「役立った」投票機能
- レビューへの返信機能（販売者返信）
- レビューの編集機能
- 購入者のみ投稿可能にする制限（Order履歴との連携）
- レビューのソート・フィルタリング（役立った順、最新順、評価順）
- 画像のサムネイル生成

**スケーラビリティ考慮事項**:
- レビュー数が10万件を超える場合: ElasticsearchやAlgoliaでの全文検索導入
- 画像数が大量になる場合: CDN（CloudFront等）の導入
- 同時アクセスが増加する場合: アプリケーションサーバーのスケールアウト

---

## 8. まとめ

本開発計画書は、商品レビュー機能の実装に必要なすべての要素を網羅しています。

**重要な実装ポイント**:
1. **セキュリティ優先**: HTMLサニタイズによるXSS対策を徹底
2. **パフォーマンス最適化**: 統計情報のキャッシュ化でスケーラビリティ確保
3. **保守性の高い設計**: レイヤー分離とSingle Responsibility Principleの遵守
4. **テストカバレッジ**: 80%以上を目標とした包括的なテスト戦略

**推定工数**: 13日（1エンジニア）
- フェーズ1: 2日
- フェーズ2: 3日
- フェーズ3: 2日
- フェーズ4: 3日
- フェーズ5: 2日
- フェーズ6: 1日

この計画に従うことで、品質の高いレビュー機能を安全かつ効率的に実装できます。
