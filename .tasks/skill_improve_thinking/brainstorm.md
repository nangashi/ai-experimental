# 「スキルの改善とは何か」ブレインストーミング

「スキルを改善するスキル」を設計するにあたり、「改善」が意味しうる全ての観点を洗い出す。

---

## A. 目的達成系（スキルが「やるべきこと」をやれているか）

### A-1. 目的達成率
スキルが宣言した目的を、期待どおりに完了できる確率。途中で失敗・脱線・不完全な結果で終わるケースが減ること。

### A-2. 成果物の正確性
生成される成果物（文書、コード、分析結果）が事実として正しいこと。幻覚、誤った推論、不整合な出力が含まれないこと。

### A-3. 成果物の網羅性
スキルがカバーすべき範囲を漏れなくカバーしていること。見落とし・検出漏れ（レビュースキルなら偽陰性）が少ないこと。

### A-4. 成果物の精度（偽陽性の抑制）
レビュー・分析スキルにおいて、的外れな指摘や誤検出が少ないこと。ノイズが多いと信頼性とユーザー体験の両方が劣化する。

### A-5. 判断品質
分岐や選択が必要な場面で、適切な判断を下せること。文脈に応じた優先度付け、トレードオフの評価が的確であること。

### A-6. ロバスト性
入力のバリエーション（異なるフォーマット、サイズ、品質のファイル）に対して安定した結果を返せること。エッジケースで破綻しないこと。

### A-7. 再現性
同一入力に対して、実行のたびに大きく異なる結果にならないこと。結果のばらつき幅が許容範囲内であること。

---

## B. ユーザー価値系（ユーザーにとっての使いやすさ・有用性）

### B-1. ユーザー意図の正確な反映
ユーザーが暗黙に期待する方向性や好みを、確認なしでも正しく推測できること。あるいは、適切なタイミングで適切な粒度の確認ができること。

### B-2. 制御性・介入のしやすさ
ユーザーが中間結果を見て方向修正できるポイントが適切に設計されていること。過剰な自動化で暴走しないこと。

### B-3. 結果の説明可能性
なぜその結果になったのかをユーザーが理解できること。判断の根拠、選択の理由が追跡可能であること。

### B-4. 期待値の管理
スキルが何をして何をしないかが事前に明確であること。結果に対する期待と実際のギャップが小さいこと。

### B-5. 成果物の利用しやすさ
出力されたファイルが、次のアクション（別のスキルへの入力、手動レビュー、意思決定）に直接使える形式であること。後処理が不要なこと。

### B-6. エラー時のリカバリ体験
失敗した場合にユーザーが何が起きたか理解でき、リカバリの手段が明確であること。「やり直し」のコストが低いこと。

### B-7. 学習コスト
ユーザーがスキルの使い方を習得するのに必要な時間・労力が小さいこと。直感的であること。

---

## C. 効率系（リソースの使い方）

### C-1. トークンコスト
スキル1回の実行で消費されるトークン量。同じ品質を達成するのに、より少ないトークンで済むこと。

### C-2. 実行時間（レイテンシ）
スキルの開始から完了までにかかる壁時計時間。並列化やステップ削減により短縮されること。

### C-3. コンテキストウィンドウ効率
限られたコンテキスト枠を有効に使っていること。不要な情報で枠を浪費せず、必要な情報が適時参照されること。

### C-4. サブエージェント効率
サブエージェントの使い方が適切であること。過剰な委譲（オーバーヘッド > 本体処理）や、不足な委譲（親コンテキスト肥大化）がないこと。

### C-5. 人的コスト
ユーザーが介入・確認・修正に費やす時間。ユーザーの注意を必要とする回数と各回の認知負荷が最小化されていること。

### C-6. 反復効率
同じスキルを複数回実行する場合（異なる入力で、または改善ループの繰り返しで）、前回の結果を活用して効率化できること。

---

## D. 構造・設計品質系（スキル定義そのものの品質）

### D-1. スキルファイル構成のシンプルさ
ファイル数、行数、ディレクトリ構造が必要最小限であること。理解しやすく、修正しやすいこと。

### D-2. 関心の分離
各ファイル・各セクションの責務が明確で、1つの変更が1箇所で完結すること。変更の波及範囲が予測可能であること。

### D-3. 指示の明確性
スキルの指示がLLMにとって曖昧でないこと。「どう解釈しても同じ行動になる」レベルの明確さがあること。

### D-4. 指示の最小性
同じ行動を引き出すのに、最も少ない指示量で済んでいること。冗長な説明、LLMが自然にやることの明示、過剰な制約がないこと。

### D-5. テンプレート・パターンの一貫性
スキル内の各フェーズ・テンプレートが統一されたパターンに従っていること。学習した設計パターンが再利用されていること。

### D-6. 拡張性
新しいユースケースや入力形式への対応を追加する際のコストが低いこと。既存構造を壊さずに拡張できること。

### D-7. 保守性
時間の経過とともに、スキルの修正・更新が容易であること。依存関係が明確で、部分的な修正が全体に悪影響を与えないこと。

---

## E. 追跡・分析・学習系（知見の蓄積と活用）

### E-1. 中間ファイルによる追跡可能性
各フェーズの入力・出力が中間ファイルとして保存され、事後的に「何が起きたか」を再構成できること。

### E-2. 比較可能性
異なる実行結果（バージョン間、パラメータ間）を並べて比較できること。差分が明確に見えること。

### E-3. 失敗の診断容易性
期待外の結果が出た場合、どのフェーズで何が原因で逸脱したかを特定できること。ログ・中間出力が十分にあること。

### E-4. 知見の蓄積と活用
実行から得られた教訓がナレッジとして構造的に記録され、次回以降の実行で実際に活用されること。

### E-5. メトリクスの定義と計測
「改善されたかどうか」を判定するための指標が定義されていて、自動的に計測・比較できること。

### E-6. 改善の方向性の可視化
現在のスキルがどの観点で強く/弱いかが可視化され、次に何を改善すべきかが明確であること。

---

## F. 安全性・信頼性系

### F-1. 破壊的操作の防止
スキルの実行が既存のファイルやデータを意図せず壊さないこと。冪等性、バックアップ、確認ステップが適切に設計されていること。

### F-2. 退行の防止
改善のつもりで行った変更が、別の観点で性能を劣化させないこと。改善前後の比較検証が組み込まれていること。

### F-3. 過剰最適化の回避
特定のテストケースやメトリクスに過剰適合して、一般的なケースでの性能が低下しないこと。

### F-4. 改善の収束性
改善ループが有限回で収束し、無意味な振動（Aに変えてBに戻してまたAに変えて…）が発生しないこと。

### F-5. 変更の可逆性
適用された改善が期待外れだった場合に、元の状態に戻せること。バージョン管理やスナップショットが機能すること。

---

## G. メタ改善系（改善プロセス自体の品質）

### G-1. 改善の自動化度
人間の介入なしに改善ループを回せる度合い。ただし完全自動化と品質のトレードオフがある。

### G-2. 改善の速度
1回の改善サイクルにかかる時間とコスト。少ない反復で大きな改善を得られること。

### G-3. 改善のポータビリティ
あるスキルで得られた知見が、別のスキルの改善に転用できること。汎用的な改善パターンの抽出。

### G-4. 改善の優先順位付け
複数の改善候補の中から、最もインパクトの大きいものを選択できること。ROIベースの判断。

### G-5. 改善のスコープ制御
1回の改善で変更する範囲が適切に制限されていること。大きすぎる変更は効果測定を困難にし、小さすぎる変更はコスト非効率。

### G-6. 改善の説明と合意形成
なぜその改善を行うのか、どういう効果が期待されるのかをユーザーに説明し、合意を得るプロセス。

### G-7. 改善手段の多様性
構造変更だけでなく、コンテンツ改善、パラメータ調整、ワークフロー再設計、分割・統合など、多様な改善手段を持つこと。

---

## H. 環境適応系

### H-1. プロジェクト文脈への適応
スキルが使われるプロジェクトの規約、技術スタック、ドメイン知識に合わせた動作ができること。

### H-2. ユーザーの習熟度への適応
初心者にはより多くの説明と確認を、熟練者にはより少ない介入を提供する柔軟性。

### H-3. モデル特性への適応
使用するLLMの特性（得意/不得意、バイアス傾向、コンテキスト長）に合わせた指示設計になっていること。

### H-4. 入力スケールへの適応
小さいファイルから大きいファイルまで、入力サイズに応じて処理戦略を適切に変えられること。

---

## 観点の整理マトリクス

| カテゴリ | 改善の対象 | 測定の容易さ | 既存スキルでの対応状況 |
|---------|-----------|------------|-------------------|
| A. 目的達成 | スキルの出力結果 | 中〜高（テストで計測可能） | agent_bench, agent_audit_reviewer |
| B. ユーザー価値 | ユーザー体験 | 低（主観的、計測困難） | skill_audit（部分的） |
| C. 効率 | リソース消費 | 高（トークン数、時間で計測） | 未対応（手動観察のみ） |
| D. 構造・設計 | スキル定義ファイル | 中（静的分析可能） | agent_audit, skill_audit |
| E. 追跡・学習 | メタデータ・ナレッジ | 中（構造の有無で判定） | agent_bench（knowledge.md） |
| F. 安全性 | 変更管理プロセス | 中（退行テストで検証） | agent_bench（比較評価） |
| G. メタ改善 | 改善プロセス自体 | 低（プロセスメトリクス） | 未対応 |
| H. 環境適応 | 動作の柔軟性 | 低（多環境テスト必要） | 未対応 |

---

## 既存スキルとの対応関係

| 既存スキル | 主にカバーする改善観点 | カバーしていない主要な観点 |
|-----------|-------------------|----------------------|
| agent_bench | A-1〜A-4（構造バリアントのA/Bテスト） | B全般, C全般, D-4, G-3 |
| agent_audit | D-1〜D-5（静的コンテンツ分析） | A全般（動的テストなし）, C全般 |
| agent_audit_reviewer | A-1〜A-4（エラー駆動の反復最適化） | B全般, C全般, D全般 |
| skill_audit | D全般, B-2,B-6（多観点レビュー） | A全般（性能計測なし）, C全般 |

### 主要なギャップ

1. **効率系（C）の改善を扱うスキルが存在しない** — トークンコスト、実行時間の計測と最適化
2. **ユーザー体験（B）の系統的な改善手段がない** — 主観的品質の扱い方が未定義
3. **メタ改善（G）のフレームワークがない** — 改善プロセス自体の効率化、知見のクロススキル転用
4. **環境適応（H）は完全に未着手** — スキルは固定的で、実行環境に適応しない
5. **カテゴリ横断の統合的な改善判断** — 「Aを上げるとCが下がる」のようなトレードオフ管理

---

## 「スキルを改善するスキル」が取りうるアプローチ

### アプローチ1: 統合ダッシュボード型
全観点のスコアを計測・可視化し、ユーザーが改善の方向性を選択する。改善自体は既存スキルに委譲。

### アプローチ2: 自動診断＋処方型
スキルの弱点を自動診断し、最適な改善手段（既存スキル or 新規手法）を処方・実行する。

### アプローチ3: 目標指定型
ユーザーが「コストを50%削減したい」「検出率を上げたい」と目標を指定し、それに特化した改善を行う。

### アプローチ4: 継続的モニタリング型
スキルの実行を監視し、劣化や非効率を検出して改善を提案する。proactiveな改善。

### アプローチ5: レシピ・パターン適用型
「改善パターンカタログ」から適用可能なパターンを選んで順に適用・検証する。
