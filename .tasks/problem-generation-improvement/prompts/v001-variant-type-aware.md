# Problem Generator — v001-variant-type-aware

baseline に対して「エージェント種別の分類と種別固有のテスト入力生成」を追加したバリアント。
入力型不整合の根本原因（種別判定なし）を解決するアプローチ。

---

## あなたのタスク

与えられたエージェント定義を分析し、エージェントの種別を正確に判定した上で、種別に応じた適切なテストシナリオセットとルーブリックを生成してください。

## 入力

- `{agent_definition_path}`: 評価対象エージェントの定義ファイルパス
- `{knowledge_path}`: 知見ファイルパス（テスト履歴確認用、存在する場合）
- `{test_set_save_path}`: テストシナリオセットの保存先パス
- `{rubric_save_path}`: ルーブリックの保存先パス
- `{agent_name}`: エージェント名

## 手順

### Step 1: エージェント定義の分析と種別判定

Read で `{agent_definition_path}` を読み込み、以下を順に特定する:

**1-a. 基本要素の特定**:
- 主要タスク: エージェントは何をするのか
- 想定入力: エージェントは何を受け取るのか
- 期待出力: エージェントは何を生成するのか

**1-b. 入力型の分類**:
以下のどれに該当するか判定する:
- **ドキュメント入力**: 設計書、仕様書、アーキテクチャ文書
- **コード入力**: ソースコード、設定ファイル
- **メタ入力**: エージェント定義、観点定義、プロンプト等の「AI指示を記述したファイル」
- **要件入力**: 要件定義、Issue、ユーザー要求
- **固有入力**: 上記に該当しない特定フォーマット

**1-c. 出力型の分類**:
- **評価出力**: 問題指摘リスト、評価レポート、批評
- **設計出力**: 設計書、計画書、ADR
- **コード出力**: ソースコード、設定ファイル、テストコード
- **変換出力**: 入力の変換結果

**1-d. 種別の決定**:

| 入力型 | 出力型 | 種別 |
|--------|--------|------|
| ドキュメント入力 | 評価出力 | **Type-A: ドキュメントレビューア** |
| コード入力 | 評価出力 | **Type-B: コードレビューア** |
| メタ入力 | 評価出力 | **Type-C: メタ評価エージェント** |
| 要件入力 | 設計出力 | **Type-D: 計画・設計エージェント** |
| 要件/設計 | コード出力 | **Type-E: 実装エージェント** |
| その他 | その他 | **Type-F: 汎用** |

**1-e. 能力カテゴリの特定**: 3-5個に分類。

`{knowledge_path}` が存在する場合は Read で読み込み、テスト履歴を確認。

### Step 2: 種別に応じたテストシナリオの生成

5-8個のテストシナリオを生成する。以下の種別固有ルールに従う:

#### Type-A (ドキュメントレビューア) のテスト入力

- **入力内容**: 50-100行のシステム設計書/仕様書
- **問題埋め込み**: 各シナリオに 2-4 個の既知の問題を意図的に埋め込む
- **問題の自然さ**: 「TODO」「FIXME」等のマーカーは使わない。設計上の判断ミスや考慮漏れとして自然に埋め込む
- **ルーブリック焦点**: 問題検出の正確性、重要度判定、改善提案の具体性

#### Type-B (コードレビューア) のテスト入力

- **入力内容**: 30-80行のソースコード
- **問題埋め込み**: 各シナリオに 2-4 個の既知の欠陥を埋め込む
- **言語**: 対象エージェントの想定言語に合わせる（不明な場合は TypeScript/Java）
- **ルーブリック焦点**: 欠陥検出、パターン違反検出、修正提案の正確性

#### Type-C (メタ評価エージェント) のテスト入力

- **入力内容**: 30-80行のエージェント定義/観点定義ファイル
- **品質バリエーション**: 良い定義、曖昧な定義、スコープ重複のある定義、過度に狭い定義を混在させる
- **注意**: テスト入力にはコードや設計書を絶対に使わない。入力は必ずエージェント/観点の定義ファイルであること
- **ルーブリック焦点**: 問題点の特定、根拠の具体性、改善提案の実行可能性

#### Type-D (計画・設計エージェント) のテスト入力

- **入力内容**: 20-60行の要件定義/Issue 記述
- **複雑度バリエーション**: 明確な要件、曖昧な要件、矛盾する要件を混在させる
- **ルーブリック焦点**: 要件の網羅性、設計の具体性（関数名・型等）、実現可能性

#### Type-E (実装エージェント) のテスト入力

- **入力内容**: 30-80行の設計書/実装仕様 + 既存コードの抜粋
- **ルーブリック焦点**: コードの正確性、設計準拠、テスト網羅性

#### Type-F (汎用) のテスト入力

- **入力内容**: エージェントの想定入力に合わせた 20-100行のコンテンツ
- **ルーブリック焦点**: エージェントの目的に合わせて個別設計

### Step 3: シナリオ構造

各シナリオは以下の構造で記述する:

```markdown
### T01: {Scenario Title}

**Difficulty**: Easy / Medium / Hard
**Category**: {テストする能力カテゴリ}

#### Input
{種別固有ルールに従った入力コンテンツ}

#### Quality Rubric

| Criterion ID | Criterion | Full (2) | Partial (1) | Miss (0) | Weight |
|-------------|-----------|----------|-------------|----------|--------|
| T01-C1 | {基準名} | {完全達成の条件} | {部分達成の条件} | {未達成の条件} | 1.0 |

#### Expected Key Behaviors
- {良い出力に含まれるべき要素}

#### Anti-patterns
- {悪い出力の特徴}
```

ルーブリック基準の書き方:
- **具体的** であること
- **Full(2)** = 核心的ポイントを正確に達成、**Partial(1)** = 関連する内容に触れるが核心が不足
- **Weight**: 核心的=1.0、補助的=0.5
- 各シナリオに3-6個の基準

シナリオ分布: 易2 / 中3 / 難1-3。全能力カテゴリをカバー。

### Step 4: 品質チェック

保存前に以下を確認:

- [ ] **入力型チェック**: 全テストシナリオの入力が Step 1 で判定した種別の入力型と一致するか
- [ ] シナリオが5-8個あるか
- [ ] 難易度分布が適切か
- [ ] 全能力カテゴリをカバーしているか
- [ ] 入力が自然で現実的か
- [ ] Full/Partial/Miss の条件が具体的か
- [ ] シナリオ間で入力が多様か

### Step 5: 保存

テストシナリオセットを `{test_set_save_path}` に、ルーブリックを `{rubric_save_path}` に Write で保存する。

### Step 6: サマリ返答

```
## テストシナリオセット
- エージェント: {agent_name}
- 種別: Type-{X} ({種別名})
- 入力型: {判定された入力型}
- シナリオ数: {N}
- 能力カテゴリ: {カテゴリリスト}

| ID | タイトル | 難易度 | カテゴリ | 基準数 |
|----|---------|--------|---------|--------|
| T01 | {title} | {difficulty} | {category} | {N} |
...
```
