# 設計原則のワークフローマッピング

ミノ駆動氏の主張をベースに批判的評価・修正・フィルタリングを経て残った15の設計原則を、AI駆動開発ワークフロー（`.tasks/ai-development-workflow/workflow.md`）の各フェーズに対応付ける。

---

## 適用対象の設計原則（15項目）

02-critical-analysis.md の最終リストを参照。以下ではP1〜P15の略称で参照する。

| # | 原則 | 適用条件 |
|---|------|---------|
| P1 | 値オブジェクト | ドメインロジック・バリデーションがある場合 |
| P2 | 完全コンストラクタ | 原則。技術制約（ORM, DI等）で例外あり |
| P3 | 不変性優先 | デフォルト方針 |
| P4 | データクラス=低凝集 | ドメイン層限定。DTO・イベント等は正当 |
| P5 | 副作用を持つstaticメソッドの排除 | 副作用・外部依存を持つstaticが対象 |
| P6 | デメテルの法則 | 内部構造への依存を制限 |
| P7 | 散在する条件分岐→ポリモーフィズム | 同一条件が複数箇所に散在する場合 |
| P8 | ファーストクラスコレクション | ビジネスルール（件数制約、重複禁止等）がある場合 |
| P9 | サブクラスの都合でスーパークラス変更禁止 | 継承関係の安定性 |
| P10 | 目的が異なるものを共通化しない | 見た目の類似ではなく意図の一致で判断 |
| P11 | null可能性の型による安全管理 | 型システムでnullを管理 |
| P12 | 目的駆動名前設計 | ドメイン層。インフラ層は技術的命名が適切 |
| P13 | CQS | デフォルト原則。アトミック操作等の正当な例外あり |
| P14 | 役割駆動設計 | 大規模ドメインでBounded Contextレベルの分割が必要な場合 |
| P15 | DRY=意図の重複禁止 | コードの見た目ではなく「意図・知識」の重複を排除 |

---

## マッピング概要

| フェーズ | 適用する原則 | 適用の性質 |
|---------|-------------|----------|
| §1 要件理解 | P12, P14, P15 | 問題分析の視点 |
| §2 既存実装調査 | P4, P5, P6, P7, P10 | 既存問題の検出基準 |
| §3 技術・アーキテクチャ | P3, P9, P14 | アーキテクチャ方針 |
| §4 詳細設計 | P1-P15（全原則） | 設計判断の基準（PRIMARY） |
| §5 テスト設計 | P1, P2, P3, P11, P13 | テスト観点の導出 |
| §7 設計レビュー | P1-P15 | レビューチェックリスト |
| §8 実装計画 | P1, P3 | 実装順序の指針 |
| §9 実装 | P1-P15 | コーディングガイド |
| §10 コードレビュー | P1-P15 | レビュー基準 |

§0（前提条件チェック）、§6（Draft PR作成）、§11-§13 は設計原則の直接的な適用対象外。

---

## フェーズ別詳細

### §1 要件理解

**問題分析の視点として適用する原則**

| 原則 | アクション |
|------|---------|
| P12 目的駆動名前設計 | ユビキタス言語の整理（1-1）において、「ユーザー」「商品」のような存在ベースの汎用名を避け、「出品者」「購入者」「予約品」「発送品」のように目的・役割ベースで命名する。この段階での命名がクラス構造の骨格を決定する |
| P14 役割駆動設計 | 大規模ドメインでは、同一エンティティの異なる役割を識別する。1つの「ユーザー」が複数のユースケースで異なる振る舞いを持つ場合、要件段階で役割を分離しておく |
| P15 DRY=意図の重複 | 複数の機能要件が「意図」レベルで重複していないかを確認する。表面的に異なるユースケースが同一のビジネスルールに基づく場合、それを識別して一元管理の計画を立てる |

---

### §2 既存実装調査

**既存問題の検出基準として適用する原則**

| 原則 | 検出対象 |
|------|---------|
| P4 データクラス=低凝集 | ドメイン層にデータのみを保持しロジックが外部に散在しているクラスがないか |
| P5 副作用static排除 | 外部状態に依存する/副作用を持つstaticメソッドがないか |
| P6 デメテルの法則 | `a.getB().getC().doSomething()` のような内部構造に依存するチェーンがないか |
| P7 散在する条件分岐 | 同一条件（型判定、ステータス判定等）が複数ファイルに散在していないか |
| P10 不適切な共通化 | 目的が異なるロジックが無理に共通化されて密結合になっていないか |

**ポイント**: 調査レポートにこれらのパターンの有無を記録し、設計フェーズでの改善対象とする。ただし、既存パターンとの整合性を無視して一方的に改善を計画しない（既存パターンに合わせる判断も正当）。

---

### §3 技術・アーキテクチャ検討

**アーキテクチャ方針として適用する原則**

| 原則 | アクション |
|------|---------|
| P3 不変性優先 | アーキテクチャレベルで不変性のデフォルト方針を決定する。言語の機能（Kotlinの`val`, Javaの`final`, TypeScriptの`readonly`）を活用し、可変が必要な箇所を例外として明示する |
| P9 スーパークラス安定性 | 継承 vs コンポジションの方針を決定する。共通基盤クラスを設計する場合、サブクラスの要求で基盤が変更されない安定したインターフェースを定義する |
| P14 役割駆動設計 | モジュール・パッケージの分割において、DDDのBounded Context相当の境界を定義する。同一ドメイン概念が異なるコンテキストで異なる振る舞いを持つ場合、モジュールを分離する |

---

### §4 詳細設計（PRIMARY）

**全15原則が設計判断の基準として適用される最重要フェーズ。** 設計原則の適用優先度に基づき、以下の順序でチェックする。

#### クラス構造の設計（P1, P2, P3, P4, P12）

| 原則 | 設計判断 |
|------|---------|
| P12 目的駆動名前設計 | ドメイン層のクラス名・メソッド名を「目的」ベースで設計する。汎用的な名前（`Data`, `Info`, `Manager`, `Processor`）を避ける |
| P1 値オブジェクト | バリデーションやドメインロジックを持つ値に専用クラスを定義する。バリデーションもロジックもない値にはtype alias等の軽量手段を検討 |
| P2 完全コンストラクタ | コンストラクタで全フィールドを初期化し、不正状態のオブジェクトが存在できない設計にする。ORM/DI等の技術制約がある場合は例外を許容し理由を記録 |
| P3 不変性優先 | フィールドはデフォルトで不変。変更が必要な場合は新しいインスタンスを返すメソッドを定義 |
| P4 データクラス=低凝集 | ドメイン層のクラスが「データのみ」になっていないか確認。ロジックがあるべき場所に配置する。DTO・イベント・コマンド等のデータ転送目的クラスは除外 |

#### メソッド・依存関係の設計（P5, P6, P13）

| 原則 | 設計判断 |
|------|---------|
| P5 副作用static排除 | 副作用や外部状態依存を持つメソッドはstaticにしない。テスト容易性と差し替え可能性を確保する |
| P6 デメテルの法則 | クラスが直接知る必要のない内部構造に依存しない設計にする。中間オブジェクトの操作は委譲メソッドで隠蔽 |
| P13 CQS | メソッドを「状態変更（コマンド）」と「値取得（クエリ）」に分離する。正当な例外（アトミック操作、pop等）は設計書に理由を記録 |

#### 拡張性・構造の設計（P7, P8, P9, P10, P14, P15）

| 原則 | 設計判断 |
|------|---------|
| P7 散在する条件分岐 | 同一条件の分岐が複数箇所に散在する場合、ポリモーフィズムやパターンマッチでの構造化を検討する。単一箇所の単純な分岐はそのまま |
| P8 ファーストクラスコレクション | ビジネスルール（最大件数、重複禁止、合計値計算等）を持つコレクションに専用クラスを定義する。ビジネスルールのないコレクションはそのまま |
| P9 スーパークラス安定性 | 継承を使用する場合、サブクラスの追加でスーパークラスの変更が必要にならない設計にする |
| P10 不適切な共通化禁止 | 共通化の判断は「コードの見た目」ではなく「ビジネス上の意図」に基づく。意図が異なれば重複を許容 |
| P14 役割駆動設計 | 大規模ドメインで、1つのモデルに複数の役割が混在する場合、役割ごとにモデルを分離する |
| P15 DRY=意図の重複 | 同一の知識・意図が複数箇所に存在する場合、単一の権威ある表現に統合する |

#### null安全の設計（P11）

| 原則 | 設計判断 |
|------|---------|
| P11 null安全管理 | null可能性を型で明示する（Kotlin: `?`, Rust: `Option<T>`, TypeScript: `| null`）。型レベルでnullの可能性を管理し、実行時のnullチェック散在を防ぐ |

---

### §5 テスト設計

**テスト観点の導出に適用する原則**

| 原則 | テスト観点 |
|------|---------|
| P1 値オブジェクト | バリデーションの境界値テスト、ドメインロジックの正常系・異常系 |
| P2 完全コンストラクタ | 不正引数でのオブジェクト構築拒否テスト |
| P3 不変性 | 操作後にオリジナルオブジェクトが変化しないことのテスト |
| P11 null安全 | null/空の境界ケース、型による安全管理の検証 |
| P13 CQS | コマンドメソッドが状態を変更すること、クエリメソッドが副作用を持たないことのテスト |

---

### §7 設計レビュー（人間）

設計レビューブリーフに、以下の観点を含める:

1. **目的ベースの命名チェック**: ドメイン層のクラス名が「目的」を反映しているか（P12）
2. **過剰設計の検出**: YAGNI原則に反する先行設計がないか（P7, P8, P14の過剰適用）
3. **不適切な共通化の検出**: 意図が異なるコードの共通化がないか（P10, P15）
4. **継承設計の安定性**: サブクラス追加でスーパークラスの変更が必要にならないか（P9）

---

### §8 実装ステップ計画

**実装順序の指針として適用する原則**

| 原則 | ステップ計画への反映 |
|------|---------|
| P1 値オブジェクト | 値オブジェクトを最初のステップで実装する（他のクラスが依存する最下層） |
| P3 不変性 | 不変オブジェクトから先に実装し、可変状態を持つオブジェクトを後に実装する |

ワークフロー§8が定義する「依存関係の下流から上流へ」の方針と、設計原則の「値オブジェクト → エンティティ → サービス」の実装順序は整合する。

---

### §9 ステップ実装

**コーディングガイドとして全15原則を適用。** 実装時のセルフチェックリスト:

1. ドメイン層のクラスに「データのみ」のクラスがないか（P4）
2. フィールドは不変か、可変にする理由は記録したか（P3）
3. コンストラクタで不正状態を防いでいるか（P2）
4. 副作用を持つstaticメソッドを書いていないか（P5）
5. 内部構造に依存するメソッドチェーンがないか（P6）
6. 見た目の類似だけで共通化していないか（P10, P15）

---

### §10 コードレビュー

**Stage 2（コード品質レビュー）の変更容易性観点に以下を追加**

| 原則グループ | レビュー観点 |
|------------|---------|
| P1-P4 クラス構造 | ドメインクラスがロジックとデータを適切に凝集しているか |
| P5-P6 依存関係 | デメテルの法則違反、副作用staticの有無 |
| P7-P8 構造化 | 条件分岐の散在、コレクションのビジネスルール管理 |
| P10-P15 設計判断 | 共通化、命名、CQS、null管理の適切さ |

---

## 原則の集中度分析

15原則のうち、§4（詳細設計）に全15原則が適用される。これは、ミノ駆動氏の主張が本質的に**クラス設計レベルの原則**であり、設計フェーズが最も重要な適用ポイントであることを示す。

一方、§1（要件理解）と§3（アーキテクチャ）に適用される原則は少数であり、これらのフェーズでは別の設計知識体系（DDDの戦略設計、アーキテクチャパターン等）がより重要になる。

ワークフロー全体での適用パターン:

- **上流フェーズ（§1-§3）**: 3-5原則 — 問題の発見と方針決定
- **設計フェーズ（§4）**: 15原則 — 設計判断の基準
- **テスト・実装フェーズ（§5, §8-§9）**: 5-15原則 — 実装ガイドとテスト観点
- **レビューフェーズ（§7, §10）**: 15原則 — 検査基準
