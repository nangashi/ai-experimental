# ミノ駆動（仙塲大也）氏の「変更容易性」に関する主張 — 網羅的整理

## 前提：ミノ駆動氏にとっての「変更容易性」とは

ミノ駆動氏は、変更容易性をソフトウェア設計の最重要品質特性と位置づけている。ソフトウェアは本質的にビジネスの道具であり、ユーザーやその目的が増えたり変わったりしても、すぐに形を変えられることが事業の継続的成長を支える。変更容易性が低い構造を「技術的負債」と呼び、その解消をエンジニア人生のテーマとしている。

DDDを「ビジネスとして利益を上げ続けられるソフトウェアをつくるために、目的に合った設計をしよう」という思想と位置づけ、最優先で満たすべきは「機能性」（ユーザーの目的達成）と「変更容易性」（変化への追従）の両立であると主張している。

---

## 書籍「良いコード/悪いコードで学ぶ設計入門」章構成に沿った整理

### 第1章：悪しき構造の弊害を知覚する

- **主張**: 悪しき構造がもたらす弊害を知覚できなければ、改善の動機が生まれない
- **理由**: 仕様変更時に最も悪いコードが書かれやすい。問題を認識しなければ手を打てない
- **詳細**: 意味不明な命名、条件分岐のネスト、データクラスなど、典型的な悪い構造とその弊害（予期しないバグ、変更困難、可読性低下）をダイジェスト的に紹介。「まず理想形を知ることで、理想でないものを認識できるようになる」

---

### 第2章：設計の初歩

**2-1. 意図が伝わる名前を設計する**
- **主張**: 省略せず、意図が伝わる名前を付けるべき
- **理由**: 名前が省略されていたり意味不明だと、コードの意図が読み手に伝わらず、誤った変更が行われる
- **詳細**: 変数名・メソッド名を正確に命名することが、変更容易性の出発点

**2-2. 変数を使い回さない**
- **主張**: 目的ごとに別の変数を用意すべき
- **理由**: 一つの変数を複数の目的に使い回すと、変更時にどの目的の値なのか判別困難になり、バグを生む
- **詳細**: 再代入を避け、変数を使い分ける

**2-3. 意味のあるまとまりでメソッド化する**
- **主張**: ベタ書きせず、意味のある単位でメソッドに切り出すべき
- **理由**: ベタ書きは可読性を下げ、同じ処理の重複を招く

**2-4. 関連するデータとロジックをクラスにまとめる**
- **主張**: データとそれを操作するロジックは同じクラスに凝集させるべき
- **理由**: 分離されるとデータクラス（アンチパターン）になり、ロジックが散在して低凝集になる

---

### 第3章：クラス設計 — 成熟したクラスへ

**3-1. 値オブジェクト（Value Object）**
- **主張**: 値をプリミティブ型ではなくクラス（型）として表現すべき
- **理由**: プリミティブ型のまま扱うと、その値に関するバリデーションやロジックが散在し、低凝集になる（プリミティブ型執着）。値オブジェクトにすることで各値のロジックが高凝集になる
- **詳細**: 例えば「消費税」をintではなくConsumptionTaxクラスとして表現し、計算ロジック・バリデーションを閉じ込める

**3-2. 完全コンストラクタ（Complete Constructor）**
- **主張**: オブジェクトはnewした時点で正しく利用可能な「完全体」であるべき
- **理由**: 未初期化状態や不正な値を持つオブジェクトが生まれることを防ぐ
- **詳細**: (1) インスタンス変数をコンストラクタで全て初期化する、(2) コンストラクタ内でバリデーションする、(3) インスタンス変数にfinal修飾子を付けて不変にする。これにより不正状態のオブジェクトがそもそも存在できなくなる

**3-3. クラス設計の本質**
- **主張**: クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくり
- **理由**: 不正状態を許容する構造は、変更時にバグを生む根本原因になる

---

### 第4章：不変の活用 — 安定動作を構築する

- **主張**: 変数やオブジェクトは可能な限り不変（immutable）にすべき
- **理由**: 可変な状態は、いつどこで値が変わったか追跡困難にし、予期しない副作用を生む。不変にすることで処理にべき等性が加わり安全性が高まる
- **詳細**: (1) 変数の再代入を禁止する（final修飾子等）、(2) 可変インスタンスを作らない、(3) 値を変更したい場合は新しいインスタンスを生成して返す。不変にすることで「ある時点の値が保証される」ため、変更時の影響範囲を局所化できる

---

### 第5章：低凝集 — バラバラになったものを凝集させる

**5-1. データクラスは低凝集のアンチパターン**
- **主張**: データだけを持ちロジックを持たないクラス（データクラス）を作ってはならない
- **理由**: データとロジックが分離すると、同じデータを操作するロジックがあちこちに散在し、重複コード、修正漏れ、整合性の崩壊を招く

**5-2. staticメソッド・ユーティリティクラスの乱用を避ける**
- **主張**: staticメソッドやユーティリティクラスの安易な利用は低凝集を招く
- **理由**: データを持つインスタンスと切り離されたstatic処理は、本来そのデータクラスに持たせるべきロジックが外に漏れ出した状態

**5-3. デメテルの法則**
- **主張**: 利用するオブジェクトの内部を知るべきではない（「知らない人に話しかけるな」）
- **理由**: 内部構造に依存すると、その内部が変わったとき呼び出し元も連鎖的に変更が必要になる（密結合）

---

### 第6章：条件分岐 — 複雑さを低減するインターフェース設計

**6-1. switch文/if文の重複はインターフェースで解消する**
- **主張**: 型やフラグ、enumによる条件分岐はポリモーフィズムで置き換えるべき
- **理由**: 条件分岐が重複すると、種類が増えるたびに全ての分岐箇所を修正する必要がある。修正漏れがバグを生む
- **詳細**: interfaceを定義し、各実装クラスを作ることで、分岐をなくす。「既存ロジックにむりやりif文をねじ込む」のではなく、interface実装クラスを追加するだけで拡張できる構造を作る

**6-2. ストラテジパターン（Strategy / Policy パターン）**
- **主張**: アルゴリズムや振る舞いのバリエーションはストラテジパターンで設計すべき
- **理由**: 条件式の重複を排除し、新しいバリエーションの追加を容易にする

**6-3. interfaceの本質は「目的単位の抽象化」**
- **主張**: システムは目的達成手段であり、interfaceも目的単位で抽象化すべき。interface実装クラスは同一目的に対する達成手段のバリエーション
- **理由**: 目的を意識せずにinterfaceを設計すると、不適切な抽象化になり分岐が消えない
- **詳細**: 「作る」と「使う」を分離し、どの実装クラスを用いるかの判断はFactoryやDIコンテナに委ねる

---

### 第7章：コレクション — ネストを解消する構造化技法

**7-1. ファーストクラスコレクション**
- **主張**: コレクション（配列・リスト）とその処理ロジックは専用のクラスにカプセル化すべき
- **理由**: コレクション周りではループ処理と条件分岐が複雑に絡み合い、ロジックが散在しやすい。専用クラスに閉じ込めることで、コレクション操作が一箇所に集約され、変更・拡張が容易になる
- **詳細**: コレクションを単なるデータの集まりではなく、一つのオブジェクトとして扱い、追加・削除・検索等の操作を内部に持たせる

---

### 第8章：密結合 — 疎結合高凝集への改善

**8-1. 単一責任原則（SRP）に基づく密結合の解消**
- **主張**: 一つのクラスは一つの責任のみを持つべき
- **理由**: 複数の関心事が混在するクラスは、一方の変更が他方に影響し、変更が困難になる
- **詳細**: 単一責任原則の「責任」とは「ある単一の関心事についての正常動作に責任を負うこと」。SRP遵守にはビジネス概念の正確な把握が必須

**8-2. サブクラスの都合でスーパークラスを変更してはならない**
- **主張**: 継承関係において、子クラスの要求で親クラスを変更すべきではない
- **理由**: 他のサブクラスに予期しない影響が波及する

**8-3. 共通化してはいけないものを無理に共通化しない**
- **主張**: 目的が異なるロジックを無理に共通化すると密結合に陥り、変更容易性が低下する
- **理由**: 表面的にコードが似ていても、ビジネス上の目的が異なれば別物。共通化すると片方の変更がもう片方を壊す

---

### 第9章：null問題と例外設計

- **主張**: nullを返さない・渡さない設計にすべき
- **理由**: nullはNullPointerExceptionの原因であり、nullチェックがコード全体に散在し、可読性と変更容易性を大きく損なう
- **詳細**: 完全コンストラクタと値オブジェクトの組み合わせにより、nullが存在しえない設計にする

---

### 第10章：名前設計 — あるべき構造を見破る名前

**10-1. 目的駆動名前設計（ミノ駆動氏特有の概念）**
- **主張**: 「存在」ではなく「目的」から名前を設計すべき
- **理由**: 「商品」「ユーザー」のような存在ベースの汎用的な名前は、複数の関心事を引き寄せて巨大クラスになる。「予約品」「注文品」「出品物」「発送品」のように目的ごとに名前を分けることで、関心事ごとにクラスが分離され、疎結合・高凝集になる
- **詳細**: 名前の「設計」であり、可読性向上だけでなく、ロジック構造を大きく左右する。最適なロジック構造を導き出すための名前の付け方

**10-2. 命名のアンチパターン**
- **主張**: プログラミング用語やコンピュータ用語（Int~, Str~, ~Memory, ~Thread, ~Flag, Update~）で命名してはならない
- **理由**: ビジネスの言葉ではない命名は、ビジネス概念とコード構造の乖離を生み、変更時に意図が読み取れない
- **詳細**: ビジネスドメインに関する分析が必要で、ドメインエキスパートとの対話を通じて個別具体的な名前を引き出すべき

---

### 第11章：コメント — 保守と変更の正確性を高める書き方

- **主張**: コメントは保守と変更に役立つように正確に書くべき
- **理由**: いい加減なコメントは、読み手に正しく意図が伝わらなかったり、逆に嘘を伝えてしまう。古いコメントが残ると誤った修正の原因になる

---

### 第12章：メソッド（関数） — 良きクラスには良きメソッドあり

**12-1. コマンド・クエリ分離の原則（CQS）**
- **主張**: メソッドは「状態を変更するコマンド」か「値を返すクエリ」のどちらか一方だけを行うべき
- **理由**: 両方を同時に行うメソッドは副作用が予測困難になり、変更時にバグを生む

**12-2. メソッド設計がクラス設計に波及する**
- **主張**: メソッドの設計が良くないと、余波でクラスの設計も悪化する
- **理由**: 過大なメソッドや責任の曖昧なメソッドは、クラスの責任境界を曖昧にする

---

### 第13章：モデリング — クラス設計の土台

- **主張**: モデリングなしに良いクラス設計は生まれない。モデルがいい加減だとクラス構造が粗悪になる
- **理由**: モデルは物事の特徴や関係性を簡単に表したもので、クラス設計の土台。土台が崩れると変更が難しくなる
- **詳細**: DDDのリファクタリングを繰り返してドメインモデルを改良し、「このドメインの問題を解決するには、実はこういう構造のモデルが相応しい」と気付く瞬間（深いモデル）が訪れることが重要

---

### 第14章：リファクタリング — 既存コードを成長に導く技

- **主張**: リファクタリングの目的は「変更容易性の高い構造」を得ること。外部振る舞いを変えずに内部構造を改善する
- **理由**: 技術的負債は放置すると膨らみ続け、変更コストが指数的に増大する
- **詳細**: テストがないコードのリファクタ方法、リファクタリング時に陥りやすい罠

---

### 第15章：設計の意義と設計への向き合い方

- **主張**: 設計の品質は事業成長と直結する。設計は「やるかやらないか」ではなく「常にやるもの」
- **理由**: 設計を怠ると低凝集・密結合な構造に陥り、変更コスト増大 → 開発生産性低下 → 事業成長の阻害
- **詳細**: 設計品質のメトリクス、メトリクスをコントロールするツールの紹介。設計と会社の事業成長の関係性

---

### 第16章：設計を妨げる開発の進め方との戦い

- **主張**: 設計を妨げるのは技術だけでなく、開発プロセス・心理的要因・組織上の課題がある
- **理由**: 「設計する時間がない」「リファクタリングの価値が理解されない」等の非技術的障壁を放置すると、技術的負債が蓄積する

---

### 第17章：設計技術の理解の深め方

- **主張**: 設計スキルは継続的な学習と実践で向上させるべき
- **詳細**: 改訂新版では「カプセル化」と「関心の分離」の観点から全面的に見直しが行われた

---

## 書籍外の主張（Qiita記事・登壇資料・インタビュー等）

### 役割駆動設計（Role-Driven Design）
- **主張**: 一つのモデルに複数の役割を割り当てず、役割ごとにモデルを分割すべき
- **理由**: 「User」のような名前は売り手・買い手・管理者など複数の役割を引き寄せ、God Class化する
- **詳細**: フリマアプリの例で、Userクラスに出品者・購入者のロジックが混在する問題を、SellerクラスとBuyerクラスに分離することで解消

### 関心の分離を意識した名前設計
- **主張**: 関心事（ユースケースや目的、役割）ごとに分離し、各関心事に特化した命名をすべき
- **理由**: 巨大クラスの根本原因は、汎用的・曖昧な名前が複数の関心事を混在させること
- **詳細**: ビジネスドメインの分析とドメインエキスパートとの対話によって、個別具体的な名前を導出する

### DRY原則の正しい解釈
- **主張**: DRY原則は「コードの重複を許すな」ではなく「意図や目的の重複を許すな」
- **理由**: 表面的にコードが似ているだけで共通化すると、目的が異なるロジックが結合し、一方の変更がもう片方を壊す
- **詳細**: 「DRY原則に従って共通化しすぎるのは良くない」という言説は誤りで、目的が一致しているかが判断基準。程度の問題ではない

### リファクタリング自爆奥義集
- **主張**: リファクタリングは目的を誤ると逆効果になる
- **理由**: 「逆リファクタリング」（高品質コードを低品質化する変更）、誤った共通化、不適切な継承の導入など、善意のリファクタリングが変更容易性を悪化させるケースがある

### 設計を歪める認知バイアス
- **主張**: 認知バイアスが設計判断を歪める。バイアスを自覚することで設計判断の精度が向上する
- **理由**: プリミティブ型執着（値オブジェクトにすべきものをintやStringで済ませてしまう）、早すぎる最適化、共通化バイアス（似たコードを見ると共通化したくなる）等

### カプセル化の本質 — 目的論的抽象
- **主張**: カプセル化とは「関連し合うデータとロジックをひとまとめにして1つのモジュールを定義すること」。目的論的抽象の観点が鍵
- **理由**: カプセル化が破られると異なる関心事が混在し、整合性の維持が困難になり、変更に弱い構造になる

### Userクラスの負債化メカニズム
- **主張**: Userクラスは技術的負債の代表例。「ユーザー」という名前があらゆる概念を引き寄せる
- **理由**: メール、欲しい物、購入履歴、性別、年齢、身長、体重、血圧、体脂肪率、病歴...と無限にデータが追加され、God Class化する
- **詳細**: 役割駆動設計により、User → Seller, Buyer, Admin等に分割することで解消

### DDDと単一責任原則の接続
- **主張**: 高い変更容易性を発揮するには、エンジニア一人ひとりがビジネスを理解し、モデルに落とし込み、SRPを遵守したクラス設計を目指すことが不可欠
- **理由**: ビジネス理解が浅いと概念の違いを区別できず、多目的クラスが生まれる
- **詳細**: DDDのユビキタス言語、境界付けられたコンテキスト、ドメインエキスパートとの対話、深いモデルなどが概念分析に有用

### 技術的負債の「怨霊」と「除霊」
- **主張**: 「流用しよう」「再利用しよう」という声に惑わされるな。アプリケーションは目的特化のため、再利用できるものはほとんどない
- **理由**: 共通化できるものは「目的が同じロジック」のみ。無理に共通化すると爆発する
- **詳細**: 「流用霊」のユーモラスな表現で警告。フレームワークの上に構築されるアプリケーションコードは目的特化であり、安易な再利用は密結合を生む

### MCPサーバー「モディフィウス」（2025年〜）
- **主張**: AIエージェントと連携して変更容易性の向上をスケールさせる
- **理由**: 人手による設計改善にはスケールの限界がある。AIに変更容易性に関する思考パターンを持たせることで、技術負債の分析や設計改善提案を自動化できる
- **詳細**: 名前は「Modifiability」+「-ius」=「変化を司る者」。コアプロンプトに変更容易性に関する思考パターンが組み込まれ、モジュール構造により拡張が容易

---

## ミノ駆動氏特有の用語・概念まとめ

| 用語 | 意味 |
|------|------|
| **目的駆動名前設計** | 「存在」ではなく「目的」から名前を設計する手法。名前がロジック構造を決定する |
| **クソコード動画** | 悪い設計が招く凄惨な結末を風刺した短編動画シリーズ |
| **爆殺する** | 低凝集・密結合な構造を設計パターンで根本的に解消すること |
| **流用霊** | 安易な再利用・共通化を促す心理的バイアスを怨霊に例えた表現 |
| **逆リファクタリング** | 高品質なコードを低品質化してしまう変更 |
| **モディフィウス** | 変更容易性の向上をAIでスケールさせるMCPサーバー（Modifiability + -ius） |

---

## 核心的な設計原則の要約

ミノ駆動氏の全ての主張を貫く原則は以下に集約される：

1. **ビジネス概念の正確な把握** — SRPもDRYもDDDも、全てビジネス理解が前提
2. **目的ベースの設計** — 名前、クラス、interface、全てを「目的」単位で設計する
3. **高凝集・疎結合** — 関連するデータとロジックは凝集させ、異なる関心事は分離する
4. **不変性の確保** — 変化しない構造は安全で予測可能
5. **不正状態の構造的排除** — 完全コンストラクタ+値オブジェクト+バリデーションで、不正なオブジェクトが存在できない設計にする

---

## ソース

- [技術評論社 改訂新版](https://gihyo.jp/book/2025/978-4-297-14622-1)
- [7つのリニューアル 技術評論社](https://gihyo.jp/book/pickup/2024/0021)
- [note: 出版告知](https://note.com/minodriven/n/n12af8005899f)
- [Qiita: ValueObjectで低凝集クラスを爆殺する](https://qiita.com/MinoDriven/items/5e69d9bd028aa350e2c4)
- [Qiita: 名前設計で巨大クラスを爆殺する](https://qiita.com/MinoDriven/items/37599172b2cd27c38a33)
- [Qiita: 役割駆動設計で巨大クラスを爆殺する](https://qiita.com/MinoDriven/items/2a378a09638e234d8614)
- [Qiita: 単一責任原則で多目的クラスを爆殺する](https://qiita.com/MinoDriven/items/76307b1b066467cbfd6a)
- [Qiita: 設計を歪める認知バイアス](https://qiita.com/MinoDriven/items/8e4abda43b05cd7a0200)
- [Qiita: リファクタリング自爆奥義集](https://qiita.com/MinoDriven/items/dac5505cf8442e1721d1)
- [レバテックLAB: なぜ負債解消にDDD?](https://levtech.jp/media/article/interview/detail_369/)
- [レバテックLAB: モディフィウス開発秘話](https://levtech.jp/media/article/column/detail_759/)
- [Forkwell: 変更容易性で技術的負債を解消](https://pr.forkwell.com/tech_event_reports/deepen-good-code-bad-code/)
- [Forkwell: 分岐を低減するinterface設計](https://pr.forkwell.com/tech_event_reports/engineer-culturefes-2023-minodriven/)
- [Forkwell: エンジニア怪談](https://pr.forkwell.com/tech_event_reports/ghost-stories-of-it-engineers/)
- [Findy: ミノ駆動さんのキャリア](https://findy-code.io/engineer-lab/minodriven)
- [Speaker Deck: Userクラス](https://speakerdeck.com/minodriven/kusokododong-hua-userkurasu-dekao-eruji-shu-de-fu-zhai-jie-xiao-falseguan-dian)
- [Speaker Deck: 技術的負債の怨霊と除霊方法](https://speakerdeck.com/minodriven/ghosts-of-technical-debt)
- [Speaker Deck: interface設計と発想の転換](https://speakerdeck.com/minodriven/interface-design-idea)
- [Speaker Deck: モディフィウス](https://speakerdeck.com/minodriven/modifius)
- [ログミーTech: 全17章書籍紹介](https://logmi.jp/tech/articles/326667)
