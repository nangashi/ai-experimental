# ミノ駆動氏の主張に対する批判的評価

以下、各主張について他の著名な設計思想家の知見をもとに反論し、妥当性を評価する。

---

## 1. 値をプリミティブ型ではなくクラス（型）として表現すべき（値オブジェクト）

**主張**: 金額、メールアドレスなどをStringやintではなく専用クラスで表現すべき。

**反論**:

- **Rich Hickey（Clojure/Simple Made Easy）**: 情報をカスタムクラスで囲むことは汎用的なデータ操作を不可能にする。「ほとんどのクラスは名前付きプロパティから値への連想マップにすぎない」とし、汎用データ構造（map, set等）の使用を推奨している。値オブジェクトの過度な適用は、汎用的なデータ操作コードの再利用を阻害する。
- **John Ousterhout（A Philosophy of Software Design）**: 小さなクラスを大量に作る「classitis」症候群を批判。値オブジェクトがインターフェースの複雑さに対して十分な機能を隠蔽しない「浅いモジュール」になる危険がある。
- **Kent Beck（Simple Design第4規則「Fewest Elements」）**: 不要な構造要素を最小化せよ。バリデーションもドメインロジックもない値にまで専用クラスを作るのは、この規則に反する。
- **Kotlin/現代言語**: Kotlinの`value class`はラッパーのオーバーヘッドをコンパイル時に除去する。言語レベルで値オブジェクトのコストを下げる試みが進んでいることは、「常にクラスにすべき」ではなくコスト判断が必要であることを示唆。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: Martin Fowlerも「Primitive Obsession」をコードスメルとして認めており、ドメインロジックやバリデーションを持つ値には有効。ただし、バリデーションもビジネスルールもない値（単なるID文字列など）にまで一律適用するのは、classitisを招き、特に小規模プロジェクトやプロトタイプでは過剰。関数型言語ではtype aliasやnewtypeで軽量に同じ効果を得られるため、「クラスにすべき」という表現はOOP限定の処方箋。

---

## 2. 完全コンストラクタ — オブジェクトはnewした時点で完全体であるべき

**主張**: 不完全な状態のオブジェクトを許容しない。

**反論**:

- **GoFビルダーパターン**: 構築に多段階のステップが必要なオブジェクトでは、完全コンストラクタはパラメータが爆発する。ビルダーパターンやファクトリメソッドは、構築過程の複雑さをコンストラクタから分離するために存在する。
- **Kent Beck（Simple Design）**: テスト時に完全なオブジェクトを毎回構築するコストが高くなる場合がある。TDDの実践では、テストに必要最小限のオブジェクトを構築する柔軟性が求められる。
- **実務的制約**: ORMのリフレクションベースのオブジェクト構築や、デシリアライズ（JSON, Protocol Buffers等）では、引数なしコンストラクタが技術的に必要になることが多い。完全コンストラクタ原則と技術基盤の制約は常に両立するわけではない。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: 「不完全な状態のオブジェクトが存在しうる」ことがバグの温床になるのは事実であり、DDDのエンティティ/値オブジェクト設計でも整合性の保証は重要視される。Eric Evansもアグリゲートの不変条件維持を重視している。しかし、フレームワークの技術制約（ORM、DI）やビルダーパターンの存在は、この原則の一律適用に限界があることを示す。「原則として目指すべきだが、技術的制約による例外は許容する」が現実的な立場。

---

## 3. 不変（immutable）を優先すべき

**主張**: 可変状態を避け、不変オブジェクトを優先する。

**反論**:

- **Rich Hickey（Simple Made Easy）**: Hickeyは可変状態の危険性をミノ駆動氏以上に徹底的に主張しており、「状態は値と時間を絡み合わせる（complect）」としている。Clojureは不変性を言語の根幹に据えている。この点ではむしろ支持的。
- **性能とメモリの現実**: 大量データのバッチ処理やゲームエンジンなど、性能が最優先の領域では可変データ構造が不可避。構造共有（structural sharing）で緩和できるが、すべての場面で不変性が最適ではない。
- **Go言語の設計思想**: Goは値型とポインタ型を明示的に使い分け、「不変性」を言語レベルで強制しない設計を選んだ。これはシンプルさを優先した結果であり、不変性の一律強制が常に最適ではないことを示す。

**妥当性評価**: ◎（妥当）

**評価理由**: 不変性の優先は、関数型プログラミング、Rich Hickey、Eric Evans（値オブジェクトの不変性）、Joshua Bloch（Effective Java）など、ほぼ全ての設計思想家が支持する数少ない合意点。並行処理の安全性、予測可能性、デバッグ容易性のいずれにおいても優位。パフォーマンスが問題になる局所的な場面で例外を許容する点を除けば、「デフォルトとして不変を選ぶ」は広く妥当。

---

## 4. データクラスは低凝集のアンチパターン

**主張**: データだけを持ちロジックを持たないクラスはアンチパターンである。

**反論**:

- **Rich Hickey（Data-Oriented Programming）**: Hickeyの立場はこれと正反対。「データに何も問題はない。データは偉大な特性を持っており、ファーストクラスの存在であるべき」と主張。データとロジックを結合することこそが、汎用的なデータ操作を不可能にする。
- **Kotlin/Java Record/関数型言語**: Kotlinの`data class`、Java 16の`record`、Haskellの代数的データ型は、データ構造を明示的に表現するための言語機能として設計されている。これらの言語設計者は、データの表現とロジックの分離を積極的に支援している。
- **Martin Fowler**: Fowlerの「Refactoring」ではData Classをコードスメルとして挙げているが、それはリファクタリングの出発点としてであり、「常に悪」とは言っていない。DTOやイベント、コマンドなどの用途では、データのみを持つクラスは正当な設計パターンである。
- **関数型プログラミング全般**: 関数型パラダイムでは、データ（代数的データ型）と関数（データを変換するもの）の分離が基本原則。「データクラスは低凝集」という主張はOOPの凝集度の定義に依存しており、パラダイムを越えて一般化できない。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: OOPにおいて「ロジックがあるべき場所にない」ことを指摘するヒューリスティックとしては有用。しかし、DTO、イベント、コマンド、APIレスポンスなど、データの表現が目的のクラスは正当に存在する。また関数型パラダイムではデータとロジックの分離が設計原則であり、「データクラス=アンチパターン」はOOP内部でも一般化しすぎている。現代言語がrecord/data classを公式機能として提供していることが、この主張の普遍性に対する最も強い反証。

---

## 5. 条件分岐はポリモーフィズムで置き換えるべき

**主張**: if/switchをポリモーフィズムで置き換え、条件分岐を排除すべき。

**反論**:

- **Martin Fowler（Refactoring）**: 「Replace Conditional with Polymorphism」をリファクタリング技法として紹介しているが、すべての条件分岐に適用すべきとは言っていない。条件が複数のメソッドに散在している場合に有効とする。
- **現代言語のパターンマッチング**: Kotlin/Scala/Rustのsealed class + when/match式は、ポリモーフィズムとは異なるアプローチで網羅的な条件分岐をコンパイル時に検証する。条件分岐をポリモーフィズムに置き換えなくても安全性を確保できる。
- **Expression Problem**: ポリモーフィズムに置き換えると、新しいメソッド（振る舞い）を追加するには全サブクラスを修正する必要がある。条件分岐のほうが変更容易な場合もある。
- **John Ousterhout**: 大量の小さなクラスを生むことはclassitis。単純なif文1つのためにクラス階層を作るのは浅いモジュールの典型。
- **Dan Abramov（Goodbye, Clean Code）**: 「コードは要件変更能力と引き換えに重複を削減することがある。それは良いトレードではない」。ポリモーフィズムによる抽象化が将来の変更を逆に困難にすることがある。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: 同一条件の分岐が複数箇所に散在している場合は有効な技法。しかし「条件分岐はポリモーフィズムで置き換えるべき」という一般化は危険。単一箇所の単純な分岐、型の追加より振る舞いの追加が頻繁な場合、パターンマッチングが使える言語環境では、ポリモーフィズムへの置換が過剰設計になる。Expression Problemの存在が、この手法の万能性を否定する。

---

## 6. ストラテジパターンで振る舞いのバリエーションを設計すべき

**主張**: 振る舞いの違いはストラテジパターンで設計する。

**反論**:

- **YAGNI（Kent Beck/Martin Fowler）**: 将来のバリエーションを先回りして設計するのはYAGNI違反。Kent Beckは「今日のシンプルな問題に対して精巧な解決策を提案する」ことを批判した。バリエーションが実際に必要になったときに導入すべき。
- **Sandi Metz（99 Bottles of OOP）**: 「十分な情報がない段階で抽象化を推測するのではなく、Shameless Green（恥知らずに直接的な実装）から始めよ」。ストラテジパターンの先行導入は、しばしば間違った抽象の温床になる。
- **Go言語の設計思想**: Goは関数を第一級オブジェクトとして扱えるため、ストラテジパターンはクラスではなく関数の注入で実現される。パターンの本質（振る舞いの差し替え）は重要だが、クラスベースのパターンとして定式化する必要は言語に依存する。
- **現代言語の関数型機能**: ラムダ式、高階関数、関数型インターフェース（Java 8+のFunction<T,R>等）により、ストラテジパターンの意図は専用クラスなしで実現可能。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: 振る舞いのバリエーションを整理する思考ツールとしては有用。しかし「設計すべき」という処方は、バリエーションが2つ以上実際に存在する場合に限定すべき。現代言語では関数の注入で同じ目的を達成でき、クラスベースのストラテジパターンを常に使う必要はない。YAGNIの観点からも、1つしかバリエーションがない段階での導入は過剰。

---

## 7. ファーストクラスコレクション — コレクションは専用クラスにカプセル化すべき

**主張**: List<Order>のようなコレクションを直接扱わず、専用クラスで包むべき。

**反論**:

- **Rich Hickey**: コレクションを専用クラスで包むことは汎用的なデータ操作を不可能にする。mapやfilterなどの標準操作がそのまま使えなくなり、委譲メソッドの増殖を招く。
- **John Ousterhout**: インターフェースの複雑さに対して隠蔽する複雑さが少ない「浅いモジュール」になりやすい。ビジネスルールを持たないコレクションのラッパーは、classitisの典型例。
- **Enterprise Craftsmanshipの分析**: 「コレクションに追加のビジネスルールや不変条件がある場合のみ、カスタムコレクションクラスの作成を検討すべき。そうでなければ単にコストに見合わない」。
- **Kotlin/Java Stream API**: 拡張関数やStream APIにより、コレクション操作のドメインロジックはラッパークラスなしでも表現力豊かに記述できる。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: コレクションにビジネスルール（最大件数制約、要素の重複禁止、合計値の計算等）がある場合は正当な手法であり、DDDのアグリゲート設計とも整合する。しかし、ビジネスルールのないコレクションにまで一律適用すると、浅いラッパークラスが増殖し、標準APIの利便性を失う。コストと効果のバランスを個別に判断すべき。

---

## 8. 「存在」ではなく「目的」から名前を設計すべき（目的駆動名前設計）

**主張**: 技術的な「何であるか」ではなく、ビジネス上の「何のためか」で命名する。

**反論**:

- **Eric Evans（DDD/ユビキタス言語）**: Evansの「ユビキタス言語」はドメインの概念に基づく命名を推奨しており、ミノ駆動氏の主張と方向性が一致する。ただしEvansは「命名はドメインエキスパートとの対話から生まれるべき」としており、開発者が独自に「目的」を定義する危険性を暗示している。
- **Martin Fowler（Refactoring）**: 「意図を明らかにする命名（Intention Revealing Name）」は広く支持されるリファクタリング技法。
- **Kent Beck（Simple Design第2規則「Reveals Intention」）**: コードが意図を明らかにすべきという点で一致。
- **実務的な限界**: インフラ層やフレームワーク連携のコードでは、技術的な命名（`UserRepository`, `HttpClient`）が適切な場合がある。すべてのレイヤーで「目的駆動」にすると、かえって技術的な実装の意図が隠れる。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: ドメイン層における命名原則としては、Evans, Fowler, Beckのいずれとも整合し、妥当性が高い。ただし「すべての名前を目的から設計すべき」と一般化すると、インフラ層や技術的なユーティリティでは不自然になる。レイヤーに応じた命名戦略の使い分けが必要。

---

## 9. DRY原則は「コードの重複」ではなく「意図の重複」を禁止する

**主張**: DRYはコードの見た目の重複ではなく、知識・意図の重複を排除すべき。

**反論**:

- **Dave Thomas & Andy Hunt（The Pragmatic Programmer — DRY原則の原典著者）**: 原典の定義は「Every piece of knowledge must have a single, unambiguous, authoritative representation within a system」。ミノ駆動氏の「意図の重複」という解釈は原典の趣旨と完全に合致している。
- **Sandi Metz**: 「Duplication is far cheaper than the wrong abstraction（重複は間違った抽象より遥かに安い）」。意図が同じかどうかの判断を誤ると、間違った共通化を招く。意図の重複を正しく見極めるのは容易ではない。
- **Dan Abramov（The Wet Codebase）**: 重複除去への執着が、将来の要件変更能力を犠牲にする場合がある。「意図の重複」を排除すべきという原則自体は正しいが、早すぎる段階で「意図が同じ」と判断するリスクがある。

**妥当性評価**: ◎（妥当）

**評価理由**: DRY原典の著者の定義と完全に一致しており、この解釈自体の妥当性に疑問の余地はない。業界で広く誤解されている「コードの見た目の重複を排除せよ」という俗流DRYに対する重要な修正である。ただし実践面では、「意図が同じかどうか」の判断はしばしば困難であり、Sandi Metzの「間違った抽象より重複のほうが安い」という補足原則と組み合わせるべき。

---

## 10. nullを返さない・渡さない設計にすべき

**主張**: nullを使わず、Optional/Null Objectパターン等で代替すべき。

**反論**:

- **Martin Fowler（Special Case Pattern）**: Fowlerは「nullを返す代わりにSpecial Caseオブジェクトを返す」ことを推奨しており、方向性は一致。
- **Robert C. Martin（Clean Code）**: null参照に対する防御的プログラミングの必要性を説き、nullを返さない設計を推奨。
- **Tony Hoare**: null参照を発明した本人が「10億ドルの過ち」と呼んだ。
- **Kotlin/Rustなど現代言語**: 型システムレベルでnull安全を保証する言語では、nullは型として明示的に管理される（Kotlin: `String?`、Rust: `Option<T>`）。これらの言語ではnullの問題は型チェッカーが解決するため、「nullを使わない」よりも「nullを型で管理する」が正確な処方箋。
- **パフォーマンスとシンプルさ**: Go言語では、nilは正常系を表す重要な値（error戻り値パターン）。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: null安全を目指すべきという方向性は広く合意がある。ただし「nullを使わない」と「nullを安全に管理する」は異なる。Kotlinの`?`型やRustの`Option<T>`は、nullを排除するのではなく型システムで制御するアプローチ。処方箋は「nullを返さない」よりも「null可能性を型で明示する」のほうが現代的かつ正確。

---

## 11. コマンド・クエリ分離の原則（CQS）を守るべき

**主張**: メソッドは状態変更（コマンド）か値の取得（クエリ）のどちらかに限定すべき。

**反論**:

- **Martin Fowler**: CQSを「非常に有用な原則」としつつも、`stack.pop()`のように「クエリとコマンドを一体にしたほうが著しく便利な場合がある」と認めている。
- **並行処理における問題**: CQSに厳密に従うと、「値を確認してから変更する」操作がアトミックでなくなる。`compareAndSwap`、`getAndIncrement`、`putIfAbsent`などのアトミック操作はCQSに違反するが、並行プログラミングでは不可欠。
- **実用的なコスト**: CQSを厳密に守ると、1つのメソッドを2つに分割し、呼び出し側の複雑さが増す場合がある。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: APIの理解しやすさを向上させる有用な指針であり、Bertrand Meyerの原典以来広く支持されている。しかし「守るべき」という表現は強すぎる。並行処理のアトミック操作、pop()のような自然なAPI、パフォーマンス上の理由など、正当な例外が多数存在する。「デフォルトとして意識すべきガイドライン」が適切な位置づけ。

---

## 12. 共通化できるのは目的が同じロジックのみ。安易な再利用は密結合を生む

**主張**: コードの見た目が似ていても、目的が異なるなら共通化すべきでない。

**反論**:

- **Sandi Metz（The Wrong Abstraction）**: 「間違った抽象は重複より遥かにコストが高い」。ミノ駆動氏の主張はMetzの洞察と完全に一致する。
- **Dan Abramov（Goodbye, Clean Code）**: 「同僚のコードの重複を排除した結果、将来の要件変更が困難になった」という実体験を紹介し、目的の異なるコードの安易な共通化を戒めている。
- **Dave Thomas & Andy Hunt**: DRY原則の原典著者自身が、DRYは「知識の重複」を排除する原則であり、見た目の類似に基づく共通化ではないと明言。
- **反論の余地**: ただし「目的が同じかどうか」の判断基準が曖昧になりがち。チーム内で「目的」の定義が共有されていない場合、この原則は実務で適用困難になる。

**妥当性評価**: ◎（妥当）

**評価理由**: Metz, Abramov, DRY原典のいずれもこの主張を強く支持している。安易な共通化が密結合を生むという指摘は、多くの実務者が経験的に知る真実である。「目的が同じかどうか」の判断が難しいという実践的課題はあるが、原則自体の妥当性は高い。

---

## 13. 役割駆動設計 — 一つのモデルに複数の役割を割り当てず、役割ごとにモデルを分割すべき

**主張**: 例えば「User」に購入者・出品者・管理者の役割を混ぜず、それぞれ別モデルにすべき。

**反論**:

- **Eric Evans（DDD/Bounded Context）**: Evansは「大規模システムで単一の統一モデルを持つことに反対」し、Bounded Contextごとに異なるモデルを持つことを推奨。方向性は一致。
- **John Ousterhout（Deep Modules）**: 過度な分割は浅いモジュールの増殖を招く。役割ごとにモデルを分割すると、共通のデータ（氏名、メールアドレス等）の管理が複雑化し、同期問題が発生する。
- **小規模プロジェクトでのコスト**: CRUDアプリやマイクロサービスの1サービスでは、1つのUserモデルで十分な場合がほとんど。役割ごとの分割は、ドメインの複雑さがそれを正当化するレベルに達してから行うべき。
- **YAGNI**: 将来のための役割分割は、実際にその複雑さが発生するまで延期すべき。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: DDDのBounded Contextの考え方として、大規模ドメインでは有効な設計指針。しかし「常に分割すべき」は過剰。役割間で共有するデータが多い場合、分割のコスト（データ同期、変換ロジック）が利益を上回る。プロジェクト規模とドメインの複雑さに応じた判断が必要。

---

## 14. staticメソッド・ユーティリティクラスの安易な利用は低凝集を招く

**主張**: staticメソッドやユーティリティクラスは避けるべき。

**反論**:

- **Martin Fowler**: staticメソッドの主な問題はポリモーフィズムが使えないこと（テスト時のスタブ差し替え困難）と指摘。ただしこれは「将来ポリモーフィックな振る舞いが必要になる可能性がある場合」に限定。
- **関数型プログラミング**: 関数型言語では、すべての関数はstatic（インスタンスに紐づかない）。純粋関数は副作用がなく、テスト容易性が高い。
- **Go言語**: Goにはクラスもstaticメソッドもない。パッケージレベルの関数が標準であり、これはGo言語の設計思想における「シンプルさ」の体現。
- **Robert C. Martin**: 「その関数がポリモーフィックである可能性がない場合」はstaticメソッドが適切としている。`Math.max()`のような純粋な計算は、staticメソッドとして完全に正当。

**妥当性評価**: △（文脈依存で一般化は危険）

**評価理由**: 「安易な利用」への警告は妥当だが、staticメソッド自体を悪とする見方はOOP偏重。純粋関数としてのstaticメソッド（副作用なし、外部状態非依存）は、テスト容易性・理解容易性ともに高い。批判すべきは「staticメソッドに隠された副作用や外部依存」であって、staticメソッドそのものではない。

---

## 15. 変更容易性はソフトウェア設計の最重要品質特性である

**主張**: ソフトウェア設計において変更容易性が最も重要。

**反論**:

- **John Ousterhout（A Philosophy of Software Design）**: 「複雑さの最小化」を最重要目標としている。変更容易性は複雑さが低い結果として得られるものであり、それ自体を直接の目標にすると、将来の変更に備えた過剰な抽象化（YAGNI違反）を招く可能性がある。
- **Kent Beck（Simple Design）**: Beckの4規則は「テストが通る」「意図を明らかにする」「重複がない」「要素が最小」。変更容易性は明示的に最上位に置かれていない。「良い設計に従えば変更容易性は自然に得られる」に近い立場。
- **Rich Hickey（Simple Made Easy）**: Hickeyは「Simple（単純）」と「Easy（簡単）」を区別し、Simpleを追求すべきとした。変更容易性は「Easy」の範疇に入りうるが、Simpleでないシステムに変更容易性を後付けすることはできない。根本的にはSimplicityが先行する。
- **文脈依存性**: 組み込みシステム、リアルタイムシステム、セキュリティクリティカルなシステムでは、性能、信頼性、セキュリティが変更容易性より優先される場合が明確にある。
- **Dan Abramov**: 変更容易性を目指した過度な抽象化が、かえって「異なる方向への変更」を困難にする事例を具体的に示している。

**妥当性評価**: ○（概ね妥当だが条件付き）

**評価理由**: ビジネスアプリケーション開発において変更容易性が極めて重要であることは広く認められている。しかし「最重要」とする断定は2つの問題を孕む。第一に、変更容易性は複雑さの最小化やシンプルさの結果であり、直接追求すると「将来の変更のための過剰設計」に陥る。第二に、ドメインによっては性能・安全性・セキュリティが明確に優先される。「ビジネスアプリケーションにおいて最も重要な品質特性の一つ」が正確な表現。

---

## 総合まとめ

| # | 主張 | 評価 | 核心的な論点 |
|---|------|------|-------------|
| 1 | 値オブジェクト | ○ | ドメインロジックがある場合は有効。一律適用はclassitis |
| 2 | 完全コンストラクタ | ○ | 原則として妥当。ORM/ビルダー等の技術制約で例外あり |
| 3 | 不変性優先 | ◎ | ほぼ全思想家が支持する稀有な合意点 |
| 4 | データクラス=低凝集（ドメイン層限定） | ○修正 | ドメイン層でロジックがあるべき場所にない場合の指標。DTO・イベント等は正当 |
| 5 | 散在する条件分岐→ポリモーフィズム | ○修正 | 同一条件が複数箇所に散在する場合に限定。単一箇所の分岐には適用しない |
| ~~6~~ | ~~ストラテジパターン推奨~~ | 除外 | AI指示としての設計改善寄与が低い（YAGNI違反リスク、関数注入で代替可能） |
| 7 | ファーストクラスコレクション（ビジネスルール有） | ○修正 | ビジネスルール（最大件数、重複禁止等）がある場合のみ正当化 |
| 8 | 目的駆動名前設計 | ○ | ドメイン層では妥当。インフラ層には不適 |
| 9 | DRY=意図の重複禁止 | ◎ | 原典と完全一致。正しい理解の普及として価値が高い |
| 10 | null可能性の型による安全管理 | ○ | 「使わない」ではなく「型で管理する」が現代的処方箋 |
| 11 | CQS（デフォルト原則） | ○ | 有用な指針だが、正当な例外が多数存在 |
| 12 | 目的が同じ場合のみ共通化 | ◎ | Metz, Abramov, DRY原典が強く支持 |
| 13 | 役割駆動設計（大規模ドメイン限定） | ○修正 | DDDのBounded Context相当。大規模ドメインでのみ適用 |
| 14 | 副作用を持つstaticメソッドの排除 | ○修正 | 純粋関数のstaticは正当。副作用・外部依存を持つstaticが問題 |
| ~~15~~ | ~~変更容易性=最重要~~ | 除外 | メタ原則であり具体的なAI指示にならない |

### 全体的な所見

ミノ駆動氏の主張は、Java/OOPの大規模ビジネスアプリケーション開発という文脈では多くが妥当である。しかし、以下の構造的バイアスが存在する。

1. **OOPパラダイムへの偏り**: 関数型プログラミング、データ指向設計の知見が反映されていない。特に主張4（データクラス）と主張14（static排除）はFP観点と直接矛盾する。

2. **規模・成熟度の前提が暗黙的**: 多くの主張は「一定規模以上の長期運用プロジェクト」を暗黙の前提としているが、その条件が明示されていない。プロトタイプ、小規模ツール、スクリプトには過剰適用のリスクがある。

3. **「べき」という処方の強さ**: Kent Beckの「Fewest Elements」、Sandi Metzの「Shameless Green」、Dan Abramovの「Goodbye, Clean Code」が共通して警告する「過剰な構造化」のリスクが、ミノ駆動氏の処方箋に潜んでいる。原則を知った上で、YAGNIとのバランスを取ることが実践上は最も重要。

---

## 更新記録

### △評価項目の修正（per-item承認済み）

以下の6項目について修正案が承認され、適用条件を限定した上で評価を変更:

- **#4** データクラス=低凝集 → ドメイン層限定。DTO・イベント等は正当なデータクラスとして除外（○修正）
- **#5** 条件分岐→ポリモーフィズム → 同一条件が複数箇所に散在する場合に限定（○修正）
- **#6** ストラテジパターン推奨 → 除外（AI指示として効果が低い。P5/P7でカバー）
- **#7** ファーストクラスコレクション → ビジネスルールがある場合のみ（○修正）
- **#13** 役割駆動設計 → 大規模ドメイン限定（○修正）
- **#14** static排除 → 副作用を持つstaticメソッドの排除に限定（○修正）

### AI指示としての設計改善寄与によるフィルタリング

以下の除外基準でフィルタリングし、元の主張集 → 15項目に絞り込み:

- **A: 行動指示に変換不能** — 抽象的すぎてAIへの具体的指示にならない
- **B: 検証不能** — 適用結果の良し悪しをAIが判定できない
- **C: AIのデフォルト動作からのデルタがない** — 指示しなくてもAIが自然に行う
- **D: 他項目と重複** — 別の原則でカバーされている

除外された代表的な項目:
- ストラテジパターン推奨（A: YAGNIとの判断が困難、D: P7でカバー）
- 変更容易性=最重要（A: メタ原則で行動指示に変換不能）
- 設計の意義・設計への向き合い方（B: 検証不能な心構え）

### 追加項目（主張集から残存）

批判的評価には含めなかったが、AI指示として有効と判断した2項目を追加:

- **デメテルの法則** — 内部構造への依存を制限。具体的な検出基準（メソッドチェーンの段数）がありAIに指示可能
- **サブクラスの都合でスーパークラス変更禁止** — 継承設計の安定性ルール。違反検出が明確

### 最終的な15項目

03-workflow-mapping.md で使用する設計原則の最終リスト:

| # | 原則 | 適用条件 |
|---|------|---------|
| P1 | 値オブジェクト | ドメインロジック・バリデーションがある場合 |
| P2 | 完全コンストラクタ | 原則。技術制約（ORM, DI等）で例外あり |
| P3 | 不変性優先 | デフォルト方針 |
| P4 | データクラス=低凝集 | ドメイン層限定。DTO・イベント等は正当 |
| P5 | 副作用を持つstaticメソッドの排除 | 副作用・外部依存を持つstaticが対象 |
| P6 | デメテルの法則 | 内部構造への依存を制限 |
| P7 | 散在する条件分岐→ポリモーフィズム | 同一条件が複数箇所に散在する場合 |
| P8 | ファーストクラスコレクション | ビジネスルール（件数制約、重複禁止等）がある場合 |
| P9 | サブクラスの都合でスーパークラス変更禁止 | 継承関係の安定性 |
| P10 | 目的が異なるものを共通化しない | 見た目の類似ではなく意図の一致で判断 |
| P11 | null可能性の型による安全管理 | 型システムでnullを管理 |
| P12 | 目的駆動名前設計 | ドメイン層。インフラ層は技術的命名が適切 |
| P13 | CQS | デフォルト原則。アトミック操作等の正当な例外あり |
| P14 | 役割駆動設計 | 大規模ドメインでBounded Contextレベルの分割が必要な場合 |
| P15 | DRY=意図の重複禁止 | コードの見た目ではなく「意図・知識」の重複を排除 |

---

## ソース

- [Martin Fowler - Value Object](https://www.martinfowler.com/bliki/ValueObject.html)
- [Martin Fowler - Beck Design Rules](https://martinfowler.com/bliki/BeckDesignRules.html)
- [Martin Fowler - YAGNI](https://martinfowler.com/bliki/Yagni.html)
- [Martin Fowler - Bounded Context](https://martinfowler.com/bliki/BoundedContext.html)
- [Martin Fowler - Command Query Separation](https://martinfowler.com/bliki/CommandQuerySeparation.html)
- [Martin Fowler - Static Substitution](https://martinfowler.com/bliki/StaticSubstitution.html)
- [Martin Fowler - Special Case Pattern](https://martinfowler.com/eaaCatalog/specialCase.html)
- [Dan Abramov - Goodbye, Clean Code](https://overreacted.io/goodbye-clean-code/)
- [Dan Abramov - The Wet Codebase](https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase)
- [Sandi Metz - The Wrong Abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)
- [Sandi Metz - 99 Bottles of OOP](https://sandimetz.com/99bottles-sample-ruby)
- [Rich Hickey - Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/)
- [Rich Hickey Interview](https://harfangk.github.io/2017/12/08/rich-hickey-interview-from-codequarterly.html)
- [John Ousterhout - A Philosophy of Software Design (Review)](https://blog.pragmaticengineer.com/a-philosophy-of-software-design-review/)
- [Pragmatic Programmer - DRY Extract](https://media.pragprog.com/titles/tpp20/dry.pdf)
- [Refactoring Guru - Replace Conditional with Polymorphism](https://refactoring.guru/replace-conditional-with-polymorphism)
- [Kotlin Data Classes](https://kotlinlang.org/docs/data-classes.html)
- [Kotlin Inline Value Classes](https://kotlinlang.org/docs/inline-classes.html)
- [Enterprise Craftsmanship - Collections and Primitive Obsession](https://enterprisecraftsmanship.com/posts/collections-primitive-obsession/)
