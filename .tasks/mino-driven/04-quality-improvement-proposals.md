# 品質向上ステップの提案

ミノ駆動氏の設計原則（03-workflow-mapping.md で定義したP1-P15）をAI駆動開発ワークフローで実効的に機能させるために、「AIの挙動特性」と「プロンプトエンジニアリングの知見」を踏まえた品質向上ステップを提案する。

---

## 前提知識

### AIの挙動特性

| 特性 | 説明 | 関連する設計原則 |
|------|------|---------------|
| 抽象化肥大 | 100行で十分な処理に1,000行を生成。関数で済むところにクラス階層を構築 | P7, P8, P14の過剰適用リスク |
| デッドコード蓄積 | 古い実装を残したまま新しい実装を追加。コード重複が人間の4倍 | P15（DRY）の形骸化 |
| 仮定伝播 | 序盤の誤った仮定が蓄積し、仮定に整合的なテストも生成される | P12（目的駆動名前設計）での命名判断ミス |
| コードチャーン | 書いた直後に修正・書き直しされるコードの割合増加 | 設計原則の理解不足による手戻り |
| 過剰PR | AI生成PRの67.3%が却下（手動の15.6%） | 設計原則の過剰適用による変更肥大化 |

### プロンプトエンジニアリングの知見（活用する手法）

| 手法 | 効果 | 適用場面 |
|------|------|---------|
| カテゴリ別分解 | 安定性最高（SD=0.0） | レビュー観点の構造化 |
| 理由付き指示 | 汎化促進 | 設計原則の指示 |
| 過剰構造化の回避 | 軽量ヒント2件が最適 | チェックリストの制限 |
| 批判的評価フレーミング | sycophancy対抗 | セルフレビュー |
| セルフレビュー視点転換 | 自己選好バイアス対抗 | コードレビュー |
| コンテキスト改善優先 | 改善の85%はコンテキストで達成 | 全フェーズ |
| 早期解決試行の抑制 | 仮定蓄積防止 | 要件理解 |

---

## フェーズ別の品質向上ステップ提案

### §1 要件理解

#### 追加ステップ: 目的ベース用語定義の明示的検証

**問題**: AIは存在ベースの汎用名（「ユーザー」「商品」）をそのまま受け入れ、要件を構造化する傾向がある。命名が設計構造を決定するにもかかわらず、この段階で命名の適切さが検証されない。

**提案**:
- ユビキタス言語の整理（1-1）において、各ドメイン用語に対して「この名前は何の目的を表しているか？」を明示的に問う
- 存在ベースの命名（「ユーザー」「注文」）が出現した場合、「この文脈での役割は何か？」と再質問する

**プロンプト知見の活用**:
- 「早期解決試行の抑制」: 用語定義が確定するまで、クラス構造の仮定を置かない
- 「理由付き指示」: 「目的ベースの命名は、後工程のクラス設計でGod Class化を防ぐため」

---

### §2 既存実装調査

#### 追加ステップ: 設計原則ベースの既存問題スキャン

**問題**: AIの調査は既存パターンの「把握」に偏り、既存パターンの「問題」の検出が弱い。既存コードのアンチパターンをそのまま踏襲するリスクがある。

**提案**:
調査レポート（2-2）に以下の検出項目を追加する:

1. **ドメイン層のデータクラス検出**: フィールドのみでメソッドが少ないドメインクラスを列挙（P4）
2. **副作用staticの検出**: 外部状態に依存するstaticメソッドを列挙（P5）
3. **法則違反チェーン検出**: 3段階以上のメソッドチェーンを列挙（P6）
4. **条件分岐の散在検出**: 同一条件が出現するファイルを列挙（P7）
5. **不適切な共通化検出**: utilやcommonパッケージ内の過度に汎用的なコードを列挙（P10）

**プロンプト知見の活用**:
- 「カテゴリ別分解」: 検出を上記5カテゴリに分解し、各カテゴリを独立して実行
- 「批判的評価フレーミング」: 「既存パターンを批判的に評価し、踏襲すべきものと改善すべきものを区別する」

**注意**: 検出された問題は§4の設計時に「改善対象として検討する」ためのインプットであり、すべてを改善する必要はない。既存コードとの整合性維持が優先される場合もある。

---

### §3 技術・アーキテクチャ検討

#### 追加ステップ: 不変性・継承方針の明示的決定

**問題**: AIは技術選定に注力するが、「不変性をデフォルトにするか」「継承とコンポジションのどちらを優先するか」などのアーキテクチャレベルの設計方針が暗黙のまま§4に進むことがある。

**提案**:
技術・アーキテクチャ検討（3-2）に以下の方針決定を追加する:

1. **不変性方針**: 言語の不変性サポート機能の利用方針を決定（P3）
2. **継承方針**: 継承の利用条件とコンポジション優先の方針を決定（P9）
3. **モジュール境界**: 大規模ドメインでは、役割ベースのモジュール分割を検討（P14）

---

### §4 詳細設計

#### 追加ステップ: 設計原則の適用度チェック（過剰適用 / 適用漏れ）

**問題**: AIは設計原則を「知っている」が、適用の判断が極端になりやすい。全ての値をオブジェクトにする（過剰適用）か、全くオブジェクトにしない（無適用）かの二極になる傾向がある。

**提案**:
設計レビュー（4-6）の変更容易性観点に、以下の2つのチェックを追加する:

1. **過剰適用チェック**: 設計原則を適用した箇所について、「この適用は現時点で必要か、それとも将来の変更に備えた先行投資か？」を検証。先行投資の場合、YAGNI原則に照らして正当化理由を記録する
2. **適用漏れチェック**: ドメイン層のクラスについて以下を確認:
   - バリデーションやドメインロジックがある値がプリミティブ型のままになっていないか（P1）
   - データのみのドメインクラスにロジックが必要ではないか（P4）
   - null可能性が型で明示されているか（P11）

**プロンプト知見の活用**:
- 「過剰構造化の回避」: チェック項目は上記2点に絞る。チェックリストを拡大しない
- 「理由付き指示」: 各原則の適用条件を「なぜなら〜」の形で指示に含める

**AIの抽象化肥大への対策**:
- 設計レビューに「設計がYAGNIに反していないか」の観点を明示的に含める
- 値オブジェクト、ファーストクラスコレクション、ポリモーフィズムの導入は、それぞれの適用条件（バリデーション有、ビジネスルール有、条件散在）を満たす場合のみ

---

### §5 テスト設計

#### 追加ステップ: 設計原則に基づくテスト観点の導出

**問題**: AIのテスト設計は実装ベース（実装を見てテストを書く）に偏り、設計原則から導出されるべきテスト観点が漏れる。

**提案**:
テストケース設計（5-2）の観点に以下を追加する:

1. **値オブジェクトのバリデーションテスト**: 値オブジェクトが存在する場合、バリデーション境界値のテストを必須とする（P1）
2. **完全コンストラクタの不正状態拒否テスト**: 不正引数でオブジェクト構築が拒否されることのテスト（P2）
3. **不変性保証テスト**: 操作後にオリジナルオブジェクトが変化しないことのテスト（P3）
4. **CQSテスト**: コマンドメソッドが副作用を持ち、クエリメソッドが副作用を持たないことのテスト（P13）

---

### §8 実装ステップ計画

#### 追加ステップ: 設計原則に基づく実装順序の検証

**問題**: AIはステップ分割時にファイル単位で分割する傾向があり、ドメインモデルの依存構造に基づく分割が弱い。

**提案**:
ステップ分割（8-2）において、以下の順序制約を明示する:

1. 値オブジェクト → エンティティ → ドメインサービスの順で実装（P1の依存構造）
2. 不変オブジェクトを先に、可変オブジェクトを後に（P3の依存構造）
3. ベースクラス/インターフェースを先に、実装クラスを後に（P9の安定性）

---

### §9 ステップ実装

#### 追加ステップ: デッドコード・隣接変更の明示的チェック

**問題**: AIは新しい実装を追加する際、古い実装を削除し忘れる（デッドコード蓄積）。また、タスク近傍のコードを「ついでに」変更する（隣接コード改変）。

**提案**:
実装サイクル（9-1）のステップ5（設計整合性チェック）に以下を追加する:

1. **デッドコードチェック**: 新しい実装を追加した場合、置き換え対象の古い実装を削除したか確認する
2. **隣接変更チェック**: タスクスコープ外のコードを変更していないか確認する
3. **抽象化肥大チェック**: 生成したコードの行数が要件に対して過剰でないか確認する

**プロンプト知見の活用**:
- `.claude/instructions/ai-coding-antipatterns.md` と一致する内容だが、ワークフロー内の具体的なチェックポイントとして位置づけることで実効性を高める

---

### §10 コードレビュー

#### 追加ステップ: 設計原則ベースの変更容易性レビュー観点

**問題**: Stage 2のコード品質レビュー（10-2）のパースペクティブは「可読性と変更容易性」と抽象的に定義されており、具体的な検出基準が不足している。

**提案**:
Stage 2に以下の変更容易性レビュー観点を追加する:

1. ドメイン層にデータのみのクラスが存在しないか（P4）
2. 副作用を持つstaticメソッドが存在しないか（P5）
3. 3段階以上のメソッドチェーン（デメテルの法則違反）がないか（P6）
4. 同一条件の分岐が2ファイル以上に散在していないか（P7）
5. 目的が異なるロジックが共通化されていないか（P10）

**プロンプト知見の活用**:
- 「カテゴリ別分解」: レビュー観点を上記5項目に限定し、各項目を独立して評価
- 「セルフレビュー時の視点転換」: 「このコードを初めて見る人の視点で」とフレーミング
- 「過剰構造化の回避」: 検出基準は5項目を上限とし、追加しない

---

## 提案の優先度

| 優先度 | フェーズ | 提案 | 理由 |
|--------|---------|------|------|
| 高 | §4 | 設計原則の適用度チェック | 設計フェーズが全原則の適用ポイント。過剰適用と適用漏れの両方を防ぐ |
| 高 | §9 | デッドコード・隣接変更チェック | AI最頻出のアンチパターンに直接対応 |
| 高 | §10 | 設計原則ベースのレビュー観点追加 | レビューの検出基準を具体化 |
| 中 | §2 | 設計原則ベースの既存問題スキャン | 既存問題の見落としを防ぐ |
| 中 | §5 | 設計原則に基づくテスト観点導出 | テスト設計の漏れを防ぐ |
| 低 | §1 | 目的ベース用語定義の検証 | 命名段階での問題は§4で修正可能 |
| 低 | §3 | 不変性方針の明示的決定 | 暗黙的でも§4で適用は可能 |
| 低 | §8 | 実装順序の検証 | 既存のワークフローで概ねカバー |

---

## まとめ

### AIの挙動特性と設計原則の相互作用

ミノ駆動氏の設計原則をAIに指示する際の最大のリスクは**過剰適用**である。AIは指示された原則を忠実に、しかし文脈を無視して適用する傾向がある。

- 「値オブジェクトにすべき」→ すべての値をオブジェクト化（classitis）
- 「ポリモーフィズムで置き換えるべき」→ 単純な分岐にもクラス階層を導入（抽象化肥大）
- 「共通化しない」→ 明らかに同一の意図を持つコードも重複させる

これを防ぐため、各原則には「適用条件」を明示し、「なぜその条件が必要か」を理由付きで指示する必要がある（理由付き指示の知見）。

### 品質向上の3つの鍵

1. **設計フェーズ（§4）での適用条件の明示**: 「いつ適用するか」だけでなく「いつ適用しないか」を明確にする
2. **実装フェーズ（§9）でのアンチパターン検出**: デッドコードと隣接変更のチェックを実装サイクルに組み込む
3. **レビューフェーズ（§10）での具体的検出基準**: 抽象的な「変更容易性」ではなく、5項目の具体的チェックリストでレビューする
