# AI駆動開発ワークフロー

## 概要

本ドキュメントは、AIが要件から実装までを行う際のワークフロー（作業の流れ）を定義する。
前半の「ワークフロー定義」で全体像を把握し、後半の「フェーズ詳細」で各フェーズの具体的な作業内容・成果物・レビュー観点を確認する。

---

# ワークフロー定義

## フェーズ一覧

| # | フェーズ | 区分 | レビュー主体 | 詳細参照 |
|---|---------|------|-------------|---------|
| 0 | 前提条件チェック | ゲート | 🤖 AI自己 | §0 |
| 1 | 要件理解 | 分析 | 👤 人間 | §1 |
| 2 | 既存実装調査 | 調査 | 🤖 AI自己 | §2 |
| 3 | 技術・アーキテクチャ検討 | 設計 | 🤖 AI自己 → 👤 人間 | §3 |
| 4 | 詳細設計 | 設計 | 🤖 AI自己（多観点並列） | §4 |
| 5 | テスト設計 | 設計 | 🤖 AI自己 | §5 |
| 6 | Draft PR作成 | 納品 | 🤖 AI自己 | §6 |
| 7 | PR上で設計レビュー | レビュー | 👤 人間 | §7 |
| 8 | 実装ステップ計画 | 設計 | 🤖 AI自己 | §8 |
| 9 | ステップ実装 | 実装 | 🤖 AI自己 | §9 |
| 10 | コードレビュー | レビュー | 🤖 AI自己（2段階） | §10 |
| 11 | 受け入れ基準の検証 | 検証 | 🤖 AI自己 | §11 |
| 12 | PR Ready化 | 納品 | 🤖 AI自己 | §12 |
| 13 | PR上でコードレビュー | レビュー | 👤 人間 | §13 |

## フロー全体図

```
Phase 0: 前提条件チェック
  └→ 🤖 プロジェクト非機能要件の確認 ─── 未定義 → 定義すべき項目を提示、ワークフロー終了
      │                                └── 定義済み → Phase 1 へ
Phase 1: 要件理解
  └→ 👤 要件確認 ─── NG → Phase 1 へ戻る
      │
Phase 2: 既存実装調査
  └→ 🤖 調査十分性レビュー
  └→ 🤖 PR分割評価 ─── 分割提案 → 👤 分割判断 ─── 採用 → 人間がIssue分割、スキル終了
      │                                            └── 却下 → Phase 3 へ
      │
Phase 3: 技術・アーキテクチャ検討
  └→ 🤖 技術・アーキテクチャレビュー
  └→ 👤 承認（ADR該当時）─── NG → Phase 3 へ戻る
      │
Phase 4: 詳細設計
  └→ 🤖 設計レビュー（多観点並列）
  └→ NG → Phase 4 へ戻る
      │
Phase 5: テスト設計
  └→ 🤖 テスト網羅性レビュー
  └→ 👤 プロジェクト設計規約の更新提案 → 実装者承認
      │
Phase 6: Draft PR作成
  └→ 受け入れ基準・設計書をブランチにコミット
  └→ 設計レビューブリーフをPRコメントとして投稿
      │
Phase 7: 👤 PR上で設計レビュー
  └→ PRコメント → 修正対応 → 再レビュー
      │
Phase 8: 実装ステップ計画
  └→ 実装スコープ見積もり（変更対象・I/O・疑問点の明確化、PRサイズ検証）
  └→ 設計書からステップ分割（ステップ毎の受け入れ基準を定義）
      │
Phase 9: ステップ実装
  └→ ステップ毎: テストコード実装(RED) → プロダクションコード実装(GREEN) → formatter/linter → テスト確認 → 設計整合性チェック → 受け入れ基準確認 → commit
      │
Phase 10: 🤖 コードレビュー（2段階）
  └→ Stage 1: 仕様準拠レビュー ─── NG → Phase 9 へ戻る（設計起因は Phase 4 へ）
  └→ Stage 2: コード品質レビュー（多観点並列） ─── NG → Phase 9 へ戻る
      │
Phase 11: 受け入れ基準の検証
  └→ 全体の受け入れ基準を満たしているか確認
  └→ 👤 プロジェクト設計規約の更新提案 → 実装者承認
      │
Phase 12: PR Ready化
  └→ PR本文更新 → Ready for Review
  └→ コードレビューブリーフをPRコメントとして投稿
      │
Phase 13: 👤 PR上でコードレビュー
  └→ PRコメント → 修正対応 → 再レビュー
```

## 👤 人間レビューポイント一覧

| レビューポイント | フェーズ | 方式 | 理由 | NG時の戻り先 |
|----------------|---------|------|------|-------------|
| 要件確認 | 1 | セッション内 | 要件の解釈ミスは後工程すべてに波及するため | Phase 1 |
| PR分割判断 | 2 | セッション内 | PRの分割粒度はビジネス上の優先度やリリース戦略に依存する判断のため | Phase 1 |
| 技術・アーキテクチャ承認 | 3 | セッション内 | 技術選定・アーキテクチャ判断はプロジェクト全体に影響する不可逆性の高い決定のため（ADR該当時のみ） | Phase 3 |
| 設計レビュー | 7 | PR上 | 設計はコードの骨格であり実装後の手戻りコストが大きいため | Phase 4 |
| コードレビュー | 13 | PR上 | ビジネス意図・チーム設計哲学・運用観点を人間が最終判断するため | Phase 9 |

## レビュー観点マトリクス

設計・コードそれぞれに「いつ」「何の観点で」レビューするかの一覧。

| レビュー観点 | 設計フェーズ (4) | テスト設計 (5) | コードフェーズ (9-10) | 主体 |
|---|---|---|---|---|
| 変更容易性 / SRP / OCP | ✅ 4 | - | ✅ 10 | 🤖 |
| 既存実装との整合性 | ✅ 4 | ✅ 5 | ✅ 10 | 🤖 |
| テスタビリティ | ✅ 4 | - | - | 🤖 |
| テスト網羅性 | - | ✅ 5 | ✅ 9 | 🤖 |
| セキュリティ | ✅ 4 | - | ✅ 10 | 🤖 |
| パフォーマンス | ✅ 4 | - | ✅ 10 | 🤖 |
| 保守性 / 可読性 | ✅ 4 | - | ✅ 10 | 🤖 |
| コード品質 | - | - | ✅ 10 | 🤖 |
| ビジネスロジック正確性 | ✅ 7 | ✅ 7 | ✅ 13 | 👤 |
| チーム方針整合性 | ✅ 7 | ✅ 7 | ✅ 13 | 👤 |
| 運用・デプロイ観点 | - | - | ✅ 13 | 👤 |

## セッション分割

本ワークフローは以下の2セッションに分割して実行する。Phase 7・13 は人間の非同期レビューであり、独立したセッションとはカウントしない。

| セッション | フェーズ | 対応スキル | 開始時に読み込む成果物 |
|-----------|---------|-----------|---------------------|
| 設計セッション | Phase 1〜6 | issue_design | GitHub Issue |
| 実装セッション | Phase 8〜12 | issue_implement | PR上の設計書・テスト設計・受け入れ基準・既存実装調査レポート・プロジェクト設計規約 |

### セッション間の引き継ぎルール

- セッション間の情報伝達は **PR上にコミットされた成果物のみ** を正とする
- 口頭やセッション内のやり取りに依存する情報は、必ず成果物に反映してからセッションを終了すること
- Phase 7・13 の人間レビューで生じた修正指摘は、PRコメントとして記録され、次セッション開始時にAIが読み込む

## エスカレーション基準

以下の場合、AIは独断で進めず人間に判断を仰ぐこと：

1. **設計上の重大なトレードオフ判明時** — パフォーマンスと可読性の二律背反など
2. **要件の解釈が複数通り可能な場合** — ドメイン知識に基づく判断が必要
3. **既存コードにバグまたは設計上の問題を発見した場合** — スコープ外修正の要否判断
4. **セキュリティリスクが高い実装が必要な場合** — リスク受容の判断
5. **設計書通りの実装が困難または非効率と判明した場合** — 設計変更の要否判断
6. **テストカバレッジがプロジェクト基準を下回る場合** — テスト追加 vs 基準緩和の判断

### 失敗時のリカバリー手順

エスカレーションの前に、AIはまず以下のリカバリーを試みること。上限回数を超えても解決しない場合は人間にエスカレーションする。

| 失敗パターン | リカバリー手順 | 試行上限 | 解決しない場合 |
|------------|--------------|---------|--------------|
| テスト不通過 | 原因分析 → 設計書の範囲内で実装修正。テスト通過のために設計書にない振る舞いを追加したり、設計上の責務分割を変更してはならない。修正が設計変更を必要とする場合は実装修正ではなく設計起因として扱う | 3回 | 原因が設計起因か実装起因かを判別し報告。設計起因なら Phase 4 への差し戻しを提案 |
| 実装の行き詰まり | アプローチ変更 → Phase 8 に戻りステップ再分割を検討 | 2回 | 行き詰まりの原因と試行内容を報告しエスカレーション |
| コンテキスト圧迫 | セッションを分割し、PR上の成果物から新セッションで再開 | — | — |

---

# フェーズ詳細

## §0. 前提条件チェック

### 0-1. プロジェクト非機能要件の確認

**目的：** プロジェクトレベルの非機能要件が定義されているかを確認し、未定義の場合はワークフローを開始しない

**作業内容：**
- プロジェクト非機能要件定義ファイルの存在を確認する
- 存在しない場合、定義すべき非機能要件の項目（性能・セキュリティ・可用性・スケーラビリティ等）を提示し、ワークフローを終了する
- 存在する場合、以降のフェーズでプロジェクト非機能要件を設計・実装の制約として参照する

**ゲート条件：** プロジェクト非機能要件定義ファイルが存在すること。未定義の場合は定義すべき項目を提示してワークフロー終了。

---

## §1. 要件理解

### 1-1. 要件の読み解きと整理

**目的：** 与えられた要件を構造化し、曖昧さや不足を洗い出す

**作業内容：**
- 機能要件の抽出と一覧化（ユースケース単位）
- 非機能要件の抽出（性能・セキュリティ・可用性など）
- 前提条件・制約条件の明確化
- 用語の定義（ユビキタス言語の整理）
- スコープ内/スコープ外の境界線定義

**成果物：**
- 要件整理ドキュメント（テンプレート: [templates/requirements.md](templates/requirements.md)）

### 1-1b. 要件の能動的探索

**目的：** ユーザーが明示していない暗黙の前提・エッジケース・ビジネス上の例外を掘り起こす

**作業内容：**
- ユースケースごとの「もし〜だったらどうなるか」シナリオの提示
- 暗黙の前提条件の言語化と確認（例：データ量の想定、同時実行の有無）
- 類似機能における一般的なエッジケースの列挙と要否確認
- スコープ境界が曖昧な箇所の具体例による確認

### 1-2. 👤 要件確認

**人間への確認事項：**
- 要件の解釈に齟齬がないか
- 優先度・スコープの合意
- 不明点への回答
- ビジネス上の背景や意図の補足

**通過条件：** 人間が要件整理ドキュメントを承認すること

---

## §2. 既存実装調査

### 2-0. プロジェクト設計規約の読み込み

**目的：** 過去の調査・レビューで蓄積された設計規約を読み込み、既知の規約をスタート地点にして差分調査に集中する

**作業内容：**
- プロジェクト設計規約ファイルが存在する場合、調査開始前に読み込む
- 規約ファイルの内容を前提知識として以降の調査・設計・実装で参照する

**注意：** このファイルは網羅的ではない。記載外の規約も積極的に調査すること。規約ファイルに記載のないパターンを発見した場合は、Phase 5-4 での更新候補として記録する。

### 2-1. 調査スコープの策定

**目的：** 何を・なぜ・どこまで調査するかを先に定義し、調査の発散を防ぐ

**調査スコープの検討項目：**
- 変更対象となるモジュール・パッケージの特定
- 変更対象が依存しているモジュールの特定（上流・下流）
- 関連するDB テーブル・API エンドポイント
- 既存のテストコードの有無と品質
- 既存の設計ドキュメント・ADR の有無

**成果物：**
- 調査計画書（調査対象一覧、調査の問い、期待するアウトプット）

### 2-2. 既存コードベースの調査

**作業内容：**
- ディレクトリ構成・レイヤー構成の把握
- 既存の設計パターン・アーキテクチャの特定
- 命名規則・コーディング規約の抽出
- 共通ユーティリティ・ヘルパーの把握
- エラーハンドリングパターンの把握
- ログ出力方針の把握
- 既存テストの構成・テスティングフレームワーク・モック戦略の把握

**成果物：**
- 既存実装調査レポート（テンプレート: [templates/investigation-report.md](templates/investigation-report.md)）

### 2-3. 🤖 AI自己レビュー：調査の十分性

**パースペクティブ：** 変更の影響範囲と既存パターンの両面から、調査に盲点がないかを探索する

### 2-4. PR分割評価

**目的：** 要件の論理構造と既存コードベースの構造を踏まえ、複数PRへの分割が適切かを判断する

**分割を提案する条件：** 以下のいずれかに該当する場合
1. **独立した機能単位が複数ある** — 機能要件に論理的に独立した変更単位が複数含まれており、それぞれが単独でリリース可能
2. **リファクタリングと新機能が混在** — 既存コードの構造変更と新機能追加が同一スコープに含まれている
3. **段階的に提供可能な依存構造がある** — 基盤変更→ロジック→UIのように層が分かれ、先行PRで単独の価値を提供できる
4. **変更が複数の境界づけられたコンテキストにまたがる** — 異なるドメイン領域を横断する変更

**分割しない条件：** 以下のいずれかに該当する場合は分割を提案しない
- 変更が密結合で、分離すると個別PRが不完全・不整合になる
- 規模がS/Mで、分割のオーバーヘッドがメリットを上回る
- PR間の整合性確保コストが分割メリットを上回る

**フロー：**
1. AIが上記条件に基づいて分割の要否を分析し、結果を提示する
2. 分割を提案する場合、推奨する分割単位とその理由を提示する
3. 👤 人間が分割を採用するか判断する
   - 採用: 人間がIssueを分割し、各サブIssueに対して個別にワークフローを実行
   - 却下: Phase 3 へ進む

---

## §3. 技術・アーキテクチャ検討

### 3-1. 新規技術の要否判断

**目的：** 新しいライブラリ・フレームワーク・ツールの導入が必要かを判断する

**検討項目：**
- 既存技術スタックで要件を満たせるか
- 新規導入が必要な場合、候補技術の比較
- ライセンス・メンテナンス状況・コミュニティの健全性
- セキュリティ脆弱性の履歴
- 既存スタックとの互換性・統合コスト
- チームの学習コスト

### 3-2. アーキテクチャ設計

**目的：** システム全体の構造的な方針を決定する

**作業内容：**
- レイヤー構成の決定（既存アーキテクチャに準拠）
- モジュール・パッケージの分割方針
- 依存方向の定義（依存性逆転の適用箇所の判断）
- 外部システムとの統合方針（Anti-Corruption Layer の検討）
- 通信パターンの選択（同期/非同期、イベント駆動等）

**成果物：**
- モジュール構成図
- 依存関係図

### 3-3. ADR（Architecture Decision Record）作成（該当時のみ）

**ADR作成の判断基準：** 以下のいずれかに該当する場合にADRを作成する
- 新規技術・ライブラリの導入
- アーキテクチャ上の重要な判断（レイヤー構成の変更、通信パターンの選択等）
- 複数の実現手段があり、トレードオフを伴う判断

**ADR テンプレート：**
```
# ADR-XXX: [タイトル]

## ステータス
提案 / 承認済 / 廃止

## コンテキスト
なぜこの意思決定が必要か

## 検討した選択肢
### 選択肢A: ...
- メリット:
- デメリット:

### 選択肢B: ...
- メリット:
- デメリット:

## 決定
何を選び、なぜ選んだか

## 影響
この決定により生じる影響・トレードオフ
```

### 3-4. 🤖 AI自己レビュー：技術・アーキテクチャの妥当性

**パースペクティブ：** 技術選定が要件駆動であるか（技術的興味による選定でないか）、既存システムとの整合性の観点から妥当性を評価する

### 3-5. 👤 技術・アーキテクチャ承認（ADRがある場合）

**通過条件：** ADRが承認されること（ADR該当事項がない場合はスキップ）

---

## §4. 詳細設計

### 4-1. API設計

**目的：** 外部に公開するインタフェースの仕様を定義する

**作業内容：**
- エンドポイント定義（パス、HTTPメソッド）
- リクエスト/レスポンススキーマ
- エラーレスポンス設計（ステータスコード、エラーコード体系）
- 認証・認可の適用方針

### 4-2. データモデル設計

**目的：** データの永続化構造を定義する

**作業内容：**
- テーブル定義（カラム、型、制約）
- テーブル間のリレーション
- インデックス設計
- マイグレーション方針

### 4-3. クラス設計

**目的：** 各クラスの責務・インタフェース・関係を定義する

**設計原則：**
- プロジェクトの設計ガイドライン（CLAUDE.md等で定義）に従うこと
- 設計ガイドラインが未定義の場合は、既存コードベースの設計パターンに準拠すること

**成果物に含める内容：**
- クラス図（クラス名・フィールド・メソッドシグネチャ・可視性）
- 各クラスの責務説明（1〜2文）
- クラス間の関係（依存・継承・コンポジション）
- インタフェース定義（公開APIの契約）
- 例外設計（どの例外をどこで投げ・どこでキャッチするか）
- ドメインイベント設計（該当する場合）

### 4-4. シーケンス設計

**目的：** 主要ユースケースの処理フローを定義する

**作業内容：**
- ユースケースごとのオブジェクト間のメッセージフロー
- 外部システム連携の呼び出し順序
- エラー発生時の処理フロー

**成果物：**
- 詳細設計書（テンプレート: [templates/design.md](templates/design.md)）
  - API設計・データモデル設計・クラス設計・シーケンス設計を1文書に統合

### 4-5. 可観測性設計

**目的：** 運用時の障害検知・原因特定を可能にするための可観測性方針を定義する

**作業内容：**
- ログ方針（出力箇所・ログレベル・構造化ログの形式）
- メトリクス設計（計測対象・閾値・アラート条件）
- トレーシング設計（分散トレーシングのスパン設計、該当する場合）
- 既存のログ・メトリクス基盤との整合性確認

**注意：** プロジェクト非機能要件やプロジェクト設計規約にログ・メトリクスの方針が定義されている場合はそれに準拠する。ここではIssue固有の可観測性要件を設計する。

### 4-6. 🤖 設計レビュー（多観点並列）

> 以下のパースペクティブごとに設計の問題を探索する。問題が見つかった場合は設計を修正し、再レビューする。

**変更容易性：** 責務の単一性と変更の局所化の観点から、設計の柔軟性と過剰設計（YAGNI）のバランスを評価する

**既存実装との整合性：** 既存コードベースのパターン・命名・依存方向との一貫性を評価する

**テスタビリティ：** 外部依存の注入可能性と副作用の分離の観点から、テスト容易性を評価する

**セキュリティ：** 信頼境界の設定と入力検証の方針が適切かを評価する

**パフォーマンス設計：** プロジェクト非機能要件の性能基準値を制約として、想定データ量に対するアルゴリズム効率とI/Oパターンの適切性を評価する

**NG時：** Phase 4 の設計作業に戻り修正

---

## §5. テスト設計

### 5-1. テスト方針の策定

**作業内容：**
- テストレベルの定義（Unit / Integration / E2E のスコープ）
- 今回のスコープでのテスト対象の優先度付け
- テストダブル戦略（Mock / Stub / Fake の使い分け方針）
- テストデータ戦略（テストフィクスチャの管理方針）

### 5-2. テストケース設計

**作業内容：**
- テスト対象メソッドの洗い出し
- 各メソッドに対するテストケースの定義

**テストケース設計の観点：**
- 正常系：代表的な入力での期待動作
- 異常系：不正入力・境界値・null/空での振る舞い
- 境界値：数値の上限下限、文字列長の境界、コレクションの空/1件/複数件
- 状態遷移：状態の前後関係、不正な遷移の拒否
- 副作用：イベント発行・ログ出力・外部呼び出しの検証
- 組み合わせ：複数条件の組み合わせ（All-pairs 等での削減検討）

**成果物：**
- テスト設計書（テンプレート: [templates/test-design.md](templates/test-design.md)）

### 5-3. 🤖 AI自己レビュー：テスト設計の網羅性レビュー

**パースペクティブ：** ビジネスルールの分岐とエッジケースの観点から、テスト設計に盲点がないかを探索する

### 5-4. 👤 プロジェクト設計規約の更新提案

**目的：** Phase 2 の調査と Phase 3-4 の設計で得た知見から、プロジェクト全体に適用可能な規約を抽出し、蓄積する

**作業内容：**
- 調査・設計の過程で発見した、規約ファイルに未記載のプロジェクト固有ルールを抽出する
- 規約ファイルが未存在の場合はテンプレート（[templates/design-conventions.md](templates/design-conventions.md)）から新規作成を提案する

**抽出基準：** 以下をすべて満たすもの
- AIがコードだけからは推測できないプロジェクト固有のルールである
- 違反時の影響が大きい（レイヤー責務、依存方向、セキュリティ境界等）
- 個別 Issue 固有ではなく、プロジェクト全体に適用可能である

**対象外：**
- linter/formatter で自動検出可能な規約
- 一般的な設計原則（SOLID等）
- Issue 固有のドメイン知識（調査レポートで扱う）

**通過条件：** 実装者が更新内容を承認すること（更新がない場合はスキップ）

---

## §6. Draft PR作成

### 6-1. ブランチ作成とDraft PR

**作業内容：**
- フィーチャーブランチを作成
- 以下の成果物をブランチにコミット：
  - 受け入れ基準（要件から導出した完了条件）
  - 設計書（モジュール構成図、詳細クラス設計書）
  - テスト設計（テスト方針、テストケース一覧）
  - 既存実装調査レポート（既存パターン・規約・再利用可能コンポーネント）
  - ADR（該当時）
  - プロジェクト設計規約（更新がある場合）
- Draft PRを作成（PR本文テンプレート: [templates/pr-description.md](templates/pr-description.md)）

### 6-2. 設計レビューブリーフの生成

**目的：** Phase 7 の人間レビューアが設計書全文を読み込む前に全体像を把握し、注意すべき箇所を特定できるようにする

**作業内容：**
以下の内容をPRコメントとして投稿する。

1. **設計概要と図解**
   - ERD・クラス図・主要シーケンス図の要約版（design.md から抽出・簡略化）
   - レビューアが設計書を読む前に構造を視覚的に把握するためのもの

2. **設計判断ハイライト**
   - AIが行った主要な設計判断とその理由
   - 検討した代替案がある場合はその概要
   - レビューアがトレードオフの許容可否を判断するための材料

3. **既存パターンからの逸脱点**
   - investigation-report.md で把握した既存パターンと異なる設計箇所の明示
   - レビューアがチーム一貫性を確認すべきポイントを事前に絞るためのもの

4. **人間に確認を求めるポイント**
   - ドメイン解釈が複数通り可能で、AIが判断しきれなかった箇所
   - 要件の行間を読んで補完した箇所
   - ビジネスルールの優先度や例外ケースについてドメイン知識が必要な箇所

---

## §7. 👤 PR上で設計レビュー

**人間の確認観点：**
- ドメインモデルの妥当性（ビジネスルールの正確な反映）
- アーキテクチャ方針との整合性
- チーム内の他機能との設計一貫性
- トレードオフの許容可否（例：パフォーマンスvs可読性）
- テスト設計の妥当性（ビジネス上重要なシナリオの漏れがないか）
- テストの粒度が適切か（過剰テスト / テスト不足）

**レビュー方式：**
- 人間がPR上でコメントにより指摘
- AIが指摘に対して修正対応し、コミットをプッシュ
- 人間が再レビューし、問題なければApprove

**通過条件：** PR上で設計がApproveされること（修正指摘がある場合は Phase 4 に戻る）

---

## §8. 実装ステップ計画

### 8-1. 実装スコープの見積もり

**目的：** 設計書を実コードベースに照らし合わせ、実装の具体的な影響範囲を明確化する

**作業内容：**
- 編集対象ファイルの特定（ファイル名:行番号の精度で列挙）
- 新規作成ファイルの一覧
- 関連するDBテーブル・APIエンドポイントの一覧
- 全I/O（外部API呼び出し、ファイル操作、DB操作）の洗い出し
- 疑問点・矛盾点の列挙（設計書と既存コードの間の不整合、設計書内の曖昧な箇所）

**スコープ検証：**
- 変更ファイル数・変更行数の概算から、PRサイズが妥当か判断する
- 疑問点・矛盾点がある場合は、実装着手前に人間に確認する

### 8-2. ステップ分割

**目的：** 設計書を実装可能な単位に分割し、段階的に実装する計画を立てる

**方針：**
- 依存関係の下流（ドメイン層）から上流（プレゼンテーション層）へ実装
- 値オブジェクト → エンティティ → ドメインサービス → アプリケーションサービス → インフラ層 → プレゼンテーション層
- 各ステップは「テストコード実装 → プロダクションコード実装」の順で実行する（テスト先行）
- テストコード実装時はプロダクションコードを変更しない。プロダクションコード実装時はテストコードを変更しない
- リファクタリング目的のステップでは、テストコード実装をスキップし、既存テストを変更せずにプロダクションコードのみ変更する
- 各ステップは独立してcommit可能な単位とする

**ステップの粒度基準：**
- 1ステップ = 1つの離散的な変更 + そのテスト。ステップを読んだだけで「何を作るか」に解釈の余地がない状態にすること
- 実装対象はファイルパス（新規/既存の区別）と具体的な変更内容を記述する（「○○を実装する」ではなく、何をどう振る舞わせるかを記述する）
- テスト対象は正常系・異常系・境界値をテストケース単位で記載する（「○○Test」のようなクラス名だけでは不十分）
- 受け入れ基準は具体的な入出力で定義する（「正しく動作すること」は受け入れ基準ではない）

**成果物：**
- 実装ステップ計画（テンプレート: [templates/implementation-plan.md](templates/implementation-plan.md)）

### 8-3. ステップ毎の受け入れ基準

**各ステップに以下を定義：**
- 実装すべきクラス・メソッドの一覧
- パスすべきテストケースの一覧
- formatter/linter エラーがないこと
- 設計書との一致性（逸脱がある場合は理由を記録）

---

## §9. ステップ実装

> 各ステップについて、以下のサイクルを繰り返す。

### 9-1. ステップ実装サイクル

**各ステップで行う作業：**

1. **テストコード実装（RED）**
   - テスト設計書に基づき、当該ステップのテストコードを実装する
   - テストヘルパー・テストフィクスチャの実装
   - テストの可読性確認（Arrange-Act-Assert パターン、テスト名の明確さ）
   - テストを実行し、期待通りに失敗することを確認する
   - この段階ではプロダクションコードを変更しない

2. **プロダクションコード実装（GREEN）**
   - クラス設計書に忠実に実装する（設計からの逸脱が必要な場合は理由を記録）
   - プロジェクト設計規約ファイルおよび既存コードベースの規約・パターンに従う
   - コメントは「なぜ」を書く（「何を」はコードで表現する）
   - TODOコメントを残す場合は対応チケット番号を付与
   - マジックナンバー・マジックストリングの排除
   - この段階ではテストコードを変更しない

3. **formatter / linter 実行**
   - プロジェクト標準の formatter を実行
   - プロジェクト標準の linter を実行
   - 静的解析ツールの実行（該当時）
   - すべての警告・エラーを解消

4. **テスト実行・結果確認**
   - テストコマンドを実行し、出力が全件パスを示していることを確認する（「通過しているはず」ではなく、実行結果の出力に基づいて判定すること）
   - カバレッジ計測と基準値の確認
   - 失敗テストがある場合はプロダクションコード側を修正する（テストコードは変更しない）

5. **設計整合性の軽量チェック**
   - 実装がクラス設計書の責務分割・依存方向から逸脱していないか確認
   - 逸脱がある場合は理由を記録し、妥当でなければこのステップ内で修正

6. **ステップの受け入れ基準確認**
   - Phase 8で定義した当該ステップの受け入れ基準をすべて満たしているか検証

**リファクタリング目的のステップの場合：** 手順1（テストコード実装）をスキップし、既存テストを変更せずに手順2以降を実行する。手順4でテストが失敗した場合は、リファクタリングにより振る舞いが変わったことを意味するため、プロダクションコード側の修正で対処する。

7. **commit**
   - 受け入れ基準を満たしたステップをcommit

---

## §10. 🤖 コードレビュー（2段階）

> 全ステップの実装完了後、**仕様準拠レビュー → コード品質レビュー**の順で2段階のAI自己レビューを行う。仕様準拠レビューを通過するまでコード品質レビューには進まない。

### Stage 1: 仕様準拠レビュー

### 10-1. 🤖 仕様準拠レビュー

**目的：** 実装が設計書通りに行われたかを検証する（「正しいものを作ったか？」）

**パースペクティブ：** 実際のソースコードを設計書と突き合わせ、実装の過不足（未実装・スコープクリープ）と設計からの逸脱を探索する

**検証方法：** 実際のソースコードを読み、設計書と突き合わせること。実装者の報告を信頼せず、コードの事実に基づいて判定する。

**NG時：** Phase 9 に戻り修正。設計起因の場合は Phase 4 への差し戻しを提案。

**通過条件：** 仕様準拠レビューの全項目をクリアすること。通過後、Stage 2 に進む。

---

### Stage 2: コード品質レビュー

> 仕様準拠レビュー通過後、以下の観点でコード品質レビューを行う。問題が見つかった場合は修正し、再レビューする。

### 10-2. 🤖 コード品質レビュー

**パースペクティブ：** 可読性と変更容易性の観点から、コードの構造的な問題を探索する

### 10-3. 🤖 セキュリティレビュー

**パースペクティブ：** 信頼境界を越えるデータフローに沿って、入力検証・認証認可・機密情報の取り扱いに関する脆弱性を探索する

### 10-4. 🤖 パフォーマンスレビュー

**パースペクティブ：** データアクセスパターンとリソース使用量の観点から、性能上のボトルネックを探索する

### 10-5. 🤖 保守性レビュー

**パースペクティブ：** 運用時の可観測性と変更時の影響予測可能性の観点から、保守上の問題を探索する

### 10-6. レビュー結果の集約

**成果物：**
- レビュー指摘事項一覧（観点・該当箇所・指摘内容・対応方針・対応結果）
- 全指摘への対応完了を確認

**NG時：** Phase 9 に戻り修正

---

## §11. 受け入れ基準の検証

**目的：** 全体の受け入れ基準を満たしているかを最終確認する

**作業内容：**
- Phase 6でコミットした受け入れ基準の一覧を参照
- 各受け入れ基準に対して、検証方法を特定し、実行し、結果を記録する
- プロジェクト非機能要件のうち本Issueに関連する項目について、検証方法を特定し、実行し、結果を記録する
- 全テストの通過を確認（テストコマンドを実行し、出力に基づいて判定する）
- formatter/linter エラーがないことを確認（実行結果に基づいて判定する）

**成果物：**
- 受け入れ基準の検証結果（各基準 × 検証方法 × 結果）。Phase 12 でPRコメントとして投稿する

**未達項目がある場合：** Phase 9 に戻り追加実装

### 11-2. 👤 プロジェクト設計規約の更新提案

**目的：** Phase 9 の実装および Phase 7 の人間レビューフィードバックから得た知見を、プロジェクト全体に適用可能な規約として蓄積する

**作業内容：**
- 実装の過程で発見した、規約ファイルに未記載のプロジェクト固有ルールを抽出する
- Phase 7 の人間レビューで指摘された「チーム方針との不整合」は、暗黙的設計思想の顕在化として特に注目する

**抽出基準：** Phase 5-4 と同一

**通過条件：** 実装者が更新内容を承認すること（更新がない場合はスキップ）

---

## §12. PR Ready化

### 12-1. PR本文の最終更新

**作業内容：**
- CIパイプラインの全チェック通過を確認（失敗時は Phase 9 に戻り修正）
- PR本文を最終状態に更新：
  - 実装結果の反映（変更内容の確定・影響範囲を含む）
  - 設計判断の記載（実装時の設計逸脱がある場合はその内容と理由を含む）
  - 受け入れ基準の充足状況の更新
  - プロジェクト設計規約の更新内容（更新がある場合）
  - チェックリストの更新
- プロジェクト設計規約の更新をコミット（更新がある場合）
- テスト結果・カバレッジ・受け入れ基準の検証結果（Phase 11の成果物）をPRコメントとして投稿
- Draft → Ready for Review に変更

### 12-2. コードレビューブリーフの生成

**目的：** Phase 13 の人間レビューアが差分全体を読む前に変更の全貌を把握し、ビジネスロジック検証に集中できるようにする

**作業内容：**
以下の内容をPRコメントとして投稿する。

1. **変更サマリ（レイヤー別）**
   - ファイル単位ではなくモジュール・レイヤー単位での変更概要
   - レビューアが差分が大きい場合でも全体構造を先に把握するためのもの

2. **ビジネスロジック所在マップ**
   - 核となるビジネスルールが実装されているファイル・メソッドの一覧（行番号付き）
   - レビューアが差分を上から読むのではなく、重要なコードに直接到達するためのもの

3. **設計からの逸脱と理由**
   - 実装時に design.md から変更した箇所とその理由の一覧
   - レビューアが設計レビュー済みの部分との差分だけに注目し、設計通りの箇所を軽く流せるようにするためのもの

4. **人間に確認を求めるポイント**
   - AI自己レビューではカバーしきれない観点（ドメイン固有の妥当性判断、運用影響、既存機能との暗黙的な整合性など）
   - レビューアの注意を「AIでは判断できない箇所」に集中させるためのもの

---

## §13. 👤 PR上でコードレビュー

**人間の確認観点：**
- ビジネスロジックの正確性（ドメインエキスパートとしての判断）
- コードベース全体との一貫性（チームの暗黙知との整合）
- 運用・デプロイ上の懸念事項
- テストの妥当性（過不足の判断）
- AI自己レビューの指摘対応の妥当性

**レビュー方式：**
- 人間がPR上でコメントにより指摘
- AIが指摘に対して修正対応し、コミットをプッシュ
- 人間が再レビューし、問題なければApprove

**通過条件：** PR上でApproveされること（修正指摘がある場合は Phase 9 に戻る）
