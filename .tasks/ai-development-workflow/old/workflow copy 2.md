# AI駆動開発ワークフロー

## 概要

本ドキュメントは、AIが要件から実装までを行う際のワークフロー（作業の流れ）を定義する。
前半の「ワークフロー定義」で全体像を把握し、後半の「フェーズ詳細」で各フェーズの具体的な作業内容・成果物・レビュー観点を確認する。

---

# ワークフロー定義

## フェーズ一覧

| # | フェーズ | 区分 | レビュー主体 | 詳細参照 |
|---|---------|------|-------------|---------|
| 1 | 要件理解 | 分析 | 👤 人間 | §1 |
| 2 | 既存実装調査 | 調査 | 🤖 AI自己 | §2 |
| 3 | 技術スタック検討 | 設計 | 🤖 AI自己 → 👤 人間 | §3 |
| 4 | クラス設計 | 設計 | 🤖 AI自己（多観点並列） | §4 |
| 5 | テスト設計 | 設計 | 🤖 AI自己 | §5 |
| 6 | Draft PR作成 | 納品 | 🤖 AI自己 | §6 |
| 7 | PR上で設計レビュー | レビュー | 👤 人間 | §7 |
| 8 | 実装ステップ計画 | 設計 | 🤖 AI自己 | §8 |
| 9 | ステップ実装 | 実装 | 🤖 AI自己 | §9 |
| 10 | コードレビュー | レビュー | 🤖 AI自己（多観点並列） | §10 |
| 11 | 受け入れ基準の検証 | 検証 | 🤖 AI自己 | §11 |
| 12 | PR Ready化 | 納品 | 🤖 AI自己 | §12 |
| 13 | PR上でコードレビュー | レビュー | 👤 人間 | §13 |

## フロー全体図

```
Phase 1: 要件理解
  └→ 👤 要件確認 ─── NG → Phase 1 へ戻る
      │
Phase 2: 既存実装調査
  └→ 🤖 調査十分性レビュー
      │
Phase 3: 技術スタック検討
  └→ 🤖 技術選定レビュー
  └→ 👤 技術選定承認（ADR該当時）─── NG → Phase 3 へ戻る
      │
Phase 4: クラス設計
  └→ 🤖 設計レビュー（多観点並列）
  └→ NG → Phase 4 へ戻る
      │
Phase 5: テスト設計
  └→ 🤖 テスト網羅性レビュー
      │
Phase 6: Draft PR作成
  └→ 受け入れ基準・設計書をブランチにコミット
      │
Phase 7: 👤 PR上で設計レビュー
  └→ PRコメント → 修正対応 → 再レビュー
      │
Phase 8: 実装ステップ計画
  └→ 設計書からステップ分割（ステップ毎の受け入れ基準を定義）
      │
Phase 9: ステップ実装
  └→ ステップ毎: 実装 → formatter/linter → テスト → 受け入れ基準確認 → commit
      │
Phase 10: 🤖 コードレビュー（多観点並列）
  └→ NG → Phase 9 へ戻る
      │
Phase 11: 受け入れ基準の検証
  └→ 全体の受け入れ基準を満たしているか確認
      │
Phase 12: PR Ready化
  └→ PR本文更新 → Ready for Review
      │
Phase 13: 👤 PR上でコードレビュー
  └→ PRコメント → 修正対応 → 再レビュー
```

## 👤 人間レビューポイント一覧

| レビューポイント | フェーズ | 方式 | 理由 | NG時の戻り先 |
|----------------|---------|------|------|-------------|
| 要件確認 | 1 | セッション内 | 要件の解釈ミスは後工程すべてに波及するため | Phase 1 |
| 技術選定承認 | 3 | セッション内 | 新規技術導入はプロジェクト全体に影響する不可逆性の高い決定のため（ADR該当時のみ） | Phase 3 |
| 設計レビュー | 7 | PR上 | 設計はコードの骨格であり実装後の手戻りコストが大きいため | Phase 4 |
| コードレビュー | 13 | PR上 | ビジネス意図・チーム設計哲学・運用観点を人間が最終判断するため | Phase 9 |

## レビュー観点マトリクス

設計・コードそれぞれに「いつ」「何の観点で」レビューするかの一覧。

| レビュー観点 | 設計フェーズ (4) | テスト設計 (5) | コードフェーズ (9-10) | 主体 |
|---|---|---|---|---|
| 変更容易性 / SRP / OCP | ✅ 4 | - | ✅ 10 | 🤖 |
| 既存実装との整合性 | ✅ 4 | ✅ 5 | ✅ 10 | 🤖 |
| テスタビリティ | ✅ 4 | - | - | 🤖 |
| テスト網羅性 | - | ✅ 5 | ✅ 9 | 🤖 |
| セキュリティ | ✅ 4 | - | ✅ 10 | 🤖 |
| パフォーマンス | - | - | ✅ 10 | 🤖 |
| 保守性 / 可読性 | ✅ 4 | - | ✅ 10 | 🤖 |
| コード品質 | - | - | ✅ 10 | 🤖 |
| ビジネスロジック正確性 | ✅ 7 | ✅ 7 | ✅ 13 | 👤 |
| チーム方針整合性 | ✅ 7 | ✅ 7 | ✅ 13 | 👤 |
| 運用・デプロイ観点 | - | - | ✅ 13 | 👤 |

## エスカレーション基準

以下の場合、AIは独断で進めず人間に判断を仰ぐこと：

1. **設計上の重大なトレードオフ判明時** — パフォーマンスと可読性の二律背反など
2. **要件の解釈が複数通り可能な場合** — ドメイン知識に基づく判断が必要
3. **既存コードにバグまたは設計上の問題を発見した場合** — スコープ外修正の要否判断
4. **セキュリティリスクが高い実装が必要な場合** — リスク受容の判断
5. **設計書通りの実装が困難または非効率と判明した場合** — 設計変更の要否判断
6. **テストカバレッジがプロジェクト基準を下回る場合** — テスト追加 vs 基準緩和の判断

---

# フェーズ詳細

## §1. 要件理解

### 1-1. 要件の読み解きと整理

**目的：** 与えられた要件を構造化し、曖昧さや不足を洗い出す

**作業内容：**
- 機能要件の抽出と一覧化（ユースケース単位）
- 非機能要件の抽出（性能・セキュリティ・可用性など）
- 前提条件・制約条件の明確化
- 用語の定義（ユビキタス言語の整理）
- スコープ内/スコープ外の境界線定義

**成果物：**
- 要件整理ドキュメント（ユースケース一覧、用語集、スコープ定義）

### 1-2. 👤 要件確認

**人間への確認事項：**
- 要件の解釈に齟齬がないか
- 優先度・スコープの合意
- 不明点への回答
- ビジネス上の背景や意図の補足

**通過条件：** 人間が要件整理ドキュメントを承認すること

---

## §2. 既存実装調査

### 2-1. 調査スコープの策定

**目的：** 何を・なぜ・どこまで調査するかを先に定義し、調査の発散を防ぐ

**調査スコープの検討項目：**
- 変更対象となるモジュール・パッケージの特定
- 変更対象が依存しているモジュールの特定（上流・下流）
- 関連するDB テーブル・API エンドポイント
- 既存のテストコードの有無と品質
- 既存の設計ドキュメント・ADR の有無

**成果物：**
- 調査計画書（調査対象一覧、調査の問い、期待するアウトプット）

### 2-2. 既存コードベースの調査

**作業内容：**
- ディレクトリ構成・レイヤー構成の把握
- 既存の設計パターン・アーキテクチャの特定
- 命名規則・コーディング規約の抽出
- 共通ユーティリティ・ヘルパーの把握
- エラーハンドリングパターンの把握
- ログ出力方針の把握
- 既存テストの構成・テスティングフレームワーク・モック戦略の把握

**成果物：**
- 既存実装調査レポート（構成図、依存関係、パターン一覧、規約メモ）

### 2-3. 🤖 AI自己レビュー：調査の十分性

**観点：**
- [ ] 変更影響範囲が漏れなく特定されているか
- [ ] 既存の規約・パターンを十分に把握できたか
- [ ] 再利用可能な既存コンポーネントを見落としていないか
- [ ] 既存テストの方針を理解できたか

---

## §3. 技術スタック検討

### 3-1. 新規技術の要否判断

**目的：** 新しいライブラリ・フレームワーク・ツールの導入が必要かを判断する

**検討項目：**
- 既存技術スタックで要件を満たせるか
- 新規導入が必要な場合、候補技術の比較
- ライセンス・メンテナンス状況・コミュニティの健全性
- セキュリティ脆弱性の履歴
- 既存スタックとの互換性・統合コスト
- チームの学習コスト

### 3-2. ADR（Architecture Decision Record）作成（該当時のみ）

**ADR テンプレート：**
```
# ADR-XXX: [タイトル]

## ステータス
提案 / 承認済 / 廃止

## コンテキスト
なぜこの意思決定が必要か

## 検討した選択肢
### 選択肢A: ...
- メリット:
- デメリット:

### 選択肢B: ...
- メリット:
- デメリット:

## 決定
何を選び、なぜ選んだか

## 影響
この決定により生じる影響・トレードオフ
```

### 3-3. 🤖 AI自己レビュー：技術選定の妥当性

**観点：**
- [ ] 既存技術で代替可能な手段を十分に検討したか
- [ ] 選定理由が要件に紐づいているか（技術的興味による選定になっていないか）
- [ ] 長期的な保守コストを考慮したか
- [ ] セキュリティリスクを評価したか

### 3-4. 👤 技術選定承認（ADRがある場合）

**通過条件：** ADRが承認されること（新規技術がない場合はスキップ）

---

## §4. クラス設計

### 4-1. アーキテクチャレベル設計

**目的：** モジュール間の責務分割と依存方向を定義する

**作業内容：**
- レイヤー構成の決定（既存アーキテクチャに準拠）
- モジュール・パッケージの分割方針
- 依存方向の定義（依存性逆転の適用箇所の判断）
- 外部システムとの境界定義（Anti-Corruption Layer の検討）

**成果物：**
- モジュール構成図
- 依存関係図

### 4-2. 詳細クラス設計

**目的：** 各クラスの責務・インタフェース・関係を定義する

**設計原則（ミノ駆動氏の提唱する変更容易性を考慮）：**
- 単一責務の徹底（1クラス1関心事）
- 閉じた操作・完全コンストラクタによる不正状態の排除
- 値オブジェクトの積極的活用（プリミティブ型の回避）
- ファーストクラスコレクションによるコレクション操作のカプセル化
- ストラテジパターンによる条件分岐の排除
- ポリシーパターンによるビジネスルールの凝集
- 不変オブジェクトの優先（副作用の最小化）
- Tell, Don't Ask の徹底

**成果物に含める内容：**
- クラス図（クラス名・フィールド・メソッドシグネチャ・可視性）
- 各クラスの責務説明（1〜2文）
- クラス間の関係（依存・継承・コンポジション）
- インタフェース定義（公開APIの契約）
- 例外設計（どの例外をどこで投げ・どこでキャッチするか）
- ドメインイベント設計（該当する場合）

**成果物：**
- 詳細クラス設計書

### 4-3. 🤖 設計レビュー（多観点並列）

> 以下の観点で包括的なAI自己レビューを行う。問題が見つかった場合は設計を修正し、再レビューする。

**変更容易性：**
- [ ] 各クラスの責務が単一か（複数の変更理由を持っていないか）
- [ ] プリミティブ型の引き回しが残っていないか（値オブジェクト化の余地）
- [ ] 不正な状態を表現できてしまわないか（完全コンストラクタ・ファクトリ）
- [ ] 条件分岐がストラテジ/ポリシーで表現できないか
- [ ] 変更が波及する範囲が局所化されているか
- [ ] 新しい要件追加時に既存コードの修正なしに拡張可能か（OCP）
- [ ] 過度な抽象化や投機的設計になっていないか（YAGNI）

**既存実装との整合性：**
- [ ] 既存のアーキテクチャパターンに従っているか
- [ ] 命名規則が既存コードと統一されているか
- [ ] 既存の共通コンポーネント（バリデーション、エラーハンドリング等）を活用しているか
- [ ] 依存方向が既存の方針と一致しているか
- [ ] 既存APIとのインタフェースに矛盾がないか
- [ ] DBスキーマ変更が必要な場合、マイグレーション戦略が明確か

**テスタビリティ：**
- [ ] 各クラスが単体でテスト可能か（外部依存が注入可能か）
- [ ] インタフェースを介した依存で、モック差し替えが容易か
- [ ] 副作用を持つ処理が分離されているか（純粋関数の最大化）
- [ ] テスト時にテストデータの構築が容易か（Builder/Factory の提供）
- [ ] 状態遷移のテストが容易な設計か
- [ ] privateメソッドに重要ロジックが隠蔽されすぎていないか

**セキュリティ：**
- [ ] 入力値のバリデーション方針が明確か
- [ ] 認証・認可の境界が適切か
- [ ] 機密データの取り扱い方針（暗号化・マスキング・ログ除外）が定義されているか
- [ ] SQLインジェクション・XSS等の一般的脆弱性への対策が設計に組み込まれているか
- [ ] 外部入力を信頼していないか（ゼロトラスト原則）

**NG時：** Phase 4 の設計作業に戻り修正

---

## §5. テスト設計

### 5-1. テスト方針の策定

**作業内容：**
- テストレベルの定義（Unit / Integration / E2E のスコープ）
- 今回のスコープでのテスト対象の優先度付け
- テストダブル戦略（Mock / Stub / Fake の使い分け方針）
- テストデータ戦略（テストフィクスチャの管理方針）

### 5-2. テストケース設計

**作業内容：**
- テスト対象メソッドの洗い出し
- 各メソッドに対するテストケースの定義

**テストケース設計の観点：**
- 正常系：代表的な入力での期待動作
- 異常系：不正入力・境界値・null/空での振る舞い
- 境界値：数値の上限下限、文字列長の境界、コレクションの空/1件/複数件
- 状態遷移：状態の前後関係、不正な遷移の拒否
- 副作用：イベント発行・ログ出力・外部呼び出しの検証
- 組み合わせ：複数条件の組み合わせ（All-pairs 等での削減検討）

**成果物：**
- テストケース一覧（テスト対象、テスト名、事前条件、入力、期待結果）

### 5-3. 🤖 AI自己レビュー：テスト設計の網羅性レビュー

**観点：**
- [ ] 全パブリックメソッドがテスト対象になっているか
- [ ] 正常系・異常系・境界値が網羅されているか
- [ ] ビジネスルールの分岐がすべてテストケースに対応しているか
- [ ] テストケース間に重複・冗長がないか
- [ ] テストの独立性が確保されているか（テスト間の依存がないか）
- [ ] エッジケースが考慮されているか（並行処理、タイムゾーン等）
- [ ] 例外設計で定義した例外がすべてテストされているか

---

## §6. Draft PR作成

### 6-1. ブランチ作成とDraft PR

**作業内容：**
- フィーチャーブランチを作成
- 以下の成果物をブランチにコミット：
  - 受け入れ基準（要件から導出した完了条件）
  - 設計書（モジュール構成図、詳細クラス設計書）
  - テスト設計（テスト方針、テストケース一覧）
  - ADR（該当時）
- Draft PRを作成

**PR本文テンプレート：**
```markdown
## 概要
<!-- 変更の目的と背景を簡潔に -->

## 変更内容
<!-- 主要な変更点を箇条書きで -->

## 設計判断
<!-- 重要な設計判断とその理由 -->

## テスト
<!-- テスト方針・カバレッジ・実行結果 -->

## 影響範囲
<!-- 変更による影響範囲 -->

## チェックリスト
- [ ] 設計レビュー済み
- [ ] AI自己レビュー完了
- [ ] 全テストパス
- [ ] formatter/linter エラーなし
- [ ] ドキュメント更新済み（該当時）
- [ ] マイグレーション手順確認済み（該当時）

## 関連資料
<!-- 設計書・ADR・チケットへのリンク -->
```

---

## §7. 👤 PR上で設計レビュー

**人間の確認観点：**
- ドメインモデルの妥当性（ビジネスルールの正確な反映）
- アーキテクチャ方針との整合性
- チーム内の他機能との設計一貫性
- トレードオフの許容可否（例：パフォーマンスvs可読性）
- テスト設計の妥当性（ビジネス上重要なシナリオの漏れがないか）
- テストの粒度が適切か（過剰テスト / テスト不足）

**レビュー方式：**
- 人間がPR上でコメントにより指摘
- AIが指摘に対して修正対応し、コミットをプッシュ
- 人間が再レビューし、問題なければApprove

**通過条件：** PR上で設計がApproveされること（修正指摘がある場合は Phase 4 に戻る）

---

## §8. 実装ステップ計画

### 8-1. ステップ分割

**目的：** 設計書を実装可能な単位に分割し、段階的に実装する計画を立てる

**方針：**
- 依存関係の下流（ドメイン層）から上流（プレゼンテーション層）へ実装
- 値オブジェクト → エンティティ → ドメインサービス → アプリケーションサービス → インフラ層 → プレゼンテーション層
- 各ステップはテストとセットで実装（TDDサイクルが望ましい）
- 各ステップは独立してcommit可能な単位とする

**成果物：**
- ステップ一覧（ステップ番号、実装範囲、受け入れ基準）

### 8-2. ステップ毎の受け入れ基準

**各ステップに以下を定義：**
- 実装すべきクラス・メソッドの一覧
- パスすべきテストケースの一覧
- formatter/linter エラーがないこと
- 設計書との一致性（逸脱がある場合は理由を記録）

---

## §9. ステップ実装

> 各ステップについて、以下のサイクルを繰り返す。

### 9-1. ステップ実装サイクル

**各ステップで行う作業：**

1. **コード実装**
   - クラス設計書に忠実に実装する（設計からの逸脱が必要な場合は理由を記録）
   - 既存コードベースの規約・パターンに従う
   - コメントは「なぜ」を書く（「何を」はコードで表現する）
   - TODOコメントを残す場合は対応チケット番号を付与
   - マジックナンバー・マジックストリングの排除

2. **テスト実装**
   - テスト設計書に基づくテストコードの実装
   - テストヘルパー・テストフィクスチャの実装
   - テストの可読性確認（Arrange-Act-Assert パターン、テスト名の明確さ）

3. **formatter / linter 実行**
   - プロジェクト標準の formatter を実行
   - プロジェクト標準の linter を実行
   - 静的解析ツールの実行（該当時）
   - すべての警告・エラーを解消

4. **テスト実行・結果確認**
   - 全テストの実行と全件パスの確認
   - カバレッジ計測と基準値の確認
   - 失敗テストの原因分析と修正

5. **ステップの受け入れ基準確認**
   - Phase 8で定義した当該ステップの受け入れ基準をすべて満たしているか検証

6. **commit**
   - 受け入れ基準を満たしたステップをcommit

---

## §10. 🤖 コードレビュー（多観点並列）

> 全ステップの実装完了後、以下の観点で包括的なAI自己レビューを行う。各観点で問題が見つかった場合は修正し、再レビューする。

### 10-1. 🤖 コード品質レビュー

**観点：**
- [ ] メソッドの長さが適切か（目安：20行以内）
- [ ] ネストが深くないか（目安：3段以内、早期リターンの活用）
- [ ] 重複コードがないか（DRY原則、ただし誤った共通化に注意）
- [ ] 命名が意図を正確に伝えているか
- [ ] 不要なコメントがないか（コードで語れているか）
- [ ] デッドコード・未使用importがないか
- [ ] エラーメッセージが原因特定に十分な情報を含むか

### 10-2. 🤖 セキュリティレビュー

**観点：**
- [ ] 入力バリデーションが適切に実装されているか
- [ ] SQLインジェクション対策（パラメータバインディング）
- [ ] XSS対策（出力エスケープ）
- [ ] 認証・認可チェックの漏れがないか
- [ ] 機密情報がログに出力されていないか
- [ ] 依存ライブラリに既知の脆弱性がないか
- [ ] CORS・CSRFの設定が適切か（該当する場合）
- [ ] シークレット・APIキーがハードコードされていないか

### 10-3. 🤖 パフォーマンスレビュー

**観点：**
- [ ] N+1クエリが発生していないか
- [ ] 不要なオブジェクト生成がループ内にないか
- [ ] 適切なデータ構造が選択されているか（List vs Set vs Map）
- [ ] DBインデックスの追加が必要か
- [ ] キャッシュの活用が適切か
- [ ] 大量データ処理時のメモリ使用量は適切か（ストリーム処理の検討）
- [ ] 外部API呼び出しのタイムアウト・リトライが設定されているか

### 10-4. 🤖 保守性レビュー

**観点：**
- [ ] 新規メンバーが読んで理解できるか
- [ ] 変更時の影響範囲が予測可能か
- [ ] ログ出力が運用時のデバッグに十分か
- [ ] 設定値が外部化されているか（ハードコードされていないか）
- [ ] エラーハンドリングが一貫しているか
- [ ] ドキュメント（Javadoc/JSDoc等）が公開APIに付与されているか
- [ ] 既存コードとのスタイル一貫性が保たれているか

### 10-5. レビュー結果の集約

**成果物：**
- レビュー指摘事項一覧（観点・該当箇所・指摘内容・対応方針・対応結果）
- 全指摘への対応完了を確認

**NG時：** Phase 9 に戻り修正

---

## §11. 受け入れ基準の検証

**目的：** 全体の受け入れ基準を満たしているかを最終確認する

**作業内容：**
- Phase 6でコミットした受け入れ基準の一覧を参照
- 各受け入れ基準に対して、充足状況を検証
- 全テストの通過を確認
- formatter/linter エラーがないことを確認

**未達項目がある場合：** Phase 9 に戻り追加実装

---

## §12. PR Ready化

### 12-1. PR本文の最終更新

**作業内容：**
- PR本文を最終状態に更新：
  - 実装結果の反映（変更内容の確定）
  - テスト結果・カバレッジの記載
  - AI自己レビュー結果サマリの記載
  - 設計からの逸脱記録（該当時）
  - チェックリストの更新
- Draft → Ready for Review に変更

---

## §13. 👤 PR上でコードレビュー

**人間の確認観点：**
- ビジネスロジックの正確性（ドメインエキスパートとしての判断）
- コードベース全体との一貫性（チームの暗黙知との整合）
- 運用・デプロイ上の懸念事項
- テストの妥当性（過不足の判断）
- AI自己レビューの指摘対応の妥当性

**レビュー方式：**
- 人間がPR上でコメントにより指摘
- AIが指摘に対して修正対応し、コミットをプッシュ
- 人間が再レビューし、問題なければApprove

**通過条件：** PR上でApproveされること（修正指摘がある場合は Phase 9 に戻る）
