# AI駆動開発ワークフロー

## 概要

本ドキュメントは、AIが要件から実装までを行う際のワークフロー（作業の流れ）を定義する。
前半の「ワークフロー定義」で全体像を把握し、後半の「フェーズ詳細」で各フェーズの具体的な作業内容・成果物・レビュー観点を確認する。

---

# ワークフロー定義

## フェーズ一覧

| # | フェーズ | 区分 | レビュー主体 | 詳細参照 |
|---|---------|------|-------------|---------|
| 1 | 要件理解・分析 | 分析 | 🤖 AI自己 → 👤 人間 | §1 |
| 2 | 既存実装の調査 | 調査 | 🤖 AI自己 | §2 |
| 3 | 技術スタック検討 | 設計 | 🤖 AI自己 → 👤 人間 | §3 |
| 4 | クラス設計 | 設計 | 🤖 AI自己（多観点） | §4 |
| 5 | 設計レビューゲート | レビュー | 👤 人間 | §5 |
| 6 | テスト設計 | 設計 | 🤖 AI自己 | §6 |
| 7 | テスト設計レビューゲート | レビュー | 👤 人間 | §7 |
| 8 | プログラム実装 | 実装 | 🤖 AI自己 | §8 |
| 9 | テスト実装・実行 | 実装 | 🤖 AI自己 | §9 |
| 10 | コードレビューゲート | レビュー | 🤖 AI自己（多観点） | §10 |
| 11 | 最終レビューゲート | レビュー | 👤 人間 | §11 |
| 12 | PR作成・提出 | 納品 | 👤 人間 | §12 |

## フロー全体図

```
Phase 1: 要件理解
  └→ 🤖 要件分析レビュー
  └→ 👤 要件確認ゲート ─── NG → Phase 1 へ戻る
      │
Phase 2: 既存実装調査
  └→ 🤖 調査十分性レビュー
      │
Phase 3: 技術スタック検討
  └→ 🤖 技術選定レビュー
  └→ 👤 技術選定承認ゲート（ADR時）─── NG → Phase 3 へ戻る
      │
Phase 4: クラス設計
  └→ 🤖 変更容易性レビュー
  └→ 🤖 既存整合性レビュー
  └→ 🤖 テスタビリティレビュー
  └→ 🤖 セキュリティ設計レビュー
      │
Phase 5: 👤 設計承認ゲート ─── NG → Phase 4 へ戻る
      │
Phase 6: テスト設計
  └→ 🤖 テスト網羅性レビュー
      │
Phase 7: 👤 テスト設計承認ゲート ─── NG → Phase 6 へ戻る
      │
Phase 8: プログラム実装
  └→ formatter/linter 実行
  └→ 🤖 設計一致性確認
      │
Phase 9: テスト実装・実行
  └→ 🤖 テスト品質レビュー
      │
Phase 10: 🤖 コードレビューゲート（多観点）
  ├→ コード品質
  ├→ セキュリティ
  ├→ パフォーマンス
  └→ 保守性
      │
Phase 11: 👤 最終レビューゲート ─── NG → Phase 8 へ戻る
      │
Phase 12: PR作成・提出
  └→ 👤 チームPRレビュー
```

## 👤 人間レビューゲート一覧

| ゲート | フェーズ | 理由 | NG時の戻り先 |
|-------|---------|------|-------------|
| 要件確認 | 1 | 要件の解釈ミスは後工程すべてに波及するため | Phase 1 |
| 技術選定承認 | 3 | 新規技術導入はプロジェクト全体に影響する不可逆性の高い決定のため | Phase 3 |
| 設計承認 | 5 | 設計はコードの骨格であり実装後の手戻りコストが大きいため | Phase 4 |
| テスト設計承認 | 7 | テスト網羅性はドメイン知識に依存し、AIが見落としがちなエッジケースを補完するため | Phase 6 |
| 最終レビュー | 11 | ビジネス意図・チーム設計哲学・運用観点を人間が最終判断するため | Phase 8 |

## レビュー観点マトリクス

設計・コードそれぞれに「いつ」「何の観点で」レビューするかの一覧。

| レビュー観点 | 設計フェーズ (4-5) | テスト設計 (6-7) | コードフェーズ (8-11) | 主体 |
|---|---|---|---|---|
| 変更容易性 / SRP / OCP | ✅ 4-3 | - | ✅ 10-4 | 🤖 |
| 既存実装との整合性 | ✅ 4-4 | ✅ 6-3 | ✅ 10-1, 10-4 | 🤖 |
| テスタビリティ | ✅ 4-5 | - | - | 🤖 |
| テスト網羅性 | - | ✅ 6-3 | ✅ 9-3 | 🤖 |
| セキュリティ | ✅ 4-6 | - | ✅ 10-2 | 🤖 |
| パフォーマンス | - | - | ✅ 10-3 | 🤖 |
| 保守性 / 可読性 | ✅ 4-3 | - | ✅ 10-4 | 🤖 |
| コード品質 | - | - | ✅ 10-1 | 🤖 |
| ビジネスロジック正確性 | ✅ 5 | ✅ 7 | ✅ 11 | 👤 |
| チーム方針整合性 | ✅ 5 | ✅ 7 | ✅ 11 | 👤 |
| 運用・デプロイ観点 | - | - | ✅ 11 | 👤 |

## エスカレーション基準

以下の場合、AIは独断で進めず人間に判断を仰ぐこと：

1. **設計上の重大なトレードオフ判明時** — パフォーマンスと可読性の二律背反など
2. **要件の解釈が複数通り可能な場合** — ドメイン知識に基づく判断が必要
3. **既存コードにバグまたは設計上の問題を発見した場合** — スコープ外修正の要否判断
4. **セキュリティリスクが高い実装が必要な場合** — リスク受容の判断
5. **設計書通りの実装が困難または非効率と判明した場合** — 設計変更の要否判断
6. **テストカバレッジがプロジェクト基準を下回る場合** — テスト追加 vs 基準緩和の判断

---

# フェーズ詳細

## §1. 要件理解・分析

### 1-1. 要件の読み解きと整理

**目的：** 与えられた要件を構造化し、曖昧さや不足を洗い出す

**作業内容：**
- 機能要件の抽出と一覧化（ユースケース単位）
- 非機能要件の抽出（性能・セキュリティ・可用性など）
- 前提条件・制約条件の明確化
- 用語の定義（ユビキタス言語の整理）
- スコープ内/スコープ外の境界線定義

**成果物：**
- 要件整理ドキュメント（ユースケース一覧、用語集、スコープ定義）

### 1-2. 🤖 AI自己レビュー：要件分析の妥当性

**観点：**
- [ ] 要件に曖昧な表現が残っていないか
- [ ] ユースケースの正常系・異常系・境界値が網羅されているか
- [ ] 非機能要件の考慮漏れがないか（性能、セキュリティ、アクセシビリティ、国際化）
- [ ] 要件間の矛盾・依存関係が整理されているか
- [ ] スコープが適切に区切られているか

### 1-3. 👤 人間レビューゲート：要件確認

**人間への確認事項：**
- 要件の解釈に齟齬がないか
- 優先度・スコープの合意
- 不明点への回答
- ビジネス上の背景や意図の補足

**ゲート通過条件：** 人間が要件整理ドキュメントを承認すること

---

## §2. 既存実装の調査

### 2-1. 調査スコープの策定

**目的：** 何を・なぜ・どこまで調査するかを先に定義し、調査の発散を防ぐ

**調査スコープの検討項目：**
- 変更対象となるモジュール・パッケージの特定
- 変更対象が依存しているモジュールの特定（上流・下流）
- 関連するDB テーブル・API エンドポイント
- 既存のテストコードの有無と品質
- 既存の設計ドキュメント・ADR の有無

**成果物：**
- 調査計画書（調査対象一覧、調査の問い、期待するアウトプット）

### 2-2. 既存コードベースの調査

**作業内容：**
- ディレクトリ構成・レイヤー構成の把握
- 既存の設計パターン・アーキテクチャの特定
- 命名規則・コーディング規約の抽出
- 共通ユーティリティ・ヘルパーの把握
- エラーハンドリングパターンの把握
- ログ出力方針の把握
- 既存テストの構成・テスティングフレームワーク・モック戦略の把握

**成果物：**
- 既存実装調査レポート（構成図、依存関係、パターン一覧、規約メモ）

### 2-3. 🤖 AI自己レビュー：調査の十分性

**観点：**
- [ ] 変更影響範囲が漏れなく特定されているか
- [ ] 既存の規約・パターンを十分に把握できたか
- [ ] 再利用可能な既存コンポーネントを見落としていないか
- [ ] 既存テストの方針を理解できたか

---

## §3. 技術スタック検討

### 3-1. 新規技術の要否判断

**目的：** 新しいライブラリ・フレームワーク・ツールの導入が必要かを判断する

**検討項目：**
- 既存技術スタックで要件を満たせるか
- 新規導入が必要な場合、候補技術の比較
- ライセンス・メンテナンス状況・コミュニティの健全性
- セキュリティ脆弱性の履歴
- 既存スタックとの互換性・統合コスト
- チームの学習コスト

### 3-2. ADR（Architecture Decision Record）作成（該当時のみ）

**ADR テンプレート：**
```
# ADR-XXX: [タイトル]

## ステータス
提案 / 承認済 / 廃止

## コンテキスト
なぜこの意思決定が必要か

## 検討した選択肢
### 選択肢A: ...
- メリット:
- デメリット:

### 選択肢B: ...
- メリット:
- デメリット:

## 決定
何を選び、なぜ選んだか

## 影響
この決定により生じる影響・トレードオフ
```

### 3-3. 🤖 AI自己レビュー：技術選定の妥当性

**観点：**
- [ ] 既存技術で代替可能な手段を十分に検討したか
- [ ] 選定理由が要件に紐づいているか（技術的興味による選定になっていないか）
- [ ] 長期的な保守コストを考慮したか
- [ ] セキュリティリスクを評価したか

### 3-4. 👤 人間レビューゲート：技術選定承認（ADRがある場合）

**ゲート通過条件：** ADRが承認されること（新規技術がない場合はスキップ）

---

## §4. クラス設計

### 4-1. アーキテクチャレベル設計

**目的：** モジュール間の責務分割と依存方向を定義する

**作業内容：**
- レイヤー構成の決定（既存アーキテクチャに準拠）
- モジュール・パッケージの分割方針
- 依存方向の定義（依存性逆転の適用箇所の判断）
- 外部システムとの境界定義（Anti-Corruption Layer の検討）

**成果物：**
- モジュール構成図
- 依存関係図

### 4-2. 詳細クラス設計

**目的：** 各クラスの責務・インタフェース・関係を定義する

**設計原則（ミノ駆動氏の提唱する変更容易性を考慮）：**
- 単一責務の徹底（1クラス1関心事）
- 閉じた操作・完全コンストラクタによる不正状態の排除
- 値オブジェクトの積極的活用（プリミティブ型の回避）
- ファーストクラスコレクションによるコレクション操作のカプセル化
- ストラテジパターンによる条件分岐の排除
- ポリシーパターンによるビジネスルールの凝集
- 不変オブジェクトの優先（副作用の最小化）
- Tell, Don't Ask の徹底

**成果物に含める内容：**
- クラス図（クラス名・フィールド・メソッドシグネチャ・可視性）
- 各クラスの責務説明（1〜2文）
- クラス間の関係（依存・継承・コンポジション）
- インタフェース定義（公開APIの契約）
- 例外設計（どの例外をどこで投げ・どこでキャッチするか）
- ドメインイベント設計（該当する場合）

**成果物：**
- 詳細クラス設計書

### 4-3. 🤖 AI自己レビュー①：変更容易性レビュー

**観点：**
- [ ] 各クラスの責務が単一か（複数の変更理由を持っていないか）
- [ ] プリミティブ型の引き回しが残っていないか（値オブジェクト化の余地）
- [ ] 不正な状態を表現できてしまわないか（完全コンストラクタ・ファクトリ）
- [ ] 条件分岐がストラテジ/ポリシーで表現できないか
- [ ] 変更が波及する範囲が局所化されているか
- [ ] 新しい要件追加時に既存コードの修正なしに拡張可能か（OCP）
- [ ] 過度な抽象化や投機的設計になっていないか（YAGNI）

### 4-4. 🤖 AI自己レビュー②：既存実装との整合性レビュー

**観点：**
- [ ] 既存のアーキテクチャパターンに従っているか
- [ ] 命名規則が既存コードと統一されているか
- [ ] 既存の共通コンポーネント（バリデーション、エラーハンドリング等）を活用しているか
- [ ] 依存方向が既存の方針と一致しているか
- [ ] 既存APIとのインタフェースに矛盾がないか
- [ ] DBスキーマ変更が必要な場合、マイグレーション戦略が明確か

### 4-5. 🤖 AI自己レビュー③：テスタビリティレビュー

**観点：**
- [ ] 各クラスが単体でテスト可能か（外部依存が注入可能か）
- [ ] インタフェースを介した依存で、モック差し替えが容易か
- [ ] 副作用を持つ処理が分離されているか（純粋関数の最大化）
- [ ] テスト時にテストデータの構築が容易か（Builder/Factory の提供）
- [ ] 状態遷移のテストが容易な設計か
- [ ] privateメソッドに重要ロジックが隠蔽されすぎていないか

### 4-6. 🤖 AI自己レビュー④：セキュリティ設計レビュー

**観点：**
- [ ] 入力値のバリデーション方針が明確か
- [ ] 認証・認可の境界が適切か
- [ ] 機密データの取り扱い方針（暗号化・マスキング・ログ除外）が定義されているか
- [ ] SQLインジェクション・XSS等の一般的脆弱性への対策が設計に組み込まれているか
- [ ] 外部入力を信頼していないか（ゼロトラスト原則）

---

## §5. 👤 人間レビューゲート：設計承認

**人間への提示物：**
1. モジュール構成図・依存関係図
2. 詳細クラス設計書
3. 各AI自己レビューの結果サマリ
4. ADR（該当時）
5. 設計上の判断ポイントと代替案

**人間に判断を求める事項：**
- ドメインモデルの妥当性（ビジネスルールの正確な反映）
- アーキテクチャ方針との整合性
- チーム内の他機能との設計一貫性
- トレードオフの許容可否（例：パフォーマンスvs可読性）

**ゲート通過条件：** 設計書が承認されること（修正指摘がある場合は Phase 4 に戻る）

---

## §6. テスト設計

### 6-1. テスト方針の策定

**作業内容：**
- テストレベルの定義（Unit / Integration / E2E のスコープ）
- 今回のスコープでのテスト対象の優先度付け
- テストダブル戦略（Mock / Stub / Fake の使い分け方針）
- テストデータ戦略（テストフィクスチャの管理方針）

### 6-2. ユニットテストケース設計

**作業内容：**
- テスト対象メソッドの洗い出し
- 各メソッドに対するテストケースの定義

**テストケース設計の観点：**
- 正常系：代表的な入力での期待動作
- 異常系：不正入力・境界値・null/空での振る舞い
- 境界値：数値の上限下限、文字列長の境界、コレクションの空/1件/複数件
- 状態遷移：状態の前後関係、不正な遷移の拒否
- 副作用：イベント発行・ログ出力・外部呼び出しの検証
- 組み合わせ：複数条件の組み合わせ（All-pairs 等での削減検討）

**成果物：**
- テストケース一覧（テスト対象、テスト名、事前条件、入力、期待結果）

### 6-3. 🤖 AI自己レビュー：テスト設計の網羅性レビュー

**観点：**
- [ ] 全パブリックメソッドがテスト対象になっているか
- [ ] 正常系・異常系・境界値が網羅されているか
- [ ] ビジネスルールの分岐がすべてテストケースに対応しているか
- [ ] テストケース間に重複・冗長がないか
- [ ] テストの独立性が確保されているか（テスト間の依存がないか）
- [ ] エッジケースが考慮されているか（並行処理、タイムゾーン等）
- [ ] 例外設計で定義した例外がすべてテストされているか

---

## §7. 👤 人間レビューゲート：テスト設計承認

**人間に判断を求める事項：**
- ビジネス上重要なシナリオの漏れがないか
- テストの粒度が適切か（過剰テスト / テスト不足）
- 既存テスト方針との整合性

**ゲート通過条件：** テストケース一覧が承認されること

---

## §8. プログラム実装

### 8-1. 実装順序の計画

**方針：**
- 依存関係の下流（ドメイン層）から上流（プレゼンテーション層）へ実装
- 値オブジェクト → エンティティ → ドメインサービス → アプリケーションサービス → インフラ層 → プレゼンテーション層
- 各単位でテストとセットで実装（TDDサイクルが望ましい）

### 8-2. コード実装

**実装時の遵守事項：**
- クラス設計書に忠実に実装する（設計からの逸脱が必要な場合は理由を記録）
- 既存コードベースの規約・パターンに従う
- コメントは「なぜ」を書く（「何を」はコードで表現する）
- TODOコメントを残す場合は対応チケット番号を付与
- マジックナンバー・マジックストリングの排除

### 8-3. formatter / linter 実行

**作業内容：**
- プロジェクト標準の formatter を実行（例：Prettier, google-java-format, Black）
- プロジェクト標準の linter を実行（例：ESLint, Checkstyle, Flake8）
- 静的解析ツールの実行（例：SonarQube, SpotBugs, mypy）
- すべての警告・エラーを解消

### 8-4. 🤖 AI自己レビュー：実装と設計の一致性確認

**観点：**
- [ ] 設計書のクラス構成・メソッドシグネチャと一致しているか
- [ ] 設計からの逸脱がある場合、理由が記録されているか
- [ ] 設計で定義した例外設計が正しく実装されているか
- [ ] 設計で定義した依存方向が守られているか

---

## §9. テスト実装・実行

### 9-1. ユニットテスト実装

**作業内容：**
- テスト設計書に基づくテストコードの実装
- テストヘルパー・テストフィクスチャの実装
- テストの可読性確認（Arrange-Act-Assert パターン、テスト名の明確さ）

### 9-2. テスト実行・結果確認

**作業内容：**
- 全テストの実行と全件パスの確認
- カバレッジ計測と基準値の確認
- 失敗テストの原因分析と修正
- ミューテーションテストの実行（可能な場合）

### 9-3. 🤖 AI自己レビュー：テスト品質レビュー

**観点：**
- [ ] テスト設計書のケースがすべて実装されているか
- [ ] テストが1つの振る舞いのみを検証しているか（1テスト1アサーション原則）
- [ ] テスト名が検証内容を正確に表現しているか
- [ ] テストデータが適切か（本番データの漏洩がないか）
- [ ] テストの実行速度が許容範囲か
- [ ] フレイキーテスト（非決定的テスト）の兆候がないか

---

## §10. 🤖 AIコードレビューゲート（多観点）

> 実装完了後、以下の観点で包括的なAI自己レビューを行う。各観点で問題が見つかった場合は修正し、再レビューする。

### 10-1. 🤖 コード品質レビュー

**観点：**
- [ ] メソッドの長さが適切か（目安：20行以内）
- [ ] ネストが深くないか（目安：3段以内、早期リターンの活用）
- [ ] 重複コードがないか（DRY原則、ただし誤った共通化に注意）
- [ ] 命名が意図を正確に伝えているか
- [ ] 不要なコメントがないか（コードで語れているか）
- [ ] デッドコード・未使用importがないか
- [ ] エラーメッセージが原因特定に十分な情報を含むか

### 10-2. 🤖 セキュリティレビュー

**観点：**
- [ ] 入力バリデーションが適切に実装されているか
- [ ] SQLインジェクション対策（パラメータバインディング）
- [ ] XSS対策（出力エスケープ）
- [ ] 認証・認可チェックの漏れがないか
- [ ] 機密情報がログに出力されていないか
- [ ] 依存ライブラリに既知の脆弱性がないか
- [ ] CORS・CSRFの設定が適切か（該当する場合）
- [ ] シークレット・APIキーがハードコードされていないか

### 10-3. 🤖 パフォーマンスレビュー

**観点：**
- [ ] N+1クエリが発生していないか
- [ ] 不要なオブジェクト生成がループ内にないか
- [ ] 適切なデータ構造が選択されているか（List vs Set vs Map）
- [ ] DBインデックスの追加が必要か
- [ ] キャッシュの活用が適切か
- [ ] 大量データ処理時のメモリ使用量は適切か（ストリーム処理の検討）
- [ ] 外部API呼び出しのタイムアウト・リトライが設定されているか

### 10-4. 🤖 保守性レビュー

**観点：**
- [ ] 新規メンバーが読んで理解できるか
- [ ] 変更時の影響範囲が予測可能か
- [ ] ログ出力が運用時のデバッグに十分か
- [ ] 設定値が外部化されているか（ハードコードされていないか）
- [ ] エラーハンドリングが一貫しているか
- [ ] ドキュメント（Javadoc/JSDoc等）が公開APIに付与されているか
- [ ] 既存コードとのスタイル一貫性が保たれているか

### 10-5. レビュー結果の集約

**成果物：**
- レビュー指摘事項一覧（観点・該当箇所・指摘内容・対応方針・対応結果）
- 全指摘への対応完了を確認

---

## §11. 👤 人間最終レビューゲート

**人間への提示物：**
1. 実装コード（差分ビュー）
2. テストコードと実行結果（カバレッジレポート含む）
3. AI自己レビュー結果サマリ（§10の集約結果）
4. 設計からの逸脱記録（該当時）
5. 未解決事項・懸念事項リスト

**人間の確認観点：**
- ビジネスロジックの正確性（ドメインエキスパートとしての判断）
- コードベース全体との一貫性（チームの暗黙知との整合）
- 運用・デプロイ上の懸念事項
- テストの妥当性（過不足の判断）
- AI自己レビューの指摘対応の妥当性

**ゲート通過条件：** 人間がコード・テストを承認すること（修正指摘がある場合は Phase 8 に戻る）

---

## §12. PR作成・提出

### 12-1. PR本文の作成

**PR本文テンプレート：**
```markdown
## 概要
<!-- 変更の目的と背景を簡潔に -->

## 変更内容
<!-- 主要な変更点を箇条書きで -->

## 設計判断
<!-- 重要な設計判断とその理由 -->

## テスト
<!-- テスト方針・カバレッジ・実行結果 -->

## 影響範囲
<!-- 変更による影響範囲 -->

## チェックリスト
- [ ] 設計レビュー済み
- [ ] AI自己レビュー完了
- [ ] 全テストパス
- [ ] formatter/linter エラーなし
- [ ] ドキュメント更新済み（該当時）
- [ ] マイグレーション手順確認済み（該当時）

## 関連資料
<!-- 設計書・ADR・チケットへのリンク -->
```

### 12-2. 👤 チームPRレビュー

**通常のチームレビュープロセスに従う。**
