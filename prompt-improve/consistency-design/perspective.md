# 観点定義: 一貫性（設計レビュー）

## 概要
設計書が既存のコードベースのパターンや規約と整合しているかを評価する。この観点は「パターンが良いか悪いか」ではなく「既存と合っているか」を評価する。既存コードベースが一貫してアンチパターンを使用している場合でも、新しい設計が同じパターンに従っていれば「一貫している」と判定する。設計書に既存パターンとの一貫性を判定するための情報が欠落している場合も、一貫性が検証不能な項目として検出する。

## 評価スコープ

### 共通指針: 既存パターンの調査方法と一致判定基準
関連する既存モジュール（同一レイヤー、同一ドメイン）のパターンを優先的に参照し、コードベース全体の傾向で補完する。

**支配的パターンの定義**: 「支配的パターン」とは、関連モジュールで一貫して採用されているパターンを指す。目安として、関連モジュールの70%以上、またはコードベース全体の50%以上が採用しているパターンが該当する。

**一致の判断基準**: 命名規則では大文字小文字・区切り文字（camelCase/snake_case/kebab-case）の違いも不一致とみなす。アーキテクチャパターンでは実装方式の種類（例: エラーハンドリングがグローバルハンドラか個別catchか）が一致すれば一致とみなす。ディレクトリ構造では配置ルール（例: ドメイン別/レイヤー別）が一致すれば一致とみなす。

この指針は以下の全評価項目に適用される。

- 命名規約の既存パターンとの一致（変数名、関数名、クラス名、ファイル名、データモデル（テーブル名、カラム名）の命名パターンが既存コードベースに合っているか、およびこれらの命名規則が設計書に明記されているか）
- 既存アーキテクチャパターンとの一致（レイヤー構成、依存方向、責務分離が既存の実装方式と一致しているか、およびアーキテクチャ設計方針が設計書に明記されているか）
- 実装パターンの既存パターンとの一致（エラー処理パターン（グローバルハンドラ/個別catch等）、認証・認可の実装パターン（middleware/decorator/manual等）、データアクセスパターン（Repository/ORM直接呼び出し等）およびトランザクション管理パターン、非同期処理パターン（async/await/Promise/callback等）、ログ出力パターン（ログレベル、メッセージ形式、構造化ログの有無）が既存方式に合っているか、およびこれらのパターン方針が設計書に明記されているか）
- ディレクトリ構造・ファイル配置の既存パターンとの一致（既存の配置規則やフォルダ構成に合っているか、およびファイル配置方針が設計書に明記されているか）
- API/インターフェース設計・依存関係の既存パターンとの一致（既存APIのエンドポイント命名、レスポンス形式、エラー形式と一致しているか、既存のライブラリ選定基準、バージョン管理方針、パッケージマネージャの使い方、設定ファイル形式（YAML/JSON等）、環境変数命名規則に合っているか、およびこれらの設計方針が設計書に明記されているか）

## スコープ外
- セキュリティ脆弱性 → security で扱う
- パフォーマンスの問題 → performance で扱う
- 設計原則（SOLID等）の遵守、テスト設計の十分性 → structural-quality で扱う

## ボーナス/ペナルティの判定指針
- **ボーナス対象**: 設計書が既存の支配的パターンから逸脱しているが正解キーに含まれない不整合の検出（例: 「既存APIは全て kebab-case だが新API設計は camelCase を使用」）
- **ペナルティ対象**: セキュリティやパフォーマンスの指摘（一貫性に無関係）、既存パターンの良し悪しを評価する指摘（例: 「既存の命名規則がわかりにくい」）
- **判断に迷うケース1**: 既存パターン自体に問題がある場合の「改善提案」→ 一貫性の観点では既存パターンとの不整合の検出に留め、改善提案は structural-quality に委ねる
- **判断に迷うケース2**: API設計がRESTful原則に反する → structural-quality のスコープ（設計原則の遵守）、API命名が既存エンドポイントと不統一 → consistency のスコープ（既存との一致）
- **判断に迷うケース3**: レイヤー間の依存方向が一般的なベストプラクティスと異なる → structural-quality のスコープ、既存コードベースの依存方向と異なる → consistency のスコープ
