# 正解キー

## 実行条件
- **観点**: performance
- **対象**: design
- **埋め込み問題数**: 10問

## 埋め込み問題一覧

### P01: 診察履歴取得のN+1問題
- **カテゴリ**: I/O・ネットワーク効率
- **深刻度**: 重大
- **該当箇所**: セクション5 API設計 - 診察履歴関連API
- **問題の説明**: `GET /api/medical-records?patient_id={id}` APIで患者の診察履歴を取得する際、JPA遅延ロードにより患者情報・医師情報を個別に取得するN+1問題が発生する。患者が10件の診察履歴を持つ場合、1回のメインクエリ + 10回の患者取得 + 10回の医師取得 = 計21回のクエリが実行される可能性がある。
- **検出判定基準**:
  - ○（検出）: 診察履歴取得APIまたはリレーション取得におけるN+1問題を指摘し、JOINフェッチやバッチロードの必要性に言及している
  - △（部分検出）: 一般的なクエリ効率化の必要性に言及しているが、N+1問題の具体的な発生箇所や原因に触れていない
  - ×（未検出）: N+1問題への言及がない

### P02: 予約一覧取得のN+1問題
- **カテゴリ**: I/O・ネットワーク効率
- **深刻度**: 重大
- **該当箇所**: セクション5 API設計 - 予約関連API
- **問題の説明**: `GET /api/appointments?patient_id={id}` および `GET /api/appointments?doctor_id={id}&date={date}` で予約一覧を取得する際、各予約レコードに紐づく患者情報・医師情報が遅延ロードされ、N+1問題が発生する。医師の1日の予約が30件ある場合、1回のメインクエリ + 最大60回の関連取得が発生する。
- **検出判定基準**:
  - ○（検出）: 予約一覧取得APIにおけるN+1問題を指摘し、Eager FetchやJOIN戦略の必要性に言及している
  - △（部分検出）: 一覧取得APIの効率化が必要と指摘しているが、N+1問題の具体的メカニズムに触れていない
  - ×（未検出）: 予約一覧取得の効率性への言及がない

### P03: パフォーマンス目標値の欠如
- **カテゴリ**: レイテンシ・スループット設計
- **深刻度**: 重大
- **該当箇所**: セクション7 非機能要件
- **問題の説明**: 非機能要件にレスポンスタイム・スループットの具体的な数値目標が記載されていない。「最大500セッション」という同時接続数の記載はあるが、APIエンドポイントごとのレスポンスタイム目標（例: 予約作成APIは95パーセンタイルで500ms以内）やスループット要件（例: 秒間100リクエスト処理可能）が未定義。
- **検出判定基準**:
  - ○（検出）: レスポンスタイムまたはスループットの数値目標が欠如していることを明示的に指摘している
  - △（部分検出）: パフォーマンス要件の具体性不足に言及しているが、レスポンスタイム・スループットの具体的な数値目標の必要性に触れていない
  - ×（未検出）: パフォーマンス目標値への言及がない

### P04: appointmentsテーブルのインデックス設計欠如
- **カテゴリ**: レイテンシ・スループット設計
- **深刻度**: 中
- **該当箇所**: セクション4 データモデル - appointments
- **問題の説明**: appointmentsテーブルに対する検索クエリが頻繁に実行されるが（patient_id, doctor_id, appointment_date による検索）、これらのカラムへのインデックス定義が記載されていない。予約データが数万件に増加した場合、フルテーブルスキャンによりクエリ性能が劣化する。
- **検出判定基準**:
  - ○（検出）: appointmentsテーブルまたは主要な検索対象テーブルに対するインデックス設計の欠如を指摘している
  - △（部分検出）: データベース設計の効率化が必要と一般的に指摘しているが、インデックスの具体的な必要性に触れていない
  - ×（未検出）: インデックス設計への言及がない

### P05: キャッシュ戦略の欠如
- **カテゴリ**: キャッシュ戦略
- **深刻度**: 中
- **該当箇所**: セクション3 アーキテクチャ設計、セクション5 API設計
- **問題の説明**: 頻繁にアクセスされるマスタデータ（医師情報、医療機関情報）や予約可能枠情報に対するキャッシュ戦略が未定義。Redisをセッションストアとして使用する記載はあるが、データキャッシュ用途での活用方針が記載されていない。予約可能枠APIは同じ医師・日付に対して複数の患者から同時にアクセスされる可能性が高い。
- **検出判定基準**:
  - ○（検出）: マスタデータまたは予約可能枠などの頻繁アクセスデータに対するキャッシュ戦略の欠如を指摘している
  - △（部分検出）: キャッシュの必要性に一般的に言及しているが、具体的なキャッシュ対象データや戦略に触れていない
  - ×（未検出）: キャッシュ戦略への言及がない

### P06: データ増加に対する容量設計・パーティショニング戦略の欠如
- **カテゴリ**: スケーラビリティ
- **深刻度**: 中
- **該当箇所**: セクション4 データモデル、セクション7 非機能要件
- **問題の説明**: appointmentsテーブルとmedical_recordsテーブルは時系列データとして継続的に増加するが、データ量増加に対する容量設計やパーティショニング戦略（例: 月次パーティション、年次アーカイブ）が記載されていない。5年間の運用で数百万件のデータが蓄積される可能性がある。
- **検出判定基準**:
  - ○（検出）: 時系列データの容量増加に対するパーティショニング、アーカイブ戦略、または容量設計の欠如を指摘している
  - △（部分検出）: データ量増加への対応が必要と一般的に指摘しているが、パーティショニング・アーカイブの具体的手法に触れていない
  - ×（未検出）: データ増加対策への言及がない

### P07: 通知処理の同期実行による遅延
- **カテゴリ**: 並行処理・非同期処理
- **深刻度**: 中
- **該当箇所**: セクション3 アーキテクチャ設計 - データフロー
- **問題の説明**: データフローの記載から、予約作成後の通知送信（メール・SMS）が同期処理で実行される設計になっている（「5. NotificationServiceが確認メールを送信」）。Amazon SNS経由の通知送信は数秒かかる可能性があり、予約作成APIのレスポンスタイムを悪化させる。
- **検出判定基準**:
  - ○（検出）: 通知送信処理の非同期化の必要性を指摘し、メッセージキューやバックグラウンドジョブの活用に言及している
  - △（部分検出）: 通知処理の効率化が必要と指摘しているが、非同期処理の具体的手法に触れていない
  - ×（未検出）: 通知処理の非同期化への言及がない

### P08: 大量画像データの取り扱い戦略欠如（隣接領域：ストレージ効率）
- **カテゴリ**: メモリ・リソース管理
- **深刻度**: 軽微
- **該当箇所**: セクション2 技術スタック - ストレージ
- **問題の説明**: S3に画像保存する記載はあるが、画像の圧縮・リサイズ戦略、サムネイル生成、CDN配信による効率化の記載がない。診察券QRコードや医療画像が大量に保存される可能性があり、ストレージコストと配信速度に影響する。
- **検出判定基準**:
  - ○（検出）: 画像データの圧縮・リサイズ・CDN配信などの効率化戦略の欠如を指摘している
  - △（部分検出）: 画像配信の最適化が必要と一般的に指摘しているが、具体的手法に触れていない
  - ×（未検出）: 画像データ戦略への言及がない

### P09: パフォーマンスメトリクス収集・監視設計の欠如
- **カテゴリ**: 監視・オブザーバビリティ
- **深刻度**: 軽微
- **該当箇所**: セクション6 実装方針、セクション7 非機能要件
- **問題の説明**: ログ出力方針とヘルスチェックエンドポイントの記載はあるが、パフォーマンスメトリクス（レスポンスタイム、スループット、エラー率）の収集・監視設計が記載されていない。パフォーマンス劣化の早期検知や継続的な改善のためには、APM（Application Performance Monitoring）ツールやメトリクス収集基盤の設計が必要。
- **検出判定基準**:
  - ○（検出）: パフォーマンスメトリクスの収集・監視の必要性を指摘し、APMツールやメトリクス基盤の導入に言及している
  - △（部分検出）: 監視の必要性に一般的に言及しているが、パフォーマンスメトリクス特有の収集・可視化戦略に触れていない
  - ×（未検出）: パフォーマンスメトリクス監視への言及がない

### P10: 予約競合時の楽観的ロック戦略欠如（隣接領域：並行制御）
- **カテゴリ**: ロック戦略・並行制御
- **深刻度**: 軽微
- **該当箇所**: セクション6 実装方針 - エラーハンドリング方針
- **問題の説明**: 同じ予約枠に対して複数の患者が同時に予約リクエストを送信した場合の競合制御戦略が記載されていない。エラーメッセージに「予約済みです」という記載はあるが、データベースレベルでの楽観的ロック（バージョン管理）や悲観的ロック戦略の設計が不明。
- **検出判定基準**:
  - ○（検出）: 予約競合時の楽観的ロック・悲観的ロックなどの並行制御戦略の必要性を指摘している
  - △（部分検出）: 予約競合への対応が必要と一般的に指摘しているが、具体的なロック戦略に触れていない
  - ×（未検出）: 予約競合制御への言及がない

## ボーナス問題リスト

正解キーに含めないが、検出された場合にボーナスとして加点する問題の候補:

| ID | カテゴリ | 内容 | ボーナス条件 |
|----|---------|------|------------|
| B01 | データベース設計 | appointmentsテーブルの複合インデックス最適化（doctor_id + appointment_date + time_slot） | 複合インデックスの具体的な必要性を指摘 |
| B02 | API設計 | 予約可能枠API (`/api/schedules/available-slots`) のバッチ取得対応（複数日分を一度に取得） | バッチAPI化の提案 |
| B03 | キャッシュ戦略 | 予約可能枠データのキャッシュ無効化戦略（予約作成時にキャッシュクリア） | キャッシュ無効化タイミングの設計言及 |
| B04 | リソース管理 | データベースコネクションプールのサイジング設計 | コネクションプール設定の具体的言及 |
| B05 | スケーラビリティ | ECSタスク数の自動スケーリング閾値の妥当性検証（CPU 70%が適切か） | スケーリング閾値の妥当性への疑問提起 |
| B06 | 非同期処理 | 通知送信失敗時のリトライ戦略（SQS Dead Letter Queueの活用） | リトライ・DLQ設計への言及 |
| B07 | データベース設計 | medical_recordsテーブルの読み取り専用レプリカ活用 | リードレプリカ戦略の提案 |
| B08 | API設計 | ページネーション設計の欠如（診察履歴・予約一覧APIでのカーソルベースページング） | ページネーション戦略への言及 |
| B09 | キャッシュ戦略 | セッションデータのTTL設計（Redisメモリ効率化） | セッションTTL最適化への言及 |
| B10 | 監視 | スロークエリログの収集設計 | スロークエリ監視への言及 |
