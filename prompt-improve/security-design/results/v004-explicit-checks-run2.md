# セキュリティ設計レビュー結果

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | Repudiation（否認防止）とDenial of Service対策が設計されていない |
| 認証・認可設計 | 2 | JWTトークンの有効期限が長すぎ、リフレッシュトークンが未実装 |
| データ保護 | 1 | マイナンバー・口座番号が平文保存、秘密情報が環境変数に平文設定 |
| 入力検証設計 | 2 | パラメータ検証の範囲が不明確、冪等性保証が未設計、ログに個人情報が出力される |
| インフラ・依存関係 | 2 | シークレット管理が不適切、依存関係の脆弱性管理が不十分 |
| **総合** | **1.8** | |

## 1. 重大な問題（設計の修正が必須）

### 1-1. マイナンバー・口座番号の平文保存
- **問題**: セクション4.1で「マイナンバー・口座番号はデータベースに保存（暗号化なし）」と明記されており、個人番号保護法違反の重大なリスク
- **影響**: データベース侵害時にマイナンバー・銀行口座情報が漏洩し、なりすまし被害や法的制裁（特定個人情報保護委員会からの勧告・命令、2年以下の懲役または100万円以下の罰金）を受ける可能性が高い
- **推奨対策**:
  - マイナンバーと口座番号をAES-256-GCMで暗号化してデータベース保存
  - 暗号化鍵はAWS KMS（Customer Managed Key）で管理し、アプリケーション層で鍵のローテーション（90日ごと）を実装
  - データベース列に`encrypted_my_number`、`encrypted_bank_account`を追加し、平文列を削除
- **該当箇所**: セクション4.1 employees テーブル、セクション7.2

### 1-2. JWT署名鍵とデータベースパスワードの平文環境変数保存
- **問題**: セクション6.5で「秘密情報（JWT署名鍵、データベースパスワード）は環境変数に平文で設定」と記載されており、コンテナイメージやログからの漏洩リスク
- **影響**: JWT署名鍵が漏洩すると攻撃者が任意のユーザーとして認証可能になり、全テナントのデータへのアクセスが可能。データベースパスワード漏洩時は全データの読み取り・改ざんが可能
- **推奨対策**:
  - AWS Secrets Managerにシークレットを保存し、アプリケーション起動時にSDK経由で取得
  - Spring Cloud AWSの`@Value("${aws.secretsmanager:/prod/hr-system/jwt-key}")`を使用
  - ECSタスクロールにSecrets Manager読み取り権限を付与し、環境変数から削除
  - シークレットの自動ローテーション（JWT鍵: 90日、DBパスワード: 60日）を設定
- **該当箇所**: セクション6.5 デプロイメント方針

### 1-3. ログ出力での個人情報の平文記録
- **問題**: セクション6.3で「個人情報（氏名、メール、給与額）はログに出力する」と明記されており、ログ管理システム（Datadog）への機密情報漏洩
- **影響**: ログを閲覧できる運用担当者やDatadog管理者が個人情報・給与情報を不正に閲覧可能。ログ保持期間（通常90日以上）中に外部漏洩した場合、個人情報保護法違反で最大1億円の罰金リスク
- **推奨対策**:
  - ログ出力時に個人情報をマスキング（氏名→`山田***`、メール→`ya***@example.com`、給与額→`***000円`）
  - Logbackの`MaskingConverter`を実装し、正規表現で個人情報フィールドを検出してマスク
  - 監査ログ（認証、権限エラー、給与計算実行）は別ストリームに分離し、アクセス制御を強化（ADMIN権限のみ閲覧可能）
  - ログ保持期間を30日に短縮し、個人情報を含むログは7日で自動削除
- **該当箇所**: セクション6.3 ロギング方針

### 1-4. JWTトークンの有効期限設定が長すぎる
- **問題**: セクション3.3で「JWT発行（有効期限24時間）」、セクション6.1で「リフレッシュトークンは発行せず、期限切れ時は再ログインを要求」と記載されており、トークン窃取時の被害期間が長い
- **影響**: XSS攻撃やネットワーク傍受でトークンが窃取された場合、24時間の間に攻撃者が全従業員の個人情報・給与情報にアクセス可能。セッション無効化の手段がないため、被害を即座に停止できない
- **推奨対策**:
  - アクセストークンの有効期限を15分に短縮
  - リフレッシュトークン（有効期限7日、ローテーション方式）を導入し、RedisにトークンIDを保存して無効化可能に
  - `/api/auth/refresh`エンドポイントで新しいアクセストークンを発行し、古いリフレッシュトークンを無効化
  - Spring Securityの`TokenStore`インターフェースを実装し、Redis経由でトークン管理
- **該当箇所**: セクション3.3 データフロー、セクション6.1 認証・認可方式

### 1-5. 勤怠打刻APIの冪等性が未設計
- **問題**: セクション5.4の`POST /api/attendance/clock-in`エンドポイントに冪等性保証の記載がなく、ネットワークエラーでのリトライ時に重複打刻が発生
- **影響**: フロントエンドのリトライやユーザーの二重クリックで同一日時の打刻レコードが複数作成され、勤怠データの整合性が失われる。給与計算時に重複カウントで過剰支給が発生するリスク
- **推奨対策**:
  - リクエストに`idempotency_key`（UUID）を追加し、Redisに24時間保存
  - 同一キーでのリクエストを検出した場合、初回レスポンスをキャッシュから返却（HTTP 200、既存の勤怠記録ID）
  - データベースにユニーク制約 `UNIQUE(employee_id, record_date, clock_in)` を追加して重複挿入を防止
- **該当箇所**: セクション5.4 勤怠管理エンドポイント

### 1-6. Denial of Service（DoS）対策の欠如
- **問題**: API全体にレート制限やリクエストサイズ制限の設計がなく、攻撃者が大量リクエストでシステムを停止可能
- **影響**: `/api/employees`に1秒間に1000リクエストを送信してデータベース接続プールを枯渇させる、`/api/payroll/calculate`に大量の従業員IDを含むリクエストを送信してバッチ処理を遅延させる、などのDoS攻撃で全テナントのサービスが停止
- **推奨対策**:
  - Spring Cloud GatewayのRedisRateLimiterを導入し、テナント単位で1秒あたり100リクエストに制限
  - `/api/payroll/calculate`の`employee_ids`配列を最大100件に制限（`@Size(max=100)`バリデーション）
  - `/api/auth/login`に5回/15分の失敗制限を設定し、失敗時は30分のアカウントロック（Redisで管理）
  - リクエストボディサイズを10MBに制限（`spring.servlet.multipart.max-file-size=10MB`）
- **該当箇所**: セクション5.1-5.4 全APIエンドポイント

### 1-7. SQLインジェクション対策の設計が不明確
- **問題**: セクション5.2の`GET /api/employees?department_id=<value>`でクエリパラメータが動的SQLに使用される可能性があるが、パラメータ化クエリの使用が明記されていない
- **影響**: `department_id`に`' OR '1'='1`を注入すると全テナントの従業員情報が漏洩する可能性。Spring Data JPAのデフォルト動作に依存するとORM外でのネイティブクエリ実装時に脆弱性が混入
- **推奨対策**:
  - Spring Data JPAの`@Query`でパラメータバインディング（`:param`または`?1`）を必須化
  - ネイティブクエリを使用する場合は`PreparedStatement`のプレースホルダ（`?`）を使用し、文字列連結を禁止
  - SonarQubeのルール`java:S2077`（SQL Injection）を有効化し、CI/CDでスキャン
  - コードレビューチェックリストに「動的SQLの禁止」を追加
- **該当箇所**: セクション5.2 従業員管理エンドポイント

## 2. 改善提案（設計の品質向上に有効）

### 2-1. 従業員削除APIの論理削除方式への変更
- **提案**: セクション5.2の`DELETE /api/employees/{id}`が物理削除の場合、給与記録・勤怠記録の外部キー制約違反や監査証跡の消失が発生
- **理由**: 労働基準法では賃金台帳を3年間保存する義務があり、従業員データの物理削除は違法。また、退職者の過去の勤怠・評価データにアクセスできなくなり、労使紛争時の証拠が失われる
- **推奨対策**:
  - employeesテーブルに`deleted_at`（TIMESTAMP, NULL許可）列を追加し、削除時に現在時刻を設定
  - データベースクエリに`WHERE deleted_at IS NULL`条件を自動追加（Spring Data JPAの`@SQLDelete`と`@Where`アノテーション使用）
  - 物理削除は3年経過後にバッチ処理で実行（人事担当者への通知付き）

### 2-2. パスワードポリシーの強化
- **提案**: セクション7.2で「パスワードはbcryptでハッシュ化（work factor 10）」とあるが、パスワードの複雑性要件や最低文字数が設計されていない
- **理由**: work factor 10は現代の計算能力では不十分（GPU攻撃で1秒間に数百万回のハッシュ計算が可能）。弱いパスワード（`password123`など）が許可されるとブルートフォース攻撃で短時間に突破される
- **推奨対策**:
  - パスワード要件: 最低12文字、大文字・小文字・数字・記号を各1文字以上含む
  - bcryptのwork factorを12に引き上げ（計算時間が約4倍になり、攻撃コストが増加）
  - Spring Securityの`PasswordEncoder`にカスタムバリデータを追加し、OWASP推奨の禁止パスワードリスト（`password`, `123456`など上位10000件）をチェック
  - パスワード変更の強制（初回ログイン時、90日ごと）と過去5世代の再利用禁止

### 2-3. APIレスポンスでのユーザー列挙攻撃対策
- **提案**: セクション5.1の`POST /api/auth/login`で「メールアドレスが存在しない」vs「パスワードが間違っている」のエラーメッセージを区別すると、攻撃者が有効なメールアドレスを列挙可能
- **理由**: 攻撃者が有効なメールアドレスのリストを取得すると、フィッシング攻撃やパスワードスプレー攻撃の標的リストとして悪用される
- **推奨対策**:
  - 認証失敗時は常に同一メッセージ「メールアドレスまたはパスワードが正しくありません」を返却
  - レスポンスタイミングを一定化（bcryptハッシュ計算を常に実行）して、タイミング攻撃を防止
  - 連続失敗時のレスポンス遅延（1回目: 即座、2回目: 1秒、3回目: 2秒、4回目: 4秒…）でブルートフォース攻撃を緩和

### 2-4. Row-Level Security（RLS）の実装詳細の明確化
- **提案**: セクション3.3で「Row-Level SecurityでテナントID自動フィルタ」と記載されているが、PostgreSQL RLSポリシーの具体的な設計が不明
- **理由**: RLSポリシーの設定ミス（例: ポリシーが適用されないロールでの接続、UPDATEポリシーの未設定）で、テナント間のデータ漏洩が発生する可能性がある
- **推奨対策**:
  - PostgreSQL RLSポリシーの例:
    ```sql
    ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
    CREATE POLICY tenant_isolation ON employees
      USING (tenant_id = current_setting('app.current_tenant_id')::uuid);
    ```
  - Spring BootのHibernate Interceptorで接続確立時に`SET app.current_tenant_id = '<tenant_id>'`を実行
  - 統合テストでテナントIDが異なるユーザーでのクエリ実行時に空の結果セットが返ることを確認
  - データベース管理者用のSUPERUSERロールにのみRLSをバイパス許可（`BYPASSRLS`属性）

### 2-5. CSRFトークンの実装
- **提案**: React SPAとREST APIの構成ではCSRF対策の記載がないが、JWTをlocalStorageやCookieに保存する場合はCSRF攻撃のリスク
- **理由**: JWTをCookieに保存する場合、攻撃者が作成した悪意のあるサイトからAPIリクエストを送信すると、ブラウザが自動的にCookieを送信してしまう（CSRF攻撃）
- **推奨対策**:
  - SameSite=Strict属性をCookieに設定してクロスサイトリクエストを禁止（`Set-Cookie: token=...; SameSite=Strict; Secure; HttpOnly`）
  - または、JWTをlocalStorageに保存し、Authorizationヘッダーで送信（CSRF耐性はあるがXSS脆弱性で窃取可能になるため、CSP: Content Security Policyでスクリプト実行を制限）
  - Spring SecurityのCSRF保護を有効化し、`X-CSRF-TOKEN`ヘッダーを要求（SPA向けに`CsrfTokenRepository`をカスタマイズ）

### 2-6. S3バケットのアクセス制御とバージョニング
- **提案**: セクション2.2で「Amazon S3（給与明細PDF、契約書類）」とあるが、バケットポリシーやバージョニング設定が明記されていない
- **理由**: S3バケットが公開設定だと給与明細PDFが全世界に公開される。バージョニング未設定では従業員の誤削除や攻撃者によるデータ削除で復旧不可能
- **推奨対策**:
  - S3バケットにパブリックアクセスブロック（Block all public access）を有効化
  - バケットポリシーでECS Fargateタスクロール（IAM Role ARN）からのみアクセス許可
  - オブジェクトの署名付きURL（有効期限15分）を生成して従業員に提供（`s3.generatePresignedUrl()`）
  - バージョニングを有効化し、削除操作を論理削除（Delete Marker）として記録
  - ライフサイクルポリシーで90日経過後にGlacierへアーカイブ、3年後に完全削除

### 2-7. APIエンドポイントのHTTPメソッド誤用対策
- **提案**: セクション5.4の勤怠APIが`POST /api/attendance/clock-in`だが、べき等でない操作に対してGETメソッドが誤用されるリスク
- **理由**: フロントエンド開発者がGETメソッドで勤怠打刻を実装すると、ブラウザのプリフェッチやリンククリックで意図しない打刻が発生。また、ログに記録されたGETリクエストURLに個人情報が含まれるとアクセスログから漏洩
- **推奨対策**:
  - Spring Securityで状態変更操作（POST, PUT, DELETE）にCSRF保護を適用し、GETリクエストを拒否
  - `@GetMapping`アノテーションに`@PreAuthorize("denyAll")`を誤って設定しないようコードレビュー
  - OpenAPI仕様（swagger.yaml）でHTTPメソッドを明記し、フロントエンドとのAPI契約を文書化

### 2-8. 給与計算バッチの監視とリトライ機構
- **提案**: セクション2.1で「Spring Batch（月次給与計算、年末調整処理）」とあるが、バッチ失敗時のリトライやアラート設定が設計されていない
- **理由**: 給与計算バッチが途中で失敗すると、一部従業員の給与が未計算のまま残り、給与支払い期日に間に合わなくなる。労働基準法では賃金支払いの遅延に罰則（30万円以下の罰金）
- **推奨対策**:
  - Spring Batchの`@Retryable`アノテーションで一時的エラー（データベース接続タイムアウト等）を3回リトライ
  - バッチ失敗時にDatadog APMで`batch.payroll.failed`メトリクスを送信し、Slack通知を自動送信
  - 給与計算ステータスを`payroll_records.status`列で管理し、失敗した従業員のみ再計算可能に（`WHERE status = 'DRAFT'`）
  - バッチ実行ログをCloudWatch Logsに保存し、24時間以内の再実行が可能な設計

## 3. 確認事項（ユーザーへの確認が必要）

### 3-1. 多要素認証（MFA）の導入要否
- **確認理由**: 人事システムは全従業員の個人情報・給与情報を扱うため、パスワード漏洩時の被害が甚大。MFA（SMS、TOTP、生体認証）導入でセキュリティが大幅に向上するが、ユーザー体験に影響
- **選択肢とトレードオフ**:
  - **A: 全ユーザーにMFA必須**
    - メリット: パスワード漏洩時も不正アクセスを防止、個人情報保護法の「安全管理措置」として有効
    - デメリット: 一般従業員の勤怠打刻が煩雑化（毎日MFA入力）、初期設定のサポートコストが増加
  - **B: 管理者・人事担当者のみMFA必須**
    - メリット: 給与計算実行、従業員情報編集などの機密操作を保護しつつ、一般従業員の利便性を維持
    - デメリット: 一般従業員アカウントの乗っ取りで自分の給与情報は閲覧可能
  - **C: MFA導入せず（現行設計）**
    - メリット: 実装コスト削減、ユーザー体験がシンプル
    - デメリット: フィッシング攻撃やパスワード漏洩で全データ侵害のリスク
- **推奨**: B（管理者・人事担当者のみMFA必須）を推奨。Spring Securityの`@PreAuthorize("hasRole('HR_MANAGER') or hasRole('ADMIN')")`でMFAチェックを追加

### 3-2. 給与明細PDFの電子署名の必要性
- **確認理由**: 給与明細をPDFで配布する際、電子署名（Adobe Sign, DocuSign等）を付与すると改ざん防止と法的証拠力が向上するが、コスト増
- **選択肢とトレードオフ**:
  - **A: 電子署名を導入**
    - メリット: 給与明細の真正性を保証、労使紛争時の証拠として有効、e-文書法対応
    - デメリット: 電子署名プロバイダーの月額費用（$10/ユーザー程度）、PDF生成処理の複雑化
  - **B: タイムスタンプのみ付与**
    - メリット: 低コスト（RFC 3161準拠のタイムスタンプサーバーは無料）、作成日時の証明が可能
    - デメリット: 改ざん検出はできるが署名者の証明はできない
  - **C: 電子署名なし（現行設計）**
    - メリット: 実装が単純、コストゼロ
    - デメリット: 給与明細の改ざんを検出不可能、法的証拠力が弱い
- **推奨**: B（タイムスタンプのみ）を推奨。Apache PDFBoxに`TSAClient`を統合してRFC 3161タイムスタンプを埋め込み

### 3-3. データベース暗号化方式の選択
- **確認理由**: マイナンバー・口座番号の暗号化（重大な問題1-1）で推奨したアプリケーション層暗号化以外に、データベース透過暗号化（TDE）の選択肢もある
- **選択肢とトレードオフ**:
  - **A: アプリケーション層暗号化（推奨）**
    - メリット: 列単位で暗号化対象を選択可能、データベース管理者からもデータを保護、鍵ローテーションが柔軟
    - デメリット: アプリケーションコードの実装が必要、暗号化列での検索が困難（インデックスが効かない）
  - **B: PostgreSQL TDE（Transparent Data Encryption）**
    - メリット: アプリケーション変更不要、ディスク全体を暗号化してバックアップファイルも保護
    - デメリット: データベース管理者がSUPERUSERでログインすると全データを平文で閲覧可能、マイナンバーのみの暗号化ができない
  - **C: AWS RDS暗号化（EBS暗号化）**
    - メリット: AWS管理の鍵で自動暗号化、追加コストなし
    - デメリット: ディスクレベルの暗号化のため、データベース接続した状態では平文アクセス可能、マイナンバー保護法の要件（列レベル暗号化）を満たさない
- **推奨**: A（アプリケーション層暗号化）を推奨。マイナンバー保護法ガイドラインでは「特定個人情報を取り扱う情報システムにおいて適切なアクセス制御を行う」ことが求められ、列レベル暗号化が最適

## 4. 評価（良い点）

### 4-1. マルチテナント構成の採用
- セクション3.1で「テナントIDによるデータ分離」が設計されており、SaaS型人事システムとして適切な構成
- PostgreSQL Row-Level Security（RLS）でテナント間のデータ漏洩を防止する設計は、アプリケーション層のバグによる情報漏洩リスクを低減

### 4-2. パスワードのbcryptハッシュ化
- セクション7.2で「パスワードはbcryptでハッシュ化（work factor 10）」が設計されており、レインボーテーブル攻撃やプレーンテキストでのパスワード漏洩を防止
- work factorを12に引き上げることを推奨したが、基本的なハッシュ化の採用は評価できる

### 4-3. HTTPS通信の全面採用
- セクション7.2で「通信は全てHTTPSで暗号化」が明記されており、中間者攻撃（MITM）やパケット盗聴からデータを保護
- ALB（Application Load Balancer）でのTLS終端とバックエンドへの暗号化通信が想定される構成

### 4-4. 監査ログの記録範囲
- セクション6.3で「認証イベント、権限エラー、給与計算実行、従業員情報更新をすべて記録」と設計されており、不正アクセスの事後調査が可能
- ログに個人情報を含める設計は問題だが、監査証跡の重要性を認識している点は評価できる

### 4-5. レイヤー構成の明確化
- セクション3.1で「Controller → Service → Repository → Entity」のレイヤー構成が定義されており、関心の分離が適切
- Spring Securityの`@PreAuthorize`をService層で実装することで、ビジネスロジックと認可制御の結合度が低く、テストが容易

### 4-6. バックアップ戦略の存在
- セクション7.3で「データベースバックアップ: 日次フルバックアップ」が設計されており、データ消失時の復旧が可能
- RPO（復旧時点目標）: 24時間は人事システムとして許容範囲（リアルタイム性が求められる金融システムと異なる）

---

**総評**: 本設計書は基本的なセキュリティ要素（HTTPS、パスワードハッシュ化、認証・認可）を含むが、**データ保護**と**入力検証設計**に重大な欠陥がある。特にマイナンバーの平文保存（重大な問題1-1）は個人番号保護法違反であり、本番環境での運用は法的に不可能。暗号化方式の選択（確認事項3-3）とログマスキング（重大な問題1-3）の即時実装を強く推奨する。
