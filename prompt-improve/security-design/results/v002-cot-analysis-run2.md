# セキュリティ設計レビュー結果

## ステップ1: 全体構造の把握

### システム概要
- **目的**: デジタルウォレット決済システム（モバイルアプリベース）
- **主要機能**: ユーザー登録・KYC、決済手段登録、QRコード決済、P2P送金、取引履歴、加盟店管理
- **技術スタック**: Java 17 + Spring Boot 3.2、React Native、PostgreSQL、Redis、MongoDB
- **インフラ**: AWS（ECS Fargate、RDS、ElastiCache、API Gateway）
- **外部連携**: Stripe API（カード決済）、Plaid API（銀行口座連携）

### アーキテクチャ構成
- 3層アーキテクチャ（Presentation → Business Logic → Data Access） + External Integration Layer
- 主要コンポーネント: AuthService, PaymentService, TransferService, MerchantService, TransactionHistoryService, FraudDetectionService

### データフローの理解
1. ユーザー → API Gateway → AuthService（JWT検証）
2. PaymentService → Stripe/Plaid APIで決済実行
3. トランザクション記録 → DB保存
4. 非同期で監査ログ書き込み（MongoDB）

### 初期観察（全体構造レベル）
- 金融取引を扱う高リスクシステム
- 外部API（Stripe/Plaid）への依存度が高い
- JWT認証を採用（Access Token 15分、Refresh Token 7日）
- JWTをlocalStorageに保存（セクション5に明記）→ **XSSリスクの懸念**
- PCI DSS準拠を明記（カード情報は自システムに保存しない）
- 監査ログをMongoDBに非同期書き込み

---

## ステップ2: セクション別詳細分析

### 2.1 脅威モデリング（STRIDE）分析

#### Spoofing（なりすまし）
- **設計状況**: JWT認証（15分/7日）、bcryptパスワードハッシュ（係数12）
- **問題点**:
  - ✅ パスワードハッシュ化は適切
  - ❌ **JWTをlocalStorageに保存**（セクション5）→ XSS攻撃でトークン窃取可能
  - ❌ 多要素認証（MFA）の設計が不在
  - ❌ デバイスフィンガープリント、異常ログイン検知の記載なし

#### Tampering（改ざん）
- **設計状況**: トランザクションDB保存、監査ログ（MongoDB）
- **問題点**:
  - ✅ トランザクションID（UUID）採用
  - ❌ **監査ログの完全性保護**が未設計（改ざん検知機構なし）
  - ❌ API Gateway → Backend間の通信保護（mTLS等）の記載なし
  - ❌ データベースの改ざん検知（チェックサム、署名）の記載なし

#### Repudiation（否認）
- **設計状況**: 監査ログをMongoDBに非同期書き込み
- **問題点**:
  - ✅ 監査ログの存在は確認
  - ❌ **監査ログの具体的内容**が不明（誰が・何を・いつ・どこから・結果）
  - ❌ ログの保持期間、アクセス制御、完全性保護の設計なし
  - ❌ 金融取引における法的要件（ログ保持期間等）への言及なし

#### Information Disclosure（情報漏洩）
- **設計状況**: HTTPS（TLS 1.3）、PCI DSS準拠、Stripeトークン化
- **問題点**:
  - ✅ カード情報のトークン化は適切
  - ❌ **機密データの暗号化戦略**が不明確
    - KYC書類メタデータ（MongoDB）の暗号化なし
    - 銀行口座情報（Plaid token）のDB暗号化なし
    - `payment_methods.provider_token` カラムの暗号化なし
  - ❌ **エラーメッセージの情報漏洩リスク**（セクション5のエラーレスポンス例が一般的すぎる）
  - ❌ API応答の機密データフィルタリング設計なし

#### Denial of Service（DoS）
- **設計状況**: レート制限の記載あり（セクション7）、Auto Scaling（CPU 70%）
- **問題点**:
  - ⚠️ **レート制限の具体的設計が不在**（「適切なレート制限」のみ記載）
  - ❌ エンドポイント別のレート制限値が未定義
  - ❌ ブルートフォース対策（ログイン試行制限）の記載なし
  - ❌ 決済・送金APIの不正利用防止（短時間の大量取引）の設計なし
  - ❌ 外部API（Stripe/Plaid）の障害時のサーキットブレーカー設計が不明確

#### Elevation of Privilege（権限昇格）
- **設計状況**: 加盟店APIは加盟店オーナーのみアクセス可能（ユーザー属性で判定）
- **問題点**:
  - ❌ **認可モデルの詳細が不在**（RBAC/ABAC? 権限テーブルは?）
  - ❌ **権限チェックの実装箇所**が不明確（Controller? Service層?）
  - ❌ 加盟店オーナーが他オーナーのデータにアクセスできないか？（横断アクセス制御）
  - ❌ 管理者権限の設計が不在（不正取引の検出・凍結を行う管理者の権限管理は?）
  - ❌ P2P送金の認可（送金元ユーザーの本人確認）の記載なし

### 2.2 認証・認可設計

#### 認証フロー
- **設計状況**: JWT（Access 15分、Refresh 7日）、localStorageに保存
- **問題点**:
  - ❌ **JWTをlocalStorageに保存** → XSS攻撃でトークン窃取可能（重大）
  - ❌ Refresh Token のローテーション機構の記載なし
  - ❌ Refresh Token の失効機構（ログアウト時）の設計なし
  - ❌ JWT署名アルゴリズムの指定なし（HS256? RS256?）
  - ❌ セッション管理（同時ログインデバイス数制限）の記載なし

#### 認可モデル
- **設計状況**: 「加盟店APIは加盟店オーナーのみアクセス可能（ユーザー属性で判定）」
- **問題点**:
  - ❌ **認可モデルが未定義**（RBAC? ABAC?）
  - ❌ ユーザー属性の管理方法が不明（`users` テーブルに `role` カラム?）
  - ❌ 権限チェックの実装層が不明（Spring Security のアノテーション?）
  - ❌ リソースレベルの認可（例: ユーザーAが自分の取引履歴のみ閲覧可能）の設計なし

#### APIアクセス制御
- **問題点**:
  - ❌ エンドポイント別の認証・認可要件が未定義
  - ❌ 管理者専用エンドポイント（不正取引凍結等）の設計なし
  - ❌ CORS設定の記載なし

### 2.3 データ保護

#### 機密データの保存・転送時の保護
- **設計状況**: HTTPS（TLS 1.3）、bcryptパスワードハッシュ、Stripeトークン化
- **問題点**:
  - ❌ **データベースの暗号化設計が不在**
    - `users.password_hash`: ハッシュ化済み（OK）
    - `payment_methods.provider_token`: **平文保存のリスク**（Stripe/Plaid トークンは機密情報）
    - KYC書類メタデータ（MongoDB）: 暗号化の記載なし
  - ❌ **転送時の暗号化**（内部通API Gateway → Backend間）の記載なし
  - ❌ バックアップデータの暗号化の記載なし

#### プライバシー要件
- **問題点**:
  - ❌ **GDPR/個人情報保護法への対応**が不明
  - ❌ ユーザーデータの削除権（Right to be Forgotten）の設計なし
  - ❌ データ保持期間の定義なし（セクション7に定期バックアップ7日保持のみ）
  - ❌ PII（個人識別情報）の最小化原則の記載なし

#### データ保持・削除方針
- **問題点**:
  - ❌ トランザクションデータの保持期間が未定義
  - ❌ 監査ログの保持期間が未定義
  - ❌ 論理削除 vs 物理削除の方針なし

### 2.4 入力検証設計

#### 外部入力の検証方針
- **問題点**:
  - ❌ **入力検証の全体方針が不在**
  - ❌ バリデーションの実装層が不明（Controller? Service層?）
  - ❌ Bean Validation（JSR-380）の使用についての言及なし

#### インジェクション防止策
- **問題点**:
  - ✅ JPA使用（SQL Injection対策は暗黙的にOK）
  - ❌ **NoSQL Injection対策**（MongoDB）の記載なし
  - ❌ ログインジェクション対策（ログ出力時のサニタイゼーション）の記載なし
  - ❌ 外部API（Stripe/Plaid）へのパラメータ検証の記載なし

#### ファイルアップロード制限
- **問題点**:
  - ⚠️ KYC書類のアップロード機能が暗示されているが、設計詳細なし
  - ❌ ファイルサイズ制限、拡張子チェック、ウイルススキャンの記載なし

#### 出力エスケーピング
- **問題点**:
  - ❌ APIレスポンスのエスケーピング方針なし
  - ❌ エラーメッセージへのユーザー入力混入リスクの検討なし

### 2.5 インフラ・依存関係のセキュリティ

#### サードパーティライブラリの安全性
- **設計状況**: Spring Security、Stripe API、Plaid API、ZXing、Lombok、MapStruct
- **問題点**:
  - ❌ **依存関係の脆弱性スキャン**の記載なし（Dependabot/Snyk等）
  - ❌ ライブラリのバージョン管理・更新方針なし
  - ❌ サプライチェーン攻撃対策の記載なし

#### シークレット管理
- **問題点**:
  - ❌ **シークレット管理の設計が完全に不在**
    - Stripe API Key、Plaid API Key の保存方法が未定義
    - JWT署名鍵の管理方法が未定義
    - データベース接続情報の管理方法が未定義
  - ❌ AWS Secrets Manager / Parameter Store の使用についての言及なし
  - ❌ シークレットのローテーション方針なし

#### デプロイメントセキュリティ
- **設計状況**: Blue/Green Deployment、GitHub Actions → ECR → ECS
- **問題点**:
  - ❌ **コンテナイメージのセキュリティスキャン**の記載なし
  - ❌ ECSタスクのIAMロール設計が不在
  - ❌ ネットワーク分離（VPC、サブネット、セキュリティグループ）の記載なし
  - ❌ Secrets のコンテナへの注入方法が未定義

---

## ステップ3: 横断的問題の検出

### 3.1 認証とデータ保護の横断的問題
**問題**: JWTをlocalStorageに保存することで、XSS攻撃発生時にトークンが窃取され、かつRefresh Tokenが7日間有効であるため、攻撃者は長期間にわたってユーザーアカウントを乗っ取り可能。さらに、決済・送金APIにアクセスできるため、金銭的被害が発生する。

**影響範囲**: 全エンドポイント（特に決済・送金API）

### 3.2 監査ログと完全性保護の横断的問題
**問題**: 監査ログがMongoDBに非同期書き込みされるが、ログの完全性保護（改ざん検知）の設計がないため、攻撃者がDBにアクセスした場合、自身の不正行為の痕跡を消去・改ざん可能。金融システムにおける監査証跡の信頼性が損なわれる。

**影響範囲**: 全トランザクション、不正検出システム、法的証拠能力

### 3.3 認可モデルの不在による横断的リスク
**問題**: 認可モデルの詳細設計が不在であり、「ユーザー属性で判定」という曖昧な記述のみ。これにより以下のリスクがある:
- 加盟店オーナーが他オーナーのQRコードや取引データにアクセス可能
- ユーザーが他ユーザーの取引履歴を閲覧可能
- 管理者権限の設計が不在のため、不正取引凍結機能の認可が未定義

**影響範囲**: 全API（特に加盟店API、取引履歴API、管理者API）

### 3.4 機密データ暗号化の横断的不足
**問題**: 以下の機密データの暗号化戦略が不在:
- `payment_methods.provider_token`（Stripe/Plaid トークン）
- KYC書類メタデータ（MongoDB）
- 監査ログ（MongoDB）
- バックアップデータ

データベース侵害時に機密情報が平文で漏洩する。

**影響範囲**: データベース層全体、バックアップシステム

### 3.5 外部API依存による障害波及リスク
**問題**: Stripe/Plaid APIへの依存度が高いが、外部API障害時の詳細な対応設計が不足:
- リトライ3回（指数バックオフ）の記載はあるが、サーキットブレーカーの設計なし
- タイムアウト値の定義なし
- 外部API障害時のユーザー体験（エラーメッセージ、代替手段）の設計なし

**影響範囲**: 決済・送金処理、決済手段登録

### 3.6 レート制限とDoS対策の横断的不足
**問題**: 「適切なレート制限を設定する」との記載はあるが、エンドポイント別の具体的な制限値が未定義。特に以下のエンドポイントでDoS/ブルートフォース攻撃のリスク:
- `/api/v1/auth/login`: ブルートフォース攻撃
- `/api/v1/payments`: 決済スパム
- `/api/v1/transfers`: 送金スパム

**影響範囲**: 全API、特に認証・決済・送金エンドポイント

---

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | JWTのlocalStorage保存（XSSリスク）、監査ログの完全性保護不在、認可モデル未定義 |
| 認証・認可設計 | 2 | JWTのlocalStorage保存、Refresh Token失効機構なし、認可モデル詳細不在 |
| データ保護 | 2 | 機密データ（provider_token, KYC書類）の暗号化戦略不在、データ保持・削除方針なし |
| 入力検証設計 | 3 | 入力検証の全体方針が不在、NoSQL Injection対策なし、ファイルアップロード制限なし |
| インフラ・依存関係 | 2 | シークレット管理設計が完全に不在、ネットワーク分離設計なし、依存関係スキャンなし |
| **総合** | **2.2** | 金融システムとして重大なセキュリティ設計不足が複数存在。本番環境リリース前に必須の対策が多数 |

---

## 詳細評価

### 重大な問題（設計の修正が必須）

#### 1. JWTトークンの保存方式がXSS攻撃に脆弱
- **問題**: セクション5に「トークンはlocalStorageに保存（フロントエンド）」と明記されている。localStorageはJavaScriptから自由にアクセス可能であり、XSS脆弱性が1つでも存在すれば、攻撃者はトークンを窃取できる。さらにRefresh Tokenが7日間有効であるため、窃取後の被害期間が長期化する。
- **影響**: XSS攻撃によるユーザーアカウント乗っ取り。決済・送金APIへのアクセス権を獲得され、金銭的被害が発生。
- **推奨対策**:
  1. **JWTをHttpOnly + Secure + SameSite=Strict属性のCookieに変更**（XSS攻撃でもJavaScriptからアクセス不可）
  2. Refresh Tokenのローテーション機構を実装（使用済みトークンは無効化）
  3. Refresh Tokenの失効API（`POST /api/v1/auth/logout`）を実装し、RedisでRevokedトークンリストを管理
  4. 多要素認証（MFA）を高額取引（例: 10万円以上の決済・送金）に必須化
- **該当箇所**: セクション5「認証・認可方式」

#### 2. 認可モデルの詳細設計が不在（権限昇格リスク）
- **問題**: 「加盟店APIは加盟店オーナーのみアクセス可能（ユーザー属性で判定）」との記載のみで、認可モデルの詳細が不明。以下のリスクがある:
  - 加盟店オーナーAが加盟店オーナーBのQRコードや取引データにアクセス可能か？
  - 一般ユーザーが他ユーザーの取引履歴を閲覧可能か？
  - 管理者権限（不正取引凍結）の認可設計が不在
- **影響**: 横断アクセス制御の欠如により、他ユーザーの機密データへの不正アクセスが可能。
- **推奨対策**:
  1. **RBAC（Role-Based Access Control）モデルを明確化**:
     - `users` テーブルに `role` カラム追加（`user`, `merchant_owner`, `admin`）
     - Spring Security の `@PreAuthorize("hasRole('MERCHANT_OWNER')")` で認可
  2. **リソースレベルの認可を実装**:
     - 例: `GET /api/v1/merchants/{id}/qrcode` では、リクエストユーザーが `merchants.owner_user_id` と一致するかチェック
     - Service層で `if (!merchant.getOwnerUserId().equals(currentUserId)) throw new ForbiddenException();`
  3. 管理者専用エンドポイント（`POST /api/v1/admin/transactions/{id}/freeze`）を設計し、`ADMIN` ロールのみアクセス可能に
- **該当箇所**: セクション5「認証・認可方式」、セクション4「データモデル」

#### 3. 機密データの暗号化戦略が不在
- **問題**: 以下の機密データの暗号化設計が不在:
  - `payment_methods.provider_token`（Stripe/Plaid トークン）: 平文保存の可能性が高い
  - KYC書類メタデータ（MongoDB）: 暗号化の記載なし
  - 監査ログ（MongoDB）: 暗号化の記載なし
  - バックアップデータ: 暗号化の記載なし
- **影響**: データベース侵害時に機密情報が平文で漏洩。Stripe/Plaidトークンが窃取されれば、攻撃者はユーザーの決済手段を不正利用可能。
- **推奨対策**:
  1. **データベースカラムレベルの暗号化**:
     - `payment_methods.provider_token` を AES-256-GCM で暗号化（Spring Boot の `@Convert` + Jasypt）
     - 暗号鍵は AWS KMS で管理（自動ローテーション有効化）
  2. **MongoDB の Encrypted Storage Engine を有効化**（KYC書類メタデータ、監査ログ）
  3. **RDS の暗号化を有効化**（PostgreSQL の Transparent Data Encryption）
  4. **バックアップデータの暗号化**（AWS Backup の暗号化オプション有効化）
- **該当箇所**: セクション4「データモデル」、セクション7「非機能要件」

#### 4. 監査ログの完全性保護が不在
- **問題**: 監査ログをMongoDBに非同期書き込みするが、ログの完全性保護（改ざん検知）の設計がない。攻撃者がDBにアクセスした場合、自身の不正行為の痕跡を消去・改ざん可能。
- **影響**: 金融システムにおける監査証跡の信頼性が損なわれる。法的証拠能力を失う。
- **推奨対策**:
  1. **監査ログにデジタル署名を付与**:
     - 各ログエントリに HMAC-SHA256 署名を追加（秘密鍵はAWS KMSで管理）
     - ログ検証時に署名を検証し、改ざんを検知
  2. **Write-Once-Read-Many（WORM）ストレージを使用**:
     - AWS S3の Object Lock 機能で監査ログを不変化（削除・上書き不可）
  3. **監査ログのバックアップをクロスリージョンに保存**（改ざん対策の多層防御）
- **該当箇所**: セクション3「データフロー」、セクション2「データベース」

#### 5. シークレット管理の設計が完全に不在
- **問題**: 以下のシークレットの管理方法が未定義:
  - Stripe API Key、Plaid API Key
  - JWT署名鍵
  - データベース接続情報（PostgreSQL、Redis、MongoDB）
- **影響**: シークレットがコードやコンテナイメージに平文で埋め込まれるリスク。GitHubリポジトリへの誤コミット、コンテナイメージの漏洩により、攻撃者がシステム全体を侵害可能。
- **推奨対策**:
  1. **AWS Secrets Manager を使用**:
     - Stripe/Plaid API Key、JWT署名鍵、DB接続情報を Secrets Manager に保存
     - ECSタスクのIAMロールで Secrets Manager へのアクセス権を付与
     - Spring Boot の `@Value("${aws.secretsmanager.stripe-api-key}")` で取得
  2. **シークレットの自動ローテーション**:
     - JWT署名鍵を30日ごとにローテーション（古い鍵も7日間は検証可能に）
     - DB接続情報を90日ごとにローテーション
  3. **環境変数への注入**:
     - ECS Task Definition で `secrets` フィールドを使用（環境変数として注入）
- **該当箇所**: セクション2「技術スタック」、セクション6「デプロイメント方針」

#### 6. レート制限の具体的設計が不在（DoS/ブルートフォース攻撃リスク）
- **問題**: セクション7に「APIには適切なレート制限を設定する」との記載はあるが、エンドポイント別の具体的な制限値が未定義。特に以下のエンドポイントで攻撃リスクが高い:
  - `/api/v1/auth/login`: ブルートフォース攻撃
  - `/api/v1/payments`, `/api/v1/transfers`: 決済・送金スパム
- **影響**: ブルートフォース攻撃によるアカウント侵害、決済・送金スパムによるシステム負荷増大・金銭的損失。
- **推奨対策**:
  1. **エンドポイント別のレート制限を設計**:
     - `/api/v1/auth/login`: 5回/15分（IPベース）、失敗5回でアカウント30分ロック
     - `/api/v1/payments`: 10回/分（ユーザーベース）
     - `/api/v1/transfers`: 5回/分（ユーザーベース）
     - その他のAPI: 100回/分（ユーザーベース）
  2. **Spring Boot で Bucket4j（Token Bucket アルゴリズム）を実装**:
     - Redisでレート制限カウンタを管理（分散環境対応）
  3. **異常検知**:
     - 短時間に大量の失敗決済が発生した場合、FraudDetectionServiceで自動凍結
- **該当箇所**: セクション7「セキュリティ要件」

---

### 改善提案（設計の品質向上に有効）

#### 1. 外部API障害時のサーキットブレーカー設計
- **提案**: Stripe/Plaid APIへの依存度が高いが、外部API障害時の詳細な対応設計が不足。リトライ3回の記載はあるが、サーキットブレーカーの設計がない。
- **理由**: 外部API障害時に無限リトライが発生し、システム全体のスレッドプールが枯渇する可能性。
- **推奨対策**:
  1. **Resilience4j のサーキットブレーカーを実装**:
     - 失敗率50%以上、または連続10回失敗でサーキット開放（60秒間リクエスト遮断）
     - Half-Open状態で5回成功すれば再開
  2. **タイムアウト値を明確化**: Stripe/Plaid APIへのHTTPリクエストタイムアウトを10秒に設定
  3. **フォールバック処理**: 外部API障害時は「決済手段が一時的に利用不可」とエラーメッセージを返し、ユーザーに代替手段を提示

#### 2. 入力検証の全体方針を明確化
- **提案**: 入力検証の全体方針が不在。Bean Validation（JSR-380）の使用についての言及もない。
- **理由**: 入力検証が不十分な場合、インジェクション攻撃やビジネスロジックの迂回が発生する可能性。
- **推奨対策**:
  1. **Bean Validation をControllerで実施**:
     - `@Valid` アノテーションで自動検証
     - 例: `@NotNull`, `@Size(min=8, max=128)`, `@Email`, `@Pattern(regexp="...")`
  2. **カスタムバリデーションを実装**:
     - 例: 決済金額が0円以下の場合はエラー
     - 例: P2P送金の送金元と送金先が同一の場合はエラー
  3. **NoSQL Injection対策**（MongoDB）:
     - MongoDBへのクエリは必ずパラメータ化（`Query.query(Criteria.where("userId").is(userId))`）
     - ユーザー入力を直接クエリ文字列に結合しない

#### 3. KYC書類アップロードのセキュリティ設計
- **提案**: KYC書類のアップロード機能が暗示されているが、設計詳細が不在。
- **理由**: ファイルアップロードは攻撃面が広く（マルウェアアップロード、パストラバーサル等）、設計が必要。
- **推奨対策**:
  1. **ファイルサイズ制限**: 5MB以下
  2. **拡張子チェック**: PDF、JPEG、PNG のみ許可（Content-Type ヘッダーと実際のファイルシグネチャの両方を検証）
  3. **ウイルススキャン**: ClamAV をECS Sidecarとして実行し、アップロード時にスキャン
  4. **S3への直接アップロード**: Presigned URLを発行し、クライアントから直接S3にアップロード（Backend経由でのアップロードを避ける）

#### 4. CORS設定の明確化
- **提案**: CORS設定の記載がない。
- **理由**: React Nativeアプリと管理画面（Next.js）からのAPIアクセス時にCORS設定が必要。
- **推奨対策**:
  1. Spring Security で CORS設定:
     - `allowedOrigins`: 本番ドメインのみ（`https://app.example.com`, `https://admin.example.com`）
     - `allowedMethods`: GET, POST, PUT, DELETE
     - `allowCredentials`: true（Cookieベース認証の場合）
     - `allowedHeaders`: Authorization, Content-Type
  2. Preflight リクエスト（OPTIONS）のキャッシュを有効化（3600秒）

#### 5. 依存関係の脆弱性スキャンを自動化
- **提案**: 依存関係の脆弱性スキャンの記載がない。
- **理由**: サードパーティライブラリの既知脆弱性を早期に検出し、対応する必要。
- **推奨対策**:
  1. **Dependabot を有効化**（GitHub）: 依存関係の脆弱性を自動検出し、PRを自動生成
  2. **OWASP Dependency-Check を CI/CDに統合**: ビルド時に脆弱性スキャンを実行し、Critical/High の脆弱性が検出された場合はビルド失敗
  3. **コンテナイメージのスキャン**: Trivy を GitHub Actions で実行（`docker scan` コマンド）

#### 6. ネットワーク分離設計の明確化
- **提案**: VPC、サブネット、セキュリティグループの設計が不在。
- **理由**: ネットワーク分離により、攻撃面を縮小し、横展開を防止する必要。
- **推奨対策**:
  1. **VPC設計**:
     - Public Subnet: ALB（API Gateway からの転送先）
     - Private Subnet: ECS Fargate、RDS、ElastiCache
     - Isolated Subnet: MongoDBマネージドサービス（または DocumentDB）
  2. **セキュリティグループ**:
     - ECS: ALBからの443ポートのみ許可
     - RDS: ECSからの5432ポートのみ許可
     - Redis: ECSからの6379ポートのみ許可
  3. **NATゲートウェイ**: ECSからの外部API（Stripe/Plaid）アクセス用

#### 7. JWT署名アルゴリズムの明確化
- **提案**: JWT署名アルゴリズムの指定がない。
- **理由**: 署名アルゴリズムの選択により、セキュリティ強度が変わる。
- **推奨対策**:
  1. **RS256（RSA署名）を使用**:
     - 秘密鍵でJWT署名、公開鍵で検証（鍵の漏洩リスクを分離）
     - 鍵長は2048ビット以上
  2. HS256（HMAC）は避ける（秘密鍵が署名・検証の両方に使われるため、鍵漏洩時のリスクが高い）

#### 8. エラーメッセージの情報漏洩対策
- **提案**: セクション5のエラーレスポンス例（`"message": "Insufficient funds"`）は一般的だが、エラーメッセージの情報漏洩リスクの検討がない。
- **理由**: エラーメッセージに機密情報（ユーザーID、内部パス等）が含まれると、攻撃者に有益な情報を提供してしまう。
- **推奨対策**:
  1. **エラーメッセージのサニタイゼーション**:
     - ユーザー入力をエラーメッセージに含めない
     - 内部例外のスタックトレースをクライアントに返さない（ログのみ）
  2. **エラーコードの体系化**:
     - `error` フィールドに機械可読なエラーコード（`PAYMENT_FAILED`, `INVALID_AMOUNT` 等）
     - `message` フィールドにユーザーフレンドリーなメッセージ

#### 9. データ保持期間の明確化（法的要件対応）
- **提案**: トランザクションデータや監査ログの保持期間が未定義。
- **理由**: 金融システムでは法的要件（例: 日本の資金決済法では10年間の取引記録保存義務）への対応が必要。
- **推奨対策**:
  1. **データ保持期間を定義**:
     - トランザクションデータ: 10年間（法的要件）
     - 監査ログ: 7年間
     - KYC書類: ユーザーアカウント削除後5年間
  2. **自動アーカイブ**: S3 Glacier に古いデータを自動移行（Lifecycle Policy）
  3. **論理削除を採用**: ユーザーが削除リクエストを出した場合、`deleted_at` カラムで論理削除（法的保持期間後に物理削除）

---

### 確認事項（ユーザーへの確認が必要）

#### 1. 多要素認証（MFA）の必須化範囲
- **確認理由**: セキュリティ強度を高めるためMFAの導入が望ましいが、ユーザー体験とのトレードオフがある。
- **選択肢**:
  - A. 全ログインでMFA必須（最もセキュア、UX低下）
  - B. 高額取引（10万円以上）のみMFA必須（推奨バランス）
  - C. 初回ログイン時のみMFA必須（UX重視）
  - D. MFA導入しない（非推奨）
- **推奨**: B（高額取引のみMFA必須）。デジタルウォレットの性質上、小額決済の利便性を損なわず、高リスク取引のみ保護する。

#### 2. KYC（本人確認）のレベル
- **確認理由**: KYCのレベルにより、取引限度額やセキュリティ強度が変わる。
- **選択肢**:
  - A. 簡易KYC（電話番号認証のみ）: 月間取引上限10万円
  - B. 標準KYC（身分証アップロード + 顔写真）: 月間取引上限100万円
  - C. 厳格KYC（eKYC: 身分証ICチップ読み取り）: 制限なし
- **推奨**: B（標準KYC）。多くのユーザーにとって受け入れ可能な範囲で、一定のセキュリティを確保。

#### 3. P2P送金の即時実行 vs 遅延実行
- **確認理由**: P2P送金を即時実行すると、不正送金の取り消しが困難。遅延実行すれば不正検出の猶予ができるが、UXが低下。
- **選択肢**:
  - A. 即時実行（リアルタイム送金、UX優先）
  - B. 遅延実行（5分後に実行、不正検出の猶予あり）
  - C. 金額に応じて分岐（1万円以下は即時、それ以上は遅延）
- **推奨**: C（金額に応じて分岐）。小額送金は即時実行でUXを確保し、高額送金は不正検出の猶予を設ける。

---

### 評価（良い点）

#### 1. カード情報のトークン化（PCI DSS準拠）
- クレジットカード情報を自システムに保存せず、Stripe APIでトークン化する設計は適切。PCI DSS のスコープを大幅に削減でき、カード情報漏洩リスクを回避している。

#### 2. パスワードハッシュ化の適切な実装
- bcrypt（ストレッチング係数12）を採用しており、レインボーテーブル攻撃や総当たり攻撃に強い。係数12は現時点で適切な値（計算コストとパフォーマンスのバランス）。

#### 3. HTTPS（TLS 1.3）の採用
- TLS 1.3 は最新の暗号化プロトコルであり、TLS 1.2 以前の脆弱性（POODLE, BEAST等）を回避。通信時のデータ保護が適切。

#### 4. Multi-AZ構成による可用性確保
- RDS の Multi-AZ構成により、AZ障害時の自動フェイルオーバーを実現。金融システムとして必要な可用性（99.9%）を確保する設計。

#### 5. Blue/Green Deployment によるダウンタイムゼロ
- Blue/Green Deployment により、本番環境へのデプロイ時のダウンタイムを回避。ロールバック可能な状態を維持することで、障害時の迅速な復旧が可能。

---

## 総評

本設計書は、デジタルウォレット決済システムのアーキテクチャ概要を示しているが、**金融システムとして必須のセキュリティ設計が多数不足**している。特に以下の6点は**本番環境リリース前に必須の対策**である:

1. **JWTをlocalStorageに保存する設計の変更**（HttpOnly Cookie に変更）
2. **認可モデルの詳細設計**（RBAC、リソースレベル認可）
3. **機密データの暗号化戦略**（provider_token、KYC書類、監査ログ）
4. **監査ログの完全性保護**（デジタル署名、WORM ストレージ）
5. **シークレット管理の設計**（AWS Secrets Manager）
6. **レート制限の具体的設計**（エンドポイント別制限値、ブルートフォース対策）

これらの問題は、**攻撃者によるアカウント乗っ取り、金銭的損失、機密情報漏洩、監査証跡の改ざん**といった重大なリスクを引き起こす可能性がある。設計段階で修正することで、実装後の手戻りを大幅に削減できる。

改善提案として挙げた9点は、設計の品質を大きく向上させるが、必須ではない。優先順位を考慮し、リソースと期間に応じて実装を検討すべきである。

全体として、本設計書は**スコア 2.2/5.0（重要な問題あり）**と評価する。上記の必須対策を実装した後、再評価を推奨する。
