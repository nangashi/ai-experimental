# セキュリティ設計レビュー結果

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | CSRF対策、セッション固定化対策、監査ログが未設計 |
| 認証・認可設計 | 3 | トークン保存方式とリフレッシュトークンのセキュリティが不明確 |
| データ保護 | 3 | 機密データのマスキング戦略と暗号化鍵管理が未設計 |
| 入力検証設計 | 3 | デバイスコマンドの検証詳細とファイル検証が不十分 |
| インフラ・依存関係 | 3 | シークレット管理とデータベース暗号化が未設計 |
| **総合** | **2.8** | |

---

## 重大な問題（計画の修正が必須）

### 1. 状態変更APIに対するCSRF対策が未設計

**問題の説明**: デバイス制御API（`POST /api/devices/:id/command`）、ユーザー招待API（`POST /api/devices/:id/invite`）、アクセス権削除API（`DELETE /api/devices/:id/access/:userId`）などの状態変更エンドポイントに対するCSRF対策が設計書に明記されていない

**影響**: 攻撃者が用意した悪意あるWebページをユーザーが閲覧するだけで、意図しないデバイス制御（ドアロック解除、カメラ有効化等）やアクセス権の削除が実行されるリスク。特にIoTデバイスの制御においては物理的な安全性にも影響する

**推奨対策**:
- Double Submit Cookieパターンまたはcsurfパッケージ（v1.3.0以降）を用いたCSRFトークン検証を実装
- 全てのPOST/PUT/DELETEエンドポイントにCSRF検証ミドルウェアを適用
- JWTトークンをCookieで送信する場合は、SameSite=Strict属性を設定（クロスサイトリクエストの自動ブロック）
- 高リスクな操作（デバイス制御、アクセス権変更）では、リクエストヘッダー（`X-CSRF-Token`）でのトークン検証を必須とする

**該当箇所**:
- セクション5.2 認証・認可方式
- セクション5.1 エンドポイント一覧（全状態変更API）

### 2. OTA更新パッケージの署名検証の実装詳細が不明確

**問題の説明**: セクション7.2で「デバイスファームウェア更新パッケージの署名検証」が要件として記載されているが、署名アルゴリズム、鍵管理方式、検証タイミングの具体的な設計が明記されていない

**影響**: 署名検証が不適切に実装された場合、攻撃者が偽のファームウェアをS3にアップロードし、デバイスに悪意あるコードを配信できる可能性。IoTデバイスのファームウェア改ざんは、家庭のプライバシー侵害（カメラの不正利用）や物理的セキュリティ（ドアロックの無効化）に直結

**推奨対策**:
- Ed25519署名アルゴリズムを採用（楕円曲線署名、鍵長256bit）
- 署名検証を2段階で実装:
  1. OTA Update Service: ファームウェア登録時にメーカーの秘密鍵で署名、公開鍵で検証
  2. デバイス側: ダウンロード後、デバイスに埋め込まれた公開鍵で再検証
- 署名鍵をAWS KMS（Key Management Service）で管理、鍵のローテーション（年1回）を実装
- `ota_updates`テーブルに`signature`カラム（VARCHAR(512)）を追加し、署名を記録

**該当箇所**:
- セクション4 データモデル（ota_updatesテーブル）
- セクション5.1 OTA更新エンドポイント
- セクション7.2 セキュリティ要件

### 3. デバイス認証におけるブルートフォース対策が未設計

**問題の説明**: MQTT接続時のデバイス認証（`device_key`検証）に対するレート制限やアカウントロックの仕組みが設計されていない。`device_key`が固定的な認証情報である場合、総当たり攻撃のリスクが高い

**影響**: 攻撃者がMQTTブローカーに対して大量の接続試行を行い、`device_key`を推測できる可能性。デバイスキーが漏洩すると、デバイスになりすまして不正なコマンドを実行したり、センサーデータを改ざんできる

**推奨対策**:
- MQTT Broker（Mosquitto等を使用の場合）にレート制限プラグインを導入
  - 同一IPアドレスから10回/分の接続失敗でブロック（30分間）
- Device Gateway Serviceに認証失敗記録を実装（Redisに記録）
  - 同一`device_key`で5回連続失敗した場合、そのキーを一時的に無効化（1時間）
- `device_key`のエントロピー要件を明確化（最低128bit、ランダム生成）
- `device_key`のローテーション機能を実装（年1回、またはセキュリティイベント発生時）

**該当箇所**:
- セクション3.2 主要コンポーネント（Device Gateway Service）
- セクション5.2 デバイス認証

---

## 改善提案（計画の品質向上に有効）

### 1. 監査ログにおける機密データのマスキング戦略が未設計

**提案の説明**: ロギング方針（セクション6.2）に記録する情報は列挙されているが、パスワード、デバイス認証キー（`device_key`）、JWTトークン等の機密データをマスキングする方針が明記されていない

**理由**: ログファイルへのアクセス権限は開発者や運用チームにも付与されることが多く、機密データが平文でログに記録されると情報漏洩のリスクが高まる。特に`device_key`が漏洩すると、デバイスのなりすましが可能

**推奨対策**:
- Winston（v3.11.0以降）のカスタムフォーマッタを実装し、以下のフィールドを自動マスキング:
  - `password`, `password_hash` → `"********"`
  - `device_key` → 最初の8文字のみ表示（例: `"a1b2c3d4****"`）
  - `Authorization`ヘッダー（JWTトークン） → `"Bearer ey****"`
- 環境変数`LOG_MASK_FIELDS`でマスキング対象フィールドを管理
- 本番環境ではマスキングを強制、開発環境では任意設定可能にする
- 監査ログ（認証イベント、権限変更）は別途CloudWatch Logsに暗号化して保存

**該当箇所**: セクション6.2 ロギング方針

### 2. デバイスコマンドAPIにおける冪等性保証が未設計

**提案の説明**: デバイス制御API（`POST /api/devices/:id/command`）において、ネットワークエラーやタイムアウト時のリトライによる二重実行を防ぐ仕組みが設計されていない

**理由**: モバイルアプリからのデバイス制御において、ネットワーク不安定時にクライアント側が自動リトライを行う可能性がある。同じコマンド（例: ドアロック解除）が複数回実行されると、セキュリティリスクや不正な状態遷移が発生

**推奨対策**:
- Idempotency Key（UUID v4）をリクエストヘッダー（`Idempotency-Key`）で受け取る
- Redisに以下の形式でキーを24時間保持:
  ```
  idempotency:{key} -> { "status": "success", "response": {...}, "created_at": ... }
  ```
- 同一キーでの再実行時は前回のレスポンスをキャッシュから返す（HTTP 200）
- Stripe APIの冪等性実装を参考に、POST/PUT/DELETEエンドポイントに適用
- クライアント側SDK（React Nativeアプリ）で自動的にIdempotency Keyを付与

**該当箇所**:
- セクション5.1 デバイス管理エンドポイント（POST /api/devices/:id/command）
- セクション3.3 データフロー

### 3. JWTトークンの保存方式と更新フローのセキュリティが不明確

**提案の説明**: JWT認証（セクション5.2）でアクセストークン（15分）とリフレッシュトークン（7日間）を使用する設計だが、以下が明記されていない:
- モバイルアプリ側でのトークン保存方式（Secure Storage使用の有無）
- リフレッシュトークンのローテーション戦略
- トークン失効機能（ログアウト、パスワード変更時の全トークン無効化）

**理由**: リフレッシュトークンが窃取された場合、7日間有効な長期間の不正アクセスが可能。モバイルデバイスの紛失・盗難時のリスクを低減するため、トークン管理の詳細設計が必要

**推奨対策**:
- モバイルアプリでのトークン保存:
  - React Native: `react-native-keychain`（v8.x）を使用してOSレベルのSecure Storageに保存
  - iOS: Keychain、Android: Keystore
- リフレッシュトークンローテーション:
  - `/api/auth/refresh`実行時に新しいリフレッシュトークンを発行し、古いトークンを無効化
  - Redisの`refresh_tokens:{user_id}`にトークンリストを保存（最大5つ、古いものから削除）
- トークン失効API: `POST /api/auth/revoke-all`（パスワード変更時に自動実行）

**該当箇所**:
- セクション5.2 認証・認可方式（ユーザー認証）
- セクション5.1 認証系エンドポイント

### 4. 管理者向けエンドポイントのレート制限が未設計

**提案の説明**: OTA更新パッケージ登録API（`POST /api/ota/updates`）が管理者向けとして記載されているが、このエンドポイントへのアクセス制御やレート制限が設計されていない

**理由**: 管理者エンドポイントはブルートフォース攻撃や権限昇格攻撃の標的になりやすく、成功時の影響が大きい（全デバイスへの悪意あるファームウェア配信）。セクション7.2で「APIレート制限: 同一IPから1分間に100リクエスト」とあるが、管理者エンドポイントには不十分

**推奨対策**:
- express-rate-limit（v7.1.0以降）で管理者エンドポイントに厳格な制限を設定:
  - `POST /api/ota/updates`: 10回/時間（同一IPまたは同一ユーザーID）
- 管理者専用の認証スコープ（JWTペイロードに`"role": "admin"`）を追加
- 管理者アクションの監査ログ（誰が、いつ、どのファームウェアを登録したか）をCloudWatch Logsに記録
- 多要素認証（MFA）の検討（OTA更新のような高リスク操作時）

**該当箇所**:
- セクション5.1 OTA更新エンドポイント
- セクション7.2 セキュリティ要件（APIレート制限）

### 5. S3ファームウェアイメージへのアクセス制御が不明確

**提案の説明**: OTA更新でファームウェアイメージをS3に保存する設計（セクション2.3、4）だが、S3オブジェクトへのアクセス制御方式が明記されていない。`s3_url`に署名付きURL（Pre-signed URL）を使用するか、公開URLとするかが不明

**理由**: S3オブジェクトが公開設定になっている場合、攻撃者がファームウェアイメージをダウンロードしてリバースエンジニアリングできる。デバイスのハードウェア設計や暗号鍵が漏洩するリスク

**推奨対策**:
- S3バケットをプライベート設定（パブリックアクセスブロック有効化）
- デバイスがファームウェアをダウンロードする際、OTA Update Serviceが署名付きURL（有効期限15分）を生成
- `GET /api/ota/check`レスポンスに署名付きURLを含める:
  ```json
  {
    "version": "1.2.3",
    "download_url": "https://s3.amazonaws.com/bucket/firmware.bin?AWSAccessKeyId=...&Expires=...&Signature=..."
  }
  ```
- S3バケットポリシーでECS FargateタスクロールからのみGetObject許可

**該当箇所**:
- セクション2.3 インフラ・デプロイ環境（ストレージ: S3）
- セクション4 データモデル（ota_updatesテーブル）
- セクション5.1 OTA更新エンドポイント

### 6. データベース接続情報とシークレット管理が未設計

**提案の説明**: PostgreSQL、Redis、InfluxDBへの接続情報（認証情報）をアプリケーションがどのように取得・管理するかが設計書に明記されていない

**理由**: データベース認証情報がソースコードや環境変数にハードコーディングされると、GitHubへの誤コミットやコンテナイメージ経由での漏洩リスクがある。特にECS Fargateのタスク定義に平文で記載すると、AWS Management Console閲覧者全員が閲覧可能

**推奨対策**:
- AWS Secrets Managerを使用してデータベース認証情報を管理
- ECS Fargateタスク定義で`secrets`フィールドを使用し、環境変数に動的にシークレットを注入:
  ```json
  "secrets": [
    {
      "name": "DB_PASSWORD",
      "valueFrom": "arn:aws:secretsmanager:region:account-id:secret:db-password"
    }
  ]
  ```
- アプリケーション起動時にSecrets Manager APIからシークレットを取得（キャッシュ1時間）
- シークレットのローテーション（90日ごと）を自動化
- JWT署名鍵もSecrets Managerで管理（`JWT_SECRET`）

**該当箇所**:
- セクション2.2 データベース
- セクション6.4 デプロイメント方針

### 7. InfluxDBとPostgreSQLの保存データ暗号化が未設計

**提案の説明**: データベース（PostgreSQL、InfluxDB）に保存されるデータの暗号化方式が設計書に明記されていない。特にセンサーデータ（温度、カメラ映像メタデータ等）にプライバシー情報が含まれる可能性

**理由**: データベースのバックアップファイルが漏洩した場合、またはディスクが物理的に盗まれた場合に、平文データが読み取られるリスク。GDPRやCCPAなどのプライバシー規制では、個人データの暗号化が要求される

**推奨対策**:
- PostgreSQL: AWS RDSの暗号化を有効化（AES-256、AWS KMS管理鍵）
  - 既存DBの場合はスナップショットから暗号化DBに移行
- InfluxDB: ストレージレベルの暗号化（EBS暗号化）を有効化
- 特に機密性の高いデータ（カメラ映像URL、位置情報等）はアプリケーションレベルで暗号化:
  - Node.js `crypto`モジュールでAES-256-GCM暗号化
  - 暗号化鍵はAWS KMSで管理（Data Encryption Key: DEK）
- バックアップファイルもS3暗号化（SSE-KMS）で保護

**該当箇所**:
- セクション2.2 データベース
- セクション7.2 セキュリティ要件

### 8. デバイスコマンドの検証ロジックが抽象的

**提案の説明**: セクション3.2でDevice Gateway Serviceが「コマンド検証」を行うとあるが、具体的な検証内容（ホワイトリスト、パラメータ範囲チェック等）が明記されていない

**理由**: デバイスコマンドの検証が不十分な場合、攻撃者が予期しないコマンドやパラメータ（例: `brightness: -999`や`command: "execute_shell"`）を送信し、デバイスの異常動作やコード実行を引き起こす可能性

**推奨対策**:
- デバイスタイプごとに許可コマンドのホワイトリストを定義:
  ```javascript
  const ALLOWED_COMMANDS = {
    "light": ["set_brightness", "set_color", "toggle"],
    "lock": ["lock", "unlock"],
    "camera": ["start_recording", "stop_recording"]
  };
  ```
- Joi（v17.x）でパラメータ検証スキーマを定義:
  ```javascript
  const schemas = {
    "set_brightness": Joi.object({
      brightness: Joi.number().min(0).max(100).required()
    })
  };
  ```
- 未知のコマンドや不正なパラメータは即座に拒否（HTTP 400）
- 検証ルールをデータベースまたは設定ファイル（JSON）で管理し、デバイスタイプ追加時に拡張可能に

**該当箇所**:
- セクション3.2 主要コンポーネント（Device Gateway Service）
- セクション5.3 リクエスト/レスポンス形式（デバイス制御コマンド送信）

---

## 確認事項（ユーザーへの確認が必要）

### 1. センサーデータの保持期間とプライバシーポリシー

**確認理由**: InfluxDBに蓄積されるセンサーデータ（温度、カメラ稼働履歴等）の保持期間が設計書に明記されていない。GDPRやCCPAでは個人データの保持期間制限が要求される

**選択肢とトレードオフ**:
- **オプションA（短期保持: 90日）**: プライバシーリスクを最小化、ストレージコスト削減。一方、長期トレンド分析が不可能
- **オプションB（長期保持: 2年）**: 機械学習や季節変動分析が可能。一方、データ主体の削除要求対応が複雑化、ストレージコスト増加
- **推奨**: 90日間のホット（高頻度アクセス）保持 + 2年間のコールド（集約データ）保持。ユーザーがデータ削除を要求した場合の削除API（`DELETE /api/users/:id/data`）を実装

### 2. MQTT通信の認証方式選択

**確認理由**: 現在の設計では`device_key`のみでデバイスを認証しているが、より強固な認証（TLS証明書ベース、OAuth 2.0等）が必要かを確認したい

**選択肢とトレードオフ**:
- **オプションA（現行: device_keyのみ）**: 実装が簡素、デバイス側の計算資源要件が低い。一方、キー漏洩時のリスクが高い
- **オプションB（TLS相互認証）**: デバイスごとにクライアント証明書を発行、MQTTブローカーで検証。セキュリティ最高。一方、証明書管理の複雑性増加、デバイス側の計算コスト増
- **オプションC（device_key + デバイス証明書のハイブリッド）**: 初回接続時に証明書検証、以降はセッションキャッシュ。バランス型
- **推奨**: オプションC。高価値デバイス（カメラ、ドアロック）には証明書を必須化、低価値デバイス（温度センサー）はdevice_keyのみ許可

### 3. リアルタイム通信（Socket.IO）の認証戦略

**確認理由**: セクション3.3でSocket.IO経由のリアルタイム通知が設計されているが、WebSocket接続時の認証方式が明記されていない

**選択肢とトレードオフ**:
- **オプションA（接続時にJWTトークンをクエリパラメータで送信）**: 実装が簡単。一方、ログにトークンが記録されるリスク
- **オプションB（接続後にauthイベントでトークンを送信）**: セキュア。一方、未認証接続が一時的に確立される
- **オプションC（HTTPヘッダーでトークンを送信）**: ベストプラクティス。一方、一部のWebSocketライブラリでサポート不足
- **推奨**: オプションC（Socket.IOはカスタムヘッダーをサポート）。接続確立後3秒以内に認証完了しない場合は切断

---

## 評価（良い点）

### 1. JWT認証の適切な有効期限設定

- アクセストークン15分、リフレッシュトークン7日間の設計は、セキュリティと利便性のバランスが取れている
- 短いアクセストークン有効期限により、トークン漏洩時の被害期間を最小化

### 2. TLS 1.2以上の暗号化要件

- 全通信をTLS 1.2以上で暗号化する要件（セクション7.2）は適切
- MQTT over TLSにより、デバイス通信の盗聴・改ざんを防止

### 3. パスワードハッシュ化のベストプラクティス

- bcryptでパスワードをハッシュ化し、コストファクタ10を設定する方針は現在のベストプラクティスに準拠
- レインボーテーブル攻撃に対して効果的

### 4. APIレート制限の基本設計

- 同一IPから1分間に100リクエストの制限は、DoS攻撃の基本的な防御として有効
- ただし、管理者エンドポイントにはより厳格な制限が必要（改善提案4参照）

### 5. 権限レベルの明確な定義

- owner/write/readの3段階の権限レベル設計により、最小権限の原則を実現可能
- 家族共有シナリオにおいて、適切なアクセス制御が可能
