# 観点定義: 構造的品質（設計レビュー）

## 概要
設計書/コードの構造的健全性をアーキテクチャ・設計レベルで評価する。SOLID原則、結合度/凝集度、変更容易性、テスタビリティ、エラーハンドリング戦略、YAGNIなど、長期的に持続可能なソフトウェアを実現するための工学原則への適合を、構造設計・変更容易性・拡張性・エラーハンドリング・テスタビリティ・API/データモデル設計の各側面から評価する。AIエージェントは全6カテゴリから最低1項目ずつ検出を試みる。

## 評価スコープ
- SOLID原則・構造設計（責務分離、依存方向、モジュール境界・レイヤー分離、結合度/凝集度、デザインパターンの過剰適用/誤適用の検出、循環依存）
- 変更容易性・モジュール設計（変更影響範囲の限定（コンポーネント境界を跨ぐ変更の波及、公開インターフェースの変更が利用側に波及しない設計（内部実装の詳細がインターフェースに漏れていないか、DTOとドメインモデルが分離されているか））、モジュール分割方針、状態管理（ステートレス/ステートフル、グローバル状態の制御方針（Singleton乱用、共有ミュータブル状態）））
- 拡張性・運用設計（将来の機能追加時に既存コードの変更を最小限に抑えるためのインターフェース設計（例: Strategy/Plugin パターンの欠如、ハードコードされた分岐）、段階的実装可能性（フェーズ分割可能な設計、モジュール間の循環依存が段階的デプロイを阻害していないか）、設定管理・環境差分（複数環境やデプロイ先が存在する場合の差分管理方針））
- エラーハンドリング・オブザーバビリティ（アプリケーションレベルのエラー分類・伝播・リカバリー戦略（ドメイン例外の分類体系、エラーコード設計、リトライ可能/不可能なエラーの区別）、ロギング設計（アプリケーションのエラーログ出力方針、構造化ログ、ログレベル戦略）、トレーシング（分散トレーシング設計、コンテキスト伝播））
- テスト設計・テスタビリティ（テスト戦略（単体/統合/E2Eテストの役割分担）、DI設計、外部依存の抽象化、モック可能性）
- API・データモデル品質（API設計原則（REST、GraphQL、gRPC等を含む一般的なインターフェース設計原則）、バージョニング、後方互換性、スキーマ進化戦略、データモデル設計（エンティティ関係、データモデルの冗長性や不整合リスクのある設計（データストアの種類に応じた適切な設計原則への不適合）、データ型・制約）、コンポーネント間のデータ契約（スキーマ、型）定義）

## スコープ外
- セキュリティ脆弱性（認証・認可、暗号化等）→ security で扱う
- パフォーマンス問題（クエリ最適化、キャッシュ戦略等）→ performance で扱う
- 既存コードとの規約一致 → consistency で扱う
- 並行性制御、トランザクション設計 → reliability で扱う

## ボーナス/ペナルティの判定指針
- **ボーナス対象**: SOLID違反、循環依存、現在の要件に対して不必要な間接化（1箇所からのみ呼ばれる抽象化層、使用されないインターフェース）など正解キーに含まれない構造的問題の検出
- **ペナルティ対象**: セキュリティ脆弱性、パフォーマンス問題、インフラレベルの障害回復パターン（サーキットブレーカー、リトライポリシー、フェイルオーバー、ヘルスチェック等）の指摘。なお、アプリケーションレベルのエラーハンドリング・リカバリー戦略は本観点のスコープ内
- **判断に迷うケース**: (a) ロギング/トレーシング: アプリケーションのエラーログ出力方針の設計 → structural-quality、ログ集約基盤やアラートルールの設計 → reliability。(b) 設計原則 vs 既存パターン: API設計がRESTful原則に反する → structural-quality、API命名が既存エンドポイントと不統一 → consistency。Factoryパターンの誤用 → structural-quality、既存コードがSingletonを使っているのに新規がFactoryを使う → consistency
