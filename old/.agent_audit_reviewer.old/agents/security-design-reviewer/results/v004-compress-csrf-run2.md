# セキュリティ設計レビュー結果

## 重大な問題（Critical）

### C1. カルテAPI・患者APIの認可制御が未設計
**問題**: `/api/records/{id}`, `/api/patients/{id}`, `/api/patients/{id}/records` において、リクエスト者が対象患者のカルテや個人情報にアクセスする権限を持つかの認可チェック設計が明示されていない。医療情報は最高レベルの機密データであり、不適切なアクセス制御は医療法・個人情報保護法違反および重大なプライバシー侵害を招く。

**影響**: 悪意ある患者が他患者のIDを推測してカルテや個人情報を大量取得できる（IDOR: Insecure Direct Object Reference）。診断内容、処方薬、検査結果、保険証番号などが漏洩し、深刻な医療プライバシー侵害が発生する。

**対策**:
1. 患者ロールの場合、`GET /api/patients/{id}` および `GET /api/patients/{id}/records` は `user_id` と認証済みユーザーIDの一致を必須とする
2. 医療従事者ロールの場合、所属医療機関の患者のみアクセス可能とする認可ロジックを設計（`MedicalInstitution` との関連チェック）
3. カルテAPI (`/api/records/*`) は、医療従事者が担当する患者または予約がある患者に限定し、Spring Securityの `@PreAuthorize` アノテーションで実装する

**参照箇所**: 「5.1 エンドポイント一覧」患者API・カルテAPI、「5.3 認証・認可方式」

---

### C2. 予約API・カルテAPIのリソース所有権検証が欠落
**問題**: `PUT /api/appointments/{id}`, `DELETE /api/appointments/{id}`, `PUT /api/records/{id}` において、リクエスト者が対象リソースの所有者または正当なアクセス権を持つかの検証設計が存在しない。

**影響**: 患者Aが患者Bの予約を変更・キャンセルできる、医師Cが担当外患者のカルテを改ざんできる。医療サービスの信頼性が損なわれ、診療記録の完全性が失われる。

**対策**:
1. `PUT /api/appointments/{id}`: 予約の `patient_id` と認証済み患者のIDを照合、または医療従事者が所属医療機関の予約のみ変更可能とする
2. `DELETE /api/appointments/{id}`: 同上の所有権検証を実施
3. `PUT /api/records/{id}`: 医療従事者が担当する患者のカルテのみ更新可能とする認可ロジックを設計

**参照箇所**: 「5.1 エンドポイント一覧」予約API・カルテAPI

---

### C3. データベース内の医療機密データの暗号化設計が未定義
**問題**: `patients` テーブルの `full_name`, `date_of_birth`, `address`, `phone_number`, `insurance_number` および `medical_records` テーブルの `diagnosis`, `prescription`, `lab_results` は、医療法・個人情報保護法で保護対象の機密データであるが、データベース内での暗号化設計が明示されていない。

**影響**: データベースへの不正アクセス（管理者の内部不正、バックアップメディアの盗難、脆弱性を突いた侵入）により、患者の氏名・生年月日・住所・診断内容・処方薬・保険証番号が平文で漏洩する。

**対策**:
1. PostgreSQLの Transparent Data Encryption (TDE) または AWS RDSの暗号化機能を有効化し、ディスク全体を暗号化
2. 特に機密性の高い `insurance_number`, `diagnosis`, `prescription` カラムはアプリケーション層でAES-256により暗号化してから保存する設計を追加
3. 暗号化キーはAWS KMS (Key Management Service) で管理し、定期ローテーションポリシーを設計

**参照箇所**: 「4.2 テーブル設計」patients・medical_records テーブル、「7.2 セキュリティ要件」

---

## 重要な問題（High）

### H1. 認証エンドポイントのブルートフォース攻撃対策が不十分
**問題**: `POST /api/auth/login` に対するレート制限設計が明示されていない。API Gatewayのグローバルレート制限（1分100リクエスト）は全エンドポイント共通であり、ログインエンドポイント単体への集中攻撃を防げない。

**影響**: 攻撃者が自動化ツールで短時間に大量のログイン試行を実行し、弱いパスワードを持つアカウントを総当たりで突破できる。医療従事者アカウントが侵害されると、全患者の医療情報が閲覧可能になる。

**対策**:
1. `/api/auth/login` 専用のレート制限を設計: 同一IPアドレスから1分間に5回、1時間に20回まで
2. アカウント単位のレート制限を追加: 同一ユーザー名への連続失敗5回でアカウントを15分間ロック
3. 失敗ログを記録し、異常なパターンを検知して管理者に通知する設計を追加

**参照箇所**: 「3.2 主要コンポーネントの責務と依存関係」API Gateway、「5.1 エンドポイント一覧」認証API

---

### H2. CSRF保護が未設計
**問題**: 状態変更API (`POST /api/appointments`, `PUT /api/appointments/{id}`, `DELETE /api/appointments/{id}`, `POST /api/records`, `PUT /api/records/{id}`) に対するCSRF (Cross-Site Request Forgery) 保護の設計が存在しない。

**影響**: 攻撃者が悪意のあるWebサイトに患者を誘導し、ログイン済みセッションを利用して患者の意図しない予約作成・キャンセルやカルテ改ざんを実行できる。

**対策**:
1. Spring SecurityのCSRF保護機能を有効化し、CSRFトークンをレスポンスヘッダーまたはCookieで返す設計を追加
2. React/React NativeクライアントはCSRFトークンを取得し、すべての状態変更リクエストのヘッダー（`X-CSRF-TOKEN`）に含める
3. または、JWTトークンをCookieではなくAuthorizationヘッダーで送信する現行方式を維持しつつ、`SameSite=Strict` 属性を持つセッションCookieを併用する設計を検討

**参照箇所**: 「5.1 エンドポイント一覧」予約API・カルテAPI、「5.3 認証・認可方式」

---

### H3. 内部通信（バックエンド↔データベース）の暗号化設計が未記載
**問題**: 「3.1 全体構成」および「7.2 セキュリティ要件」では外部通信のTLS暗号化のみ言及され、Spring Boot APIサーバーとPostgreSQL/Redis間の通信が平文であるか暗号化されるかが不明。

**影響**: 内部ネットワークへの侵入者（例: 横展開攻撃、内部不正）がネットワークトラフィックを盗聴し、患者の氏名・診断内容・パスワードハッシュを含むSQLクエリやセッションデータを取得できる。

**対策**:
1. PostgreSQL接続にSSL/TLSを必須化する設計を明記（JDBC接続文字列に `ssl=true&sslmode=require` を追加）
2. Redis接続にTLSを有効化する設計を明記（Redis 6.0以降のTLSサポートを活用）
3. AWS環境ではRDSのSSL証明書を検証し、中間者攻撃を防ぐ設計を追加

**参照箇所**: 「3.1 全体構成」、「7.2 セキュリティ要件」

---

### H4. パスワードリセット・トークンリフレッシュのレート制限が未設計
**問題**: 認証関連エンドポイント `POST /api/auth/refresh` に対するレート制限設計が欠落している（パスワードリセットエンドポイントが未記載のため、存在する場合も同様の問題）。

**影響**: リフレッシュトークンの総当たり攻撃や、パスワードリセットエンドポイントを悪用したアカウント列挙攻撃（存在するユーザー名の特定）が可能になる。

**対策**:
1. `/api/auth/refresh` に専用レート制限を設計: 同一トークンまたはIPから1分間に3回まで
2. パスワードリセットエンドポイント（未記載の場合は設計に追加）にもレート制限を設計: 同一IPから1時間に5回まで
3. アカウント列挙を防ぐため、存在しないユーザー名へのリセット要求にも同一レスポンス時間・メッセージを返す設計を追加

**参照箇所**: 「5.1 エンドポイント一覧」認証API

---

## 中程度の問題（Medium）

### M1. 監査ログの設計が認証失敗のみで不十分
**問題**: ロギング方針ではAPIリクエスト・レスポンスの記録のみが言及され、セキュリティ監査に必要な認証失敗、権限エラー、機密データアクセスの記録設計が明示されていない。

**影響**: セキュリティインシデント発生時に攻撃の痕跡を追跡できず、不正アクセスの検知が遅れる。コンプライアンス要件（医療情報システムの安全管理ガイドライン）を満たせない可能性がある。

**対策**:
1. 以下のイベントを専用の監査ログに記録する設計を追加:
   - 認証失敗（ユーザー名、IPアドレス、タイムスタンプ）
   - 認可エラー（リクエストパス、ユーザーID、ロール）
   - 機密データアクセス（カルテ閲覧・更新、患者情報取得時のユーザーID、患者ID、操作種別）
   - ロール・権限変更（管理者操作）
2. 監査ログは改ざん防止のため別ストレージ（S3 + Object Lock）に転送する設計を追加

**参照箇所**: 「6.2 ロギング方針」

---

### M2. CORS設定の具体的な許可オリジン設計が欠落
**問題**: React SPA・React Nativeアプリからのクロスオリジンアクセスがあるが、CORS (Cross-Origin Resource Sharing) 設定の許可オリジンリストが未設計。ワイルドカード (`*`) を使用すると認証情報を含むリクエストが失敗する。

**影響**: 開発時にワイルドカード設定を使い、本番環境でも残してしまうと、悪意のあるサイトからのAPIアクセスを許可してしまう。または、厳格すぎる設定で正規クライアントがブロックされる。

**対策**:
1. 許可するオリジンを明示的にリスト化する設計を追加（例: `https://app.medical-booking.com`, `https://admin.medical-booking.com`）
2. React Nativeアプリからのリクエストは通常CORSの対象外だが、WebViewを使用する場合は同様に許可オリジンを設計
3. 認証情報を含むリクエスト（`credentials: 'include'`）では `Access-Control-Allow-Origin: *` を使用しない設計方針を明記

**参照箇所**: 「3.1 全体構成」、「5.3 認証・認可方式」

---

### M3. JWTトークンのlocalStorage保存によるXSS脆弱性リスク
**問題**: 「5.3 認証・認可方式」でJWTトークンをlocalStorageに保存すると記載されているが、これはXSS (Cross-Site Scripting) 攻撃によりトークンが盗まれるリスクが高い。

**影響**: アプリケーションにXSS脆弱性が存在する場合、攻撃者がJavaScriptでlocalStorageからトークンを読み取り、患者・医療従事者になりすまして医療情報を窃取できる。

**対策**:
1. JWTトークンをHTTPOnly Cookie（JavaScriptからアクセス不可）に保存する設計に変更
2. Cookie属性に `Secure` (HTTPS必須), `SameSite=Strict` (CSRF対策) を設定
3. または、localStorage使用を継続する場合はXSS対策を徹底する設計を追加:
   - すべてのユーザー入力をサニタイズ（Reactのデフォルトエスケープに依存するだけでなく、`dangerouslySetInnerHTML` の使用を禁止）
   - Content Security Policy (CSP) ヘッダーを設定し、インラインスクリプトを禁止

**参照箇所**: 「5.3 認証・認可方式」

---

### M4. エラーメッセージに詳細なスタックトレースを含む設計の問題
**問題**: 「6.1 エラーハンドリング方針」で「エラーメッセージには詳細なスタックトレースを含め、デバッグを容易にする」と記載されているが、本番環境でスタックトレースを公開するとシステムの内部構造が漏洩する。

**影響**: 攻撃者がエラーレスポンスからフレームワークのバージョン、ファイルパス、データベーススキーマを推測し、既知の脆弱性を狙った攻撃を実行できる。

**対策**:
1. 本番環境ではスタックトレースを含まないエラーレスポンスを返す設計に変更
2. 詳細なエラー情報はサーバー側ログにのみ記録し、クライアントには汎用エラーメッセージ（「内部エラーが発生しました。サポートにお問い合わせください」）とエラーIDを返す
3. 開発環境と本番環境でエラーハンドリング設定を切り替える設計を明記

**参照箇所**: 「6.1 エラーハンドリング方針」

---

### M5. ログに機密情報（リクエストボディ全体）を記録する設計の問題
**問題**: 「6.2 ロギング方針」のログフォーマット例で `"requestBody": "{...}"` とすべてのリクエストボディを記録する設計になっているが、これはパスワード、診断内容、保険証番号などの機密情報をログに含める可能性がある。

**影響**: ログファイルへの不正アクセスや、ログ管理システムの脆弱性を通じて機密情報が漏洩する。ログをCloudWatch Logsに転送する設計のため、AWSアカウントが侵害された場合の影響範囲が拡大する。

**対策**:
1. ログ記録時に機密フィールドをマスキングする設計を追加（例: パスワード、診断内容、保険証番号を `***` に置換）
2. ログライブラリに機密フィールドのブラックリストを設定し、自動マスキングを実装
3. ログの保管期間とアクセス制御を設計（CloudWatch Logsのログ保持期間を30日に制限、IAMポリシーでアクセスを最小権限化）

**参照箇所**: 「6.2 ロギング方針」

---

## 軽微な改善提案（Low）

### L1. JWT署名アルゴリズムとシークレット管理方針の未記載
**問題**: JWT認証を採用しているが、署名アルゴリズム（HS256, RS256など）と署名鍵の管理方法が設計書に明示されていない。

**推奨事項**: JWT署名にRS256（RSA公開鍵暗号）を使用し、秘密鍵をAWS Secrets Managerで管理する設計を追加。HS256の場合は共有シークレットの定期ローテーションポリシーを設計。

**参照箇所**: 「5.3 認証・認可方式」

---

### L2. 依存ライブラリの脆弱性管理方針の未記載
**問題**: 「2.4 主要ライブラリ」で使用ライブラリが列挙されているが、これらの脆弱性スキャンや定期アップデートのプロセスが設計されていない。

**推奨事項**: GitHub Dependabot または Snyk を導入し、脆弱性が検出された依存ライブラリを自動検知・アラート送信する設計を追加。月次で依存ライブラリを更新するメンテナンスサイクルを設計。

**参照箇所**: 「2.4 主要ライブラリ」、「6.4 デプロイメント方針」

---

### L3. データベースバックアップの暗号化設計が未記載
**問題**: 「7.3 可用性・スケーラビリティ」でバックアップ取得は記載されているが、バックアップデータの暗号化設計が明示されていない。

**推奨事項**: PostgreSQLバックアップファイルをS3に保存する際、サーバーサイド暗号化（SSE-KMS）を有効化する設計を追加。バックアップデータへのアクセスをIAMロールで制限する設計を明記。

**参照箇所**: 「7.3 可用性・スケーラビリティ」

---

## 総評

本設計書は基本的な認証（JWT）、暗号化（TLS, bcrypt）、入力検証（Spring Validation, PreparedStatement）の設計が存在するが、**医療情報システムに要求される厳格なアクセス制御と機密データ保護の設計が不足**している。

特に重大な問題として、カルテAPI・患者APIの認可制御欠落（C1, C2）と、データベース内医療機密データの暗号化設計欠落（C3）は、医療法・個人情報保護法違反および深刻なプライバシー侵害のリスクをもたらす。これらは設計段階で必ず解決すべき。

また、認証エンドポイントのブルートフォース対策（H1）、CSRF保護（H2）、内部通信暗号化（H3）は、本番稼働前に設計を完成させることを強く推奨する。エラーハンドリング・ロギングの設計（M4, M5）も、情報漏洩リスクを低減するため早期に修正すべき。
