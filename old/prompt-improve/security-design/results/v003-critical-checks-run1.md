# セキュリティ設計レビュー: SmartHome IoTデバイス管理プラットフォーム

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | CSRF対策が未設計で状態変更APIが脆弱。リプレイ攻撃対策も不足 |
| 認証・認可設計 | 3 | JWTトークンの保存方式が不明。デバイス認証の鍵管理に課題 |
| データ保護 | 3 | センサーデータの暗号化が不明。MQTT通信のペイロード保護が未設計 |
| 入力検証設計 | 3 | ファイルアップロード制限が未設計。デバイスコマンドの検証戦略が不足 |
| インフラ・依存関係 | 2 | ファームウェア署名検証の具体的実装が不明。シークレット管理が未設計 |
| **総合** | **2.6** | |

---

## 重大な問題（設計の修正が必須）

### P01: 状態変更APIに対するCSRF対策が未設計

**問題の説明**: デバイス制御API（`POST /api/devices/:id/command`）、ユーザー招待API（`POST /api/devices/:id/invite`）、アクセス権削除API（`DELETE /api/devices/:id/access/:userId`）等の状態変更エンドポイントにCSRF対策が設計されていない。

**影響**: 攻撃者が用意した悪意あるWebページをユーザーが閲覧するだけで、意図しないデバイス制御（ドアロック解除、カメラ無効化等）やアクセス権変更が実行される。IoTデバイスは物理世界に影響を与えるため、CSRF攻撃の影響は深刻。

**推奨対策**:
- Double Submit Cookieパターンまたはcsurfパッケージ（v1.3.0）を用いたCSRFトークン検証を実装
- 全てのPOST/PUT/DELETEエンドポイントにミドルウェアとして適用
- SameSite=Strict属性のCookie設定も併用（多層防御）
- JWTトークンの保存方式をlocalStorageではなくHttpOnly Cookieとする

**該当箇所**: セクション5 API設計、セクション5.2 認証・認可方式

---

### P02: ファームウェア更新パッケージの署名検証が具体的に設計されていない

**問題の説明**: セクション7でファームウェア更新パッケージの署名検証が要件として挙げられているが、具体的な実装方式（署名アルゴリズム、鍵管理、検証フロー）が設計されていない。

**影響**: 攻撃者がS3バケットを侵害した場合、または中間者攻撃で悪意あるファームウェアに置き換えられた場合、デバイスが改ざんされたファームウェアを実行してしまう。IoTデバイスのファームウェア改ざんは、ボットネット化や家庭内ネットワークへの侵入経路となる。

**推奨対策**:
- ECDSA (P-256) またはEd25519による署名生成
- 署名秘密鍵をAWS KMSで管理、公開鍵をデバイスファームウェアに埋め込み
- デバイス側でダウンロード後、署名検証に失敗した場合はインストールを中止
- OTA Updateサービスで署名付きマニフェスト（JSON）を生成し、`s3_url`、`version`、`sha256_hash`、`signature`を含める
- 検証フロー: デバイスがマニフェストをダウンロード → 署名検証 → ハッシュ検証 → インストール実行

**該当箇所**: セクション6.4 デプロイメント方針、セクション7.2 セキュリティ要件

---

### P03: デバイス認証キー（device_key）のライフサイクル管理が未設計

**問題の説明**: デバイス認証に使用する`device_key`の発行方式、保存方式、ローテーション戦略、失効方式が設計されていない。一度発行されたキーが永続的に有効であれば、デバイス廃棄時やキー漏洩時にリスクが残る。

**影響**: デバイスキーが漏洩した場合、攻撃者は永続的にデバイスになりすましてコマンドを実行可能。デバイス廃棄時にキーが無効化されなければ、中古デバイスの購入者が前所有者のアカウントにアクセスできる可能性。

**推奨対策**:
- デバイスキーにHMAC-SHA256ベースのトークン生成を使用（シークレットはAWS Systems Manager Parameter Storeで管理）
- デバイス初回登録時にキーを生成し、デバイスの安全な領域（Secure Elementまたは暗号化ストレージ）に保存
- デバイスキーに有効期限（例: 1年）を設定し、期限前に自動ローテーション
- `device_key_revoked`カラムをdevicesテーブルに追加し、デバイス削除時または侵害検知時に即座に失効
- Device Gateway Serviceでキー検証時に失効リストをチェック（Redisキャッシュを活用）

**該当箇所**: セクション4 データモデル（devicesテーブル）、セクション5.2 認証・認可方式（デバイス認証）

---

### P04: MQTT通信のペイロード暗号化が未設計

**問題の説明**: MQTT接続はTLSで暗号化されると記載があるが（セクション7.2）、MQTTペイロード自体の暗号化は設計されていない。TLSはトランスポート層の暗号化であり、MQTT Broker内部や Redis経由でのデータ伝達時には平文となる。

**影響**: MQTT Broker または Redis が侵害された場合、デバイスコマンド（ドアロック解除コマンド等）やセンサーデータ（カメラ映像の有無、在宅状況等）が平文で露出する。内部ネットワークでの中間者攻撃や、ログファイルへのアクセスでも機密情報が漏洩する可能性。

**推奨対策**:
- MQTTペイロードをAES-256-GCMで暗号化（デバイス固有の対称鍵を使用）
- デバイス固有鍵の生成: デバイス登録時にAPI ServerがAWS KMSでデバイスごとの対称鍵を生成し、デバイスに安全に配布（TLS経由）
- デバイス側: コマンド受信時に復号化、テレメトリ送信時に暗号化
- API Server側: Redisからデータを読み取る際に復号化
- 鍵のローテーション: デバイスキーローテーション時に暗号鍵も更新

**該当箇所**: セクション3.3 データフロー、セクション7.2 セキュリティ要件

---

### P05: センサーデータAPIのアクセス制御が不十分

**問題の説明**: `GET /api/devices/:id/telemetry`エンドポイントでセンサーデータを取得する際、権限レベル（owner/write/read）のいずれかを持つユーザーであればアクセス可能と推測されるが、データの時間範囲制限やデータ量制限が設計されていない。

**影響**:
- 攻撃者が窃取したJWTトークンまたは招待された低権限ユーザーアカウントを悪用し、数年分のセンサーデータを一括取得することで、住人の生活パターン（在宅時間、就寝時刻等）を分析可能
- データ量制限がないため、大量のデータ取得リクエストによるDoS攻撃が可能

**推奨対策**:
- データ取得期間を最大31日間に制限（クエリパラメータ検証）
- 1回のリクエストで取得可能なデータポイント数を10,000件に制限
- `read`権限ユーザーには直近7日間のデータのみアクセス可能とする制限を追加
- レート制限を強化: センサーデータAPIは1分間に10リクエストまで（セクション7.2の100リクエストは緩い）
- 監査ログに大量データ取得リクエストを記録し、異常検知システムと連携

**該当箇所**: セクション5.1 エンドポイント一覧（センサーデータ）、セクション5.2 認証・認可方式（APIアクセス制御）

---

### P06: リフレッシュトークンのローテーション機能が未設計

**問題の説明**: リフレッシュトークンが7日間有効でRedisに保存されると記載があるが、トークン更新時のローテーション（古いトークンの無効化）が設計されていない。

**影響**: リフレッシュトークンが窃取された場合、攻撃者は7日間にわたって新しいアクセストークンを発行し続けることが可能。正規ユーザーと攻撃者が同時に同じリフレッシュトークンを使用できる状態は、攻撃検知を困難にする。

**推奨対策**:
- リフレッシュトークンのローテーション実装: 新しいアクセストークンを発行する際に、新しいリフレッシュトークンも発行し、古いトークンをRedisから削除
- リフレッシュトークンの再利用検知: 既に使用されたトークンで再度リクエストがあった場合、そのユーザーの全てのトークンを無効化（侵害の兆候）
- Redisのキーに `refresh_token:{token_id}` と `user_refresh_tokens:{user_id}` の2種類を保存し、ユーザー単位での全トークン失効を可能にする
- OAuth 2.0 Refresh Token Rotation のベストプラクティスに準拠

**該当箇所**: セクション5.2 認証・認可方式（ユーザー認証）

---

## 改善提案（設計の品質向上に有効）

### P07: 監査ログにおける機密データのマスキング戦略が未設計

**理由**: セクション6.2のロギング方針で構造化ログの記録項目が定義されているが、機密データ（パスワード、デバイスキー、JWTトークン、センサーデータの詳細等）のマスキング方針が明記されていない。ログファイルへのアクセス権限は開発者や運用チームにも付与されることが多く、機密データが平文でログに記録されると情報漏洩のリスクが高まる。

**推奨対策**:
- Winston（v3.11.0）またはPino（v8.x）のカスタムフォーマッタを実装し、機密フィールドを自動的にマスキング
- マスキング対象: `password`, `device_key`, `authorization`ヘッダー、`refresh_token`、センサーデータの生値
- マスキング形式: パスワードは`***`、トークンは先頭8文字のみ表示（例: `eyJhbGci...`→`eyJhbGci****`）
- 環境変数でマスキングルールを管理し、本番環境では厳格に適用、開発環境では柔軟に設定
- 監査ログとデバッグログを分離し、監査ログには機密データを含めない

**該当箇所**: セクション6.2 ロギング方針

---

### P08: デバイスコマンドの検証とサニタイゼーションが未設計

**理由**: `POST /api/devices/:id/command`でデバイス制御コマンドを送信する際、コマンドとパラメータの検証方式が設計されていない。`joi`（v17.x）を使用すると記載があるが（セクション2.4）、具体的なスキーマ定義やコマンドのホワイトリスト戦略が不明。

**推奨対策**:
- デバイスタイプごとに許可されたコマンドをホワイトリスト化（例: `light`タイプは`set_brightness`, `set_color`, `toggle`のみ許可）
- Joiスキーマでパラメータの型、範囲、形式を厳密に検証（例: `brightness`は0-100の整数）
- コマンド検証ミドルウェアを実装し、不正なコマンドはAPI層でリジェクト（Device Gateway Serviceに到達させない）
- デバイス側でもコマンド検証を実装（多層防御）
- 未知のコマンドや異常なパラメータを受信した場合、監査ログに記録し、アラートを発報

**該当箇所**: セクション5.3 リクエスト/レスポンス形式（デバイス制御コマンド送信）

---

### P09: OTA更新のロールバック機能とキルスイッチが未設計

**理由**: ファームウェアOTA更新機能が設計されているが、更新失敗時のロールバック機能や、緊急時に全デバイスの更新を停止するキルスイッチが設計されていない。悪意ある更新または不具合のある更新が配信された場合、被害が拡大する。

**推奨対策**:
- デバイス側にファームウェアABパーティションを実装し、更新失敗時は前バージョンに自動ロールバック
- OTA Update Serviceに段階的ロールアウト機能を実装: 最初は1%のデバイスに配信し、エラー率を監視しながら徐々に拡大
- `ota_updates`テーブルに`status`カラム（`active`, `paused`, `cancelled`）を追加し、管理者が配信を一時停止・中止可能にする
- デバイスが更新失敗を報告した場合、一定割合を超えたら自動的に配信を停止するキルスイッチを実装
- 更新後のデバイスヘルスチェック: 更新後にデバイスが正常に起動し、MQTT接続を確立できるかを監視

**該当箇所**: セクション5.1 エンドポイント一覧（OTA更新）、セクション4 データモデル（ota_updatesテーブル）

---

### P10: APIレート制限の粒度が粗い

**理由**: セクション7.2で「同一IPから1分間に100リクエストまで」と記載されているが、エンドポイントごとの制限や認証済みユーザーごとの制限が設計されていない。特に認証系エンドポイント（`/api/auth/login`）やデバイス制御エンドポイント（`/api/devices/:id/command`）は、より厳格な制限が必要。

**推奨対策**:
- express-rate-limit（v7.1.0）で階層的なレート制限を実装
  - グローバル制限: 同一IPから100リクエスト/分
  - 認証系エンドポイント: 5回/分（ブルートフォース対策）
  - デバイス制御エンドポイント: 10回/分/ユーザー（誤操作やAPI誤用を防ぐ）
  - センサーデータAPI: 10回/分/ユーザー（P05と同じ）
- 認証済みユーザーはIPベースではなくユーザーIDベースで制限
- レート制限超過時は`429 Too Many Requests`とRetry-Afterヘッダーを返す
- 繰り返し制限を超えるIPアドレスやユーザーを一時的にブロック（WAF連携）

**該当箇所**: セクション7.2 セキュリティ要件

---

### P11: デバイス削除時のデータ保持ポリシーが未設計

**理由**: ユーザーがデバイスを削除する際、センサーデータ（InfluxDB）やデバイスアクセス履歴（PostgreSQL）の保持期間や削除方針が設計されていない。GDPRやCCPA等のプライバシー規制では、ユーザーがデータ削除を要求した場合、合理的な期間内に削除する義務がある。

**推奨対策**:
- デバイス削除APIエンドポイント（`DELETE /api/devices/:id`）を追加
- 削除時の動作:
  - devicesテーブルのレコードは論理削除（`deleted_at`カラム追加）、物理削除は30日後にバッチ処理で実行
  - InfluxDBのセンサーデータは論理削除の時点で匿名化または削除（保持期間30日）
  - device_accessテーブルのレコードは即座に削除（アクセス権を無効化）
- 監査ログには削除要求とその実行を記録（コンプライアンス対応）
- ユーザーにデータ削除完了の通知を送信

**該当箇所**: セクション5.1 エンドポイント一覧（デバイス管理）

---

### P12: 管理者エンドポイントの認証・認可が未設計

**理由**: `POST /api/ota/updates`（更新パッケージ登録）は管理者向けと記載があるが、管理者認証の方式や管理者権限の定義が設計されていない。通常のユーザー認証と同じJWTトークンを使用する場合、権限昇格攻撃のリスクがある。

**推奨対策**:
- usersテーブルに`role`カラム（`user`, `admin`）を追加
- 管理者専用エンドポイント（`/api/admin/*`, `/api/ota/updates`）にロールベースアクセス制御（RBAC）ミドルウェアを適用
- 管理者ログインに多要素認証（MFA）を必須化（TOTP, SMS, WebAuthn等）
- 管理者操作は全て監査ログに記録（誰が、いつ、何をしたか）
- 管理者用APIエンドポイントに専用のレート制限（5回/15分）とIP制限（オフィスIPホワイトリスト）を設定

**該当箇所**: セクション5.1 エンドポイント一覧（OTA更新）

---

### P13: JWTトークンの署名アルゴリズムとシークレット管理が未設計

**理由**: JWT認証を使用すると記載があるが、署名アルゴリズム（HS256/RS256等）やシークレット鍵の管理方式が設計されていない。HS256を使用する場合、シークレットが漏洩すると全てのトークンが偽造可能。

**推奨対策**:
- RS256（RSA公開鍵暗号）を使用: 秘密鍵で署名、公開鍵で検証（秘密鍵の露出範囲を最小化）
- 秘密鍵をAWS KMSまたはAWS Secrets Managerで管理、API Server起動時に取得
- 鍵のローテーション: 秘密鍵を3ヶ月ごとに更新（古い鍵は1週間保持し、移行期間を設ける）
- JWTヘッダーに`kid`（Key ID）を含め、複数の鍵を同時にサポート
- `jsonwebtoken`パッケージの使用時、`algorithm`オプションを明示的に指定（`none`アルゴリズム攻撃を防ぐ）

**該当箇所**: セクション5.2 認証・認可方式（ユーザー認証）

---

### P14: Socket.IOのリアルタイム通信における認証・認可が未設計

**理由**: セクション3.3でSocket.IO経由でモバイルアプリにリアルタイム通知を送信すると記載があるが、Socket.IO接続時の認証方式や、デバイスごとのアクセス制御が設計されていない。

**推奨対策**:
- Socket.IO接続時にJWTトークンを検証（接続時のハンドシェイクでトークンを送信）
- ユーザーごとに専用のルーム（`user:{user_id}`）を作成し、そのユーザーがアクセス権を持つデバイスの通知のみを送信
- デバイスイベント送信前に、Device Gateway Serviceでユーザーの権限を検証
- Socket.IOの`transport`オプションをWebSocketのみに制限（long-polling攻撃を防ぐ）
- Socket.IO接続数のレート制限（1ユーザーあたり最大5接続）

**該当箇所**: セクション2.1 言語・フレームワーク（リアルタイム通信）、セクション3.3 データフロー

---

### P15: データベース接続のセキュリティ設定が未設計

**理由**: PostgreSQL、Redis、InfluxDBへの接続方式や認証情報の管理が設計されていない。平文のパスワードを環境変数に保存する方式は、コンテナイメージやログに露出するリスクがある。

**推奨対策**:
- データベース接続情報をAWS Secrets Managerで管理、API Server起動時に取得
- PostgreSQLへの接続にIAM認証を使用（パスワード不要）
- TLS接続を必須化: PostgreSQL（`sslmode=require`）、Redis（`tls: true`）、InfluxDB（HTTPSエンドポイント）
- データベースアカウントの最小権限の原則: API Server用アカウントはCRUD操作のみ、マイグレーション用アカウントは別途管理
- 接続プールの設定: 最大接続数を制限し、接続リークを監視

**該当箇所**: セクション2.2 データベース、セクション2.3 インフラ・デプロイ環境

---

### P16: ファイルアップロード機能のセキュリティ対策が未設計

**理由**: ファームウェアイメージをS3に保存すると記載があるが、アップロード時のファイルサイズ制限、ファイル形式検証、マルウェアスキャンが設計されていない。

**推奨対策**:
- ファイルサイズ制限: 最大100MB（multerミドルウェアで設定）
- ファイル形式検証: MIMEタイプとファイル拡張子をチェック（ファームウェアイメージは`.bin`, `.hex`, `.elf`等のみ許可）
- ファイルの内容検証: `file-type`パッケージでMagic Numberをチェック（拡張子偽装を防ぐ）
- S3バケットのセキュリティ設定: パブリックアクセスをブロック、バケットポリシーでAPI Serverからのみアクセス可能に設定
- アップロード後にAWS GuardDutyまたはClamAVでマルウェアスキャン（非同期）
- S3オブジェクトに署名付きURL（有効期限15分）を使用し、直接URLアクセスを防ぐ

**該当箇所**: セクション2.3 インフラ・デプロイ環境（ストレージ）、セクション5.1 エンドポイント一覧（OTA更新）

---

## 評価（良い点）

### 評価1: TLS暗号化の徹底

全ての通信をTLS 1.2以上で暗号化する方針（セクション7.2）は適切。HTTPSとMQTT over TLSの併用により、トランスポート層の保護が確保されている。

### 評価2: パスワードハッシュ化のベストプラクティス

パスワードをbcryptでハッシュ化し、コストファクタ10を設定している点（セクション7.2）は適切。bcryptはレインボーテーブル攻撃に強く、計算コストにより総当たり攻撃を遅延させる。

### 評価3: JWTアクセストークンの短い有効期限

アクセストークンの有効期限を15分に設定している点（セクション5.2）は適切。窃取されたトークンの悪用期間を最小化し、セキュリティリスクを低減している。

### 評価4: 権限レベルに基づくアクセス制御

デバイスアクセス権を`owner/write/read`の3段階で管理する設計（セクション4、セクション5.2）は適切。最小権限の原則に基づき、家族メンバーへの共有時にきめ細かな権限設定が可能。

### 評価5: Blue/Greenデプロイメントによる安全性

Blue/Greenデプロイメントとロールバック可能な構成（セクション6.4）は、アプリケーションレベルのセキュリティパッチ適用時のダウンタイムを最小化し、問題発生時の迅速な復旧を可能にする。
