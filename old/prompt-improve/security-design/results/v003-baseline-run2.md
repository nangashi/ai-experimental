# SmartHome IoTデバイス管理プラットフォーム セキュリティ評価レポート

**評価対象**: test-document-round-003.md
**評価日**: 2026-02-10
**評価者**: security-design-reviewer (v003-baseline)

---

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | デバイスなりすまし、コマンドインジェクション、監査ログ不足等、複数の重大な脅威が未対策 |
| 認証・認可設計 | 3 | JWT保存方式とリフレッシュトークンのローテーション未設計、権限チェックの実装詳細不足 |
| データ保護 | 2 | 機密データの暗号化方針未定義、MQTT通信の相互TLS認証不足、S3バケット公開リスク |
| 入力検証設計 | 2 | コマンドパラメータ検証未設計、ファイルアップロード検証不足、SQLインジェクション対策の言及なし |
| インフラ・依存関係 | 3 | シークレット管理方針未定義、依存関係の脆弱性管理未設計、ネットワークセグメンテーション不足 |
| **総合** | **2.4** | |

---

## 1. 重大な問題（設計の修正が必須）

### 1-1. デバイス認証にデバイスキーのみを使用（なりすましリスク）

**問題**: デバイス認証が固定の `device_key` のみで行われ、デバイスの真正性を検証する仕組みがない

**影響**:
- `device_key` が漏洩した場合、攻撃者は正規デバイスになりすましてコマンドを受信・実行できる
- デバイスの物理盗難時に、攻撃者が別のネットワークから接続可能
- 家庭内のカメラやドアロックデバイスがなりすまされた場合、プライバシー侵害や物理的安全リスクが発生

**推奨対策**:
- デバイス証明書ベースの相互TLS認証（mTLS）を実装
- デバイス製造時に固有の証明書を埋め込み、MQTT接続時にサーバー側で証明書検証
- `device_key` は初回登録時のみ使用し、登録後は証明書ベース認証に移行
- デバイスのハードウェアセキュリティモジュール（TPM/Secure Element）に秘密鍵を保存

**該当箇所**: セクション5「認証・認可方式 > デバイス認証」、セクション3「アーキテクチャ設計」

---

### 1-2. デバイス制御コマンドの検証・認可不足

**問題**: デバイス制御コマンドのパラメータ検証と、ユーザー権限に応じたコマンド制限の設計がない

**影響**:
- 悪意あるユーザーが異常なパラメータ（brightness: 999999）を送信し、デバイスを誤動作させる
- `read` 権限のユーザーが `write` 権限を要するコマンドを実行できる可能性
- カメラやドアロックへの不正コマンドによる、プライバシー侵害や物理的安全リスク

**推奨対策**:
- デバイスタイプごとに許可コマンドとパラメータ範囲を定義（例: brightness: 0-100）
- Joiスキーマでコマンドパラメータを検証
- 権限レベルに応じたコマンド認可マトリクスを実装（例: `read` 権限は状態取得のみ、`write` 権限は制御コマンド許可）
- Device Gateway Serviceでコマンド検証レイヤーを追加

**該当箇所**: セクション5「API設計 > デバイス管理」、セクション3「データフロー」

---

### 1-3. OTA更新パッケージのダウンロードURL保護不足

**問題**: `ota_updates` テーブルに平文のS3 URLが保存されているが、署名付きURL生成の設計がない

**影響**:
- S3バケットが誤って公開された場合、誰でもファームウェアをダウンロード・リバースエンジニアリング可能
- 攻撃者が古いファームウェアの脆弱性を発見し、既知の攻撃手法を適用できる
- ファームウェア内の埋め込みシークレット（証明書、APIキー）が流出

**推奨対策**:
- S3バケットを完全プライベートに設定（パブリックアクセス全面禁止）
- OTA更新API（`GET /api/ota/check`）で署名付きURL（Presigned URL、有効期限15分）を動的生成
- デバイス認証後にのみ署名付きURLを返す
- CloudFront + S3を使用し、CloudFrontのSigned Cookiesでアクセス制御

**該当箇所**: セクション4「データモデル > ota_updates テーブル」、セクション5「API設計 > OTA更新」

---

### 1-4. 監査ログとセキュリティイベントのロギング不足

**問題**: ロギング方針にセキュリティイベント（認証失敗、権限エラー、異常なデバイス動作）の記録が含まれていない

**影響**:
- 攻撃やセキュリティインシデントの検知が遅れる
- 事後調査（フォレンジック）時に証拠となるログが不足
- コンプライアンス要件（GDPR、ISO 27001）の監査証跡が不十分
- 内部不正行為（管理者権限の悪用）を検知できない

**推奨対策**:
- 以下のセキュリティイベントを必ず記録:
  - 認証失敗（ユーザー、デバイス）とブルートフォース試行
  - 権限エラー（アクセス拒否、権限昇格試行）
  - デバイスの異常動作（不正なコマンド、異常な通信量）
  - 管理者操作（OTA更新登録、ユーザー削除、権限変更）
- ログに含めるべき情報: タイムスタンプ、ユーザーID/デバイスID、送信元IP、操作内容、結果（成功/失敗）
- ログを改ざん不可能なストレージ（CloudWatch Logs、S3 + Object Lock）に保存
- SIEM（Security Information and Event Management）システムと連携し、リアルタイム検知を実装

**該当箇所**: セクション6「実装方針 > ロギング方針」

---

### 1-5. PostgreSQLへのSQLインジェクション対策の未記載

**問題**: データベースクエリの実装方針にプリペアドステートメントやORM使用の言及がない

**影響**:
- 開発者が文字列連結でクエリを構築した場合、SQLインジェクション脆弱性が発生
- 攻撃者がユーザー情報、デバイス認証キー、センサーデータを窃取可能
- データベースの全データ削除（`DROP TABLE`）や権限昇格のリスク

**推奨対策**:
- プリペアドステートメントまたはORMライブラリ（Sequelize、TypeORM）を必須化
- コードレビューガイドラインで文字列連結によるクエリ構築を禁止
- 静的解析ツール（ESLint + eslint-plugin-security）でSQLインジェクションパターンを検出
- データベースユーザーの権限を最小化（APIサーバーは`DROP`/`CREATE`権限を持たない）

**該当箇所**: セクション6「実装方針」、セクション2「技術スタック > データベース」

---

### 1-6. MQTT BrokerとDevice Gateway Serviceの認可制御不足

**問題**: MQTT Brokerがデバイスからのトピック購読・発行を制限する設計がない

**影響**:
- デバイスAが、本来アクセスできないデバイスBの制御トピックを購読し、コマンドを傍受
- 悪意あるデバイスが他デバイスになりすまして不正なコマンドを発行
- デバイス間の水平権限昇格攻撃（Horizontal Privilege Escalation）

**推奨対策**:
- MQTT BrokerのACL（Access Control List）を設定し、デバイスごとに購読・発行可能なトピックを制限
- トピック命名規則: `devices/{device_id}/commands`、`devices/{device_id}/telemetry`
- デバイスは自分のデバイスIDに対応するトピックのみアクセス可能に設定
- Device Gateway ServiceでトピックとデバイスIDの一致を再検証

**該当箇所**: セクション3「アーキテクチャ設計 > MQTT Broker」

---

## 2. 改善提案（設計の品質向上に有効）

### 2-1. JWTトークンの保存場所とトークンローテーション戦略の明示化

**提案**: モバイルアプリでのJWTトークン保存方式とリフレッシュトークンのローテーション戦略を設計に追加

**理由**:
- 現状、トークンの保存場所が未定義（localStorageはXSS脆弱性、Secure Storageが推奨）
- リフレッシュトークンのローテーションがないと、トークン窃取後の被害期間が長期化
- React Nativeアプリでのトークン管理は、プラットフォーム固有のセキュアストレージ（iOS Keychain、Android Keystore）を使用すべき

**推奨対策**:
- トークン保存: React Native Keychain（iOS Keychain、Android Keystore）を使用
- リフレッシュトークンローテーション: トークンリフレッシュ時に新しいリフレッシュトークンを発行し、古いトークンを無効化
- Redisにリフレッシュトークンのハッシュ値を保存し、使用済みトークンの再利用を検知
- リフレッシュトークンの再利用検知時は、該当ユーザーの全セッションを強制ログアウト

---

### 2-2. APIレート制限の細分化（エンドポイントごとの制限）

**提案**: APIレート制限を全体（100リクエスト/分/IP）だけでなく、エンドポイントごとに設定

**理由**:
- 認証エンドポイント（`/api/auth/login`）はブルートフォース攻撃の標的になりやすい
- デバイスコマンド送信（`/api/devices/:id/command`）の過剰なリクエストはDoS攻撃につながる
- センサーデータ取得（`/api/devices/:id/telemetry`）の大量リクエストはデータベース負荷を増大

**推奨対策**:
- 認証エンドポイント: 10リクエスト/分/IP（ログイン試行回数制限）
- デバイスコマンド: 30リクエスト/分/ユーザー
- センサーデータ取得: 60リクエスト/分/ユーザー
- express-rate-limit（v7.x）のストアをRedisに設定し、分散環境で一貫したレート制限を実装
- レート制限超過時のHTTPステータス: 429 Too Many Requests、リトライ可能な時刻をヘッダーで返す

---

### 2-3. 機密データ（パスワード、デバイスキー）の暗号化保存

**提案**: データベース内の `password_hash`、`device_key` を追加暗号化（Encryption at Rest）

**理由**:
- 現状、bcryptハッシュ化されたパスワードは、データベースが漏洩した場合にオフライン攻撃を受けるリスクがある
- `device_key` は平文保存されており、データベース漏洩時に全デバイスが危険にさらされる
- GDPRやPCI DSSでは、機密データの多層保護（暗号化＋ハッシュ化）が推奨される

**推奨対策**:
- PostgreSQLの列レベル暗号化（pgcrypto拡張）または、アプリケーション層での暗号化を実装
- 暗号化キーをAWS KMS（Key Management Service）で管理
- `device_key` は登録時にのみ平文で返し、データベースには暗号化して保存
- データベースバックアップも暗号化（RDS自動暗号化バックアップ）

---

### 2-4. デバイスファームウェア更新パッケージのロールバック機能

**提案**: OTA更新失敗時の自動ロールバック機能を設計に追加

**理由**:
- ファームウェア更新失敗時にデバイスが起動不能（ブリック）になるリスク
- ロールバック機能がないと、デバイスの物理回収とリカバリーが必要になり、サポートコストが増大
- セキュリティ更新を安全に適用するため、失敗時の自動復旧が重要

**推奨対策**:
- デバイス側にA/Bパーティション方式を実装（更新はBパーティションに適用、成功時にAと切り替え）
- 更新後の起動確認タイムアウト（5分以内に正常動作レポートがない場合、自動的に旧バージョンに復帰）
- OTA Update Serviceで更新成功率（デバイスごと、バージョンごと）を記録し、失敗率が高い場合は配信停止

---

### 2-5. Socket.IOのセキュリティ設定（CORS、認証）

**提案**: Socket.IOのCORS設定と接続時の認証方式を設計に明記

**理由**:
- 現状、Socket.IOのセキュリティ設定が未定義
- CORS設定が緩い場合、悪意あるサイトからWebSocketを通じてリアルタイム通知を傍受可能
- 認証なしでSocket.IO接続を許可すると、攻撃者が任意のデバイス状態変更を購読できる

**推奨対策**:
- Socket.IO接続時にJWTトークンを検証（接続時のhandshakeクエリパラメータまたはヘッダーで送信）
- CORS設定を厳格化（許可するオリジンをモバイルアプリのドメインのみに制限）
- Socket.IOの`transports`を`['websocket']`に限定（ポーリングを無効化）
- クライアント側でSocket.IO接続の再接続ロジックを実装し、トークン有効期限切れ時は自動リフレッシュ

---

### 2-6. デバイスの最終接続日時を用いた異常検知

**提案**: `last_seen` カラムを活用し、デバイスの異常な接続パターンを検知

**理由**:
- デバイスが通常の接続頻度から外れた動作（例: 毎時接続 → 毎秒接続）をする場合、マルウェア感染や不正操作の可能性
- 長期間接続がないデバイスが突然接続した場合、盗難デバイスの可能性

**推奨対策**:
- デバイスの通常接続パターンを学習し、異常検知アルゴリズムを実装
- 異常検知時にユーザーに通知（メール、プッシュ通知）
- 疑わしいデバイスを一時的に隔離（制限モード: コマンド受信不可、テレメトリ送信のみ許可）
- `last_seen` の更新をログに記録し、接続履歴を追跡可能に

---

## 3. 確認事項（ユーザーへの確認が必要）

### 3-1. GDPRなどのプライバシー規制の適用範囲

**確認理由**: センサーデータ（特にカメラ映像）やユーザー位置情報を扱う場合、GDPRやCCPAの適用を受ける可能性がある

**質問**:
- 本プラットフォームはEU圏内のユーザーを対象とするか？
- カメラデバイスは動画・静止画を保存するか、リアルタイムストリーミングのみか？
- ユーザーデータの保持期間と削除ポリシーは決まっているか？

**選択肢とトレードオフ**:
- **GDPR準拠を実装**: データ削除権（Right to Erasure）、データポータビリティ、同意管理機能を追加。開発コスト増加。
- **EU圏外に限定**: プライバシー規制の負担を軽減。市場機会の制限。

---

### 3-2. デバイス証明書の発行・管理プロセス

**確認理由**: デバイス証明書ベースの認証を実装する場合、製造プロセスとの統合が必要

**質問**:
- デバイスメーカーはどのタイミングで証明書を埋め込むか（製造時、初回起動時）？
- 証明書の更新頻度と有効期限は？
- デバイスの物理的なセキュリティ（改ざん防止）はどの程度確保されているか？

**選択肢とトレードオフ**:
- **製造時に証明書を埋め込む**: 最もセキュア。製造プロセスの変更が必要。
- **初回起動時にプロビジョニング**: 柔軟性が高い。プロビジョニングプロセス自体のセキュリティが重要。
- **AWS IoT Core証明書管理を使用**: 証明書ライフサイクル管理を自動化。AWS依存度が増加。

---

### 3-3. インフラのネットワークセグメンテーション戦略

**確認理由**: 現状のアーキテクチャ図では、API Server、MQTT Broker、データベースのネットワーク分離が不明

**質問**:
- API ServerとMQTT Brokerは同一VPC内の異なるサブネットに配置するか？
- データベース（PostgreSQL、InfluxDB、Redis）はプライベートサブネットに配置するか？
- ALBからの通信のみを許可するセキュリティグループ設定をするか？

**選択肢とトレードオフ**:
- **厳格なネットワークセグメンテーション**: セキュリティ向上、攻撃面の縮小。設定複雑度の増加。
- **緩いネットワーク設定**: 初期開発の迅速化。セキュリティリスクの増加。

---

## 4. 評価（良い点）

### 4-1. 短命なアクセストークンとリフレッシュトークンの分離

**評価**: アクセストークン（15分）とリフレッシュトークン（7日）を分離し、トークン窃取時の被害期間を短縮する設計は適切

**詳細**:
- アクセストークンが窃取されても、15分後には自動的に無効化される
- リフレッシュトークンをRedisで管理することで、サーバー側で即座に無効化可能
- この設計は、OAuth 2.0のベストプラクティスに準拠

---

### 4-2. TLS 1.2以上の強制と暗号化通信の全体適用

**評価**: 全ての通信（HTTPS、MQTT/TLS）をTLS 1.2以上で暗号化する方針は、通信傍受リスクを大幅に低減

**詳細**:
- TLS 1.2は現在の標準であり、既知の暗号スイート脆弱性を回避
- MQTT/TLS使用により、デバイス通信も暗号化され、中間者攻撃（MITM）を防止

---

### 4-3. bcryptによるパスワードハッシュ化（コストファクタ10）

**評価**: bcryptはレインボーテーブル攻撃に強く、コストファクタ10は現在の推奨値に準拠

**詳細**:
- bcryptは計算コストが高く、ブルートフォース攻撃を困難にする
- コストファクタ10は、2026年時点で適切なバランス（セキュリティとパフォーマンス）

---

### 4-4. ファームウェア更新パッケージの署名検証

**評価**: OTA更新パッケージの署名検証により、改ざんされたファームウェアのインストールを防止

**詳細**:
- デバイス側で署名検証を実装することで、攻撃者が悪意あるファームウェアを配信する攻撃を無効化
- この設計は、IoTデバイスのサプライチェーン攻撃対策として重要

---

### 4-5. 権限レベルの3段階設計（owner/write/read）

**評価**: デバイスアクセス権限を3段階に分けることで、家族共有時の最小権限原則を実現

**詳細**:
- `read` 権限で状態確認のみ、`write` 権限で制御可能、`owner` 権限で招待・削除可能という段階的な権限設計
- 家族メンバーやゲストに過剰な権限を与えないことで、誤操作や悪意ある操作を防止

---

## まとめ

本設計書は、短命なJWTトークン、TLS暗号化、bcryptパスワードハッシュ化、ファームウェア署名検証など、基本的なセキュリティベストプラクティスを採用している点で評価できます。

一方で、以下の**重大な問題**が存在し、本番環境への展開前に修正が必須です:
1. デバイス認証の脆弱性（固定キーのみ、証明書認証不足）
2. デバイスコマンドの検証・認可制御の不足
3. OTA更新パッケージのアクセス制御不足
4. セキュリティ監査ログの欠如
5. SQLインジェクション対策の未記載
6. MQTT Brokerのトピックレベル認可制御不足

これらの問題は、IoTプラットフォーム特有の脅威（デバイスなりすまし、不正コマンド、ファームウェア改ざん）に対する対策が不十分であることを示しています。特に、家庭内のカメラやドアロックを制御するシステムでは、これらの脅威が物理的安全やプライバシーに直結するため、優先的に対処すべきです。

**推奨される次のステップ**:
1. デバイス証明書ベースのmTLS認証を設計に追加
2. デバイスコマンド検証レイヤーと権限ベースの認可マトリクスを定義
3. セキュリティ監査ログの要件を明確化し、SIEM統合を計画
4. OTA更新のS3署名付きURL生成フローを設計
5. MQTT BrokerのACL設定とトピックレベル認可を実装
6. ペネトレーションテストまたは脅威モデリングワークショップを実施し、追加の脅威を特定
