# SmartHome IoTデバイス管理プラットフォーム セキュリティ評価レポート

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | MQTT通信のTampering/Spoofing対策、デバイスなりすまし防止策が未設計 |
| 認証・認可設計 | 3 | JWTの保存方式が未記載、リフレッシュトークンのローテーション未設計、権限チェックロジックが不明瞭 |
| データ保護 | 2 | センサーデータの暗号化未設計、S3バケットのアクセス制御未記載、監視カメラ映像の保護策が欠落 |
| 入力検証設計 | 3 | コマンドパラメータの検証ルールが不明、ファームウェア検証の詳細が欠落、SQLインジェクション対策が未記載 |
| インフラ・依存関係 | 3 | JWTシークレットの管理方法が未記載、依存ライブラリの更新方針が欠落、ネットワーク分離設計が不明 |
| **総合** | **2.6** | |

---

## 1. 重大な問題（設計の修正が必須）

### 1-1. MQTT通信のメッセージ改ざん・なりすまし対策が未設計

**問題**: デバイス認証に `device_key` のみを使用し、MQTT通信のメッセージレベルの署名検証や暗号化が設計されていない。`device_key` が漏洩した場合、攻撃者は正規デバイスになりすまして任意のコマンドを送受信可能。

**影響**:
- デバイスキー漏洩時、攻撃者がドアロックの解錠コマンドを送信可能（物理的侵入）
- カメラ映像の傍受、センサーデータの改ざん
- 偽のファームウェア更新指示による複数デバイスの乗っ取り

**推奨対策**:
1. MQTT over TLSに加え、メッセージレベルのHMAC署名を実装
   - 各デバイスに `signing_key`（`device_key` とは別）を発行
   - MQTTペイロードに `{"command": "...", "hmac": "sha256(...)"}`形式で署名を含める
   - Device Gateway Serviceで署名を検証し、改ざんされたメッセージを拒否
2. デバイスキーのローテーション機構を実装
   - 90日ごとに新しい `device_key` を自動発行
   - 古いキーの無効化とデバイスへの安全な配布方法（OTA経由）

**該当箇所**: セクション3（アーキテクチャ設計）、セクション5（デバイス認証）

---

### 1-2. S3ファームウェアイメージの署名検証と配布制御が不十分

**問題**:
- ファームウェア更新パッケージの署名検証が「要件」として記載されているが、具体的な実装方式が未設計
- S3 URLのアクセス制御方法が未記載（`ota_updates.s3_url` に恒久的な公開URLを保存している可能性）
- 署名鍵の管理方法が欠落

**影響**:
- 攻撃者がS3バケットに不正なファームウェアをアップロードし、10万台のデバイスにマルウェアを配布可能
- S3 URLが漏洩した場合、競合他社が独自ファームウェアを解析・リバースエンジニアリング可能

**推奨対策**:
1. コード署名の実装
   - AWS KMS（HSMバックエンド）で署名鍵ペアを生成・管理
   - ファームウェアビルド時に `openssl dgst -sha256 -sign private.key firmware.bin` で署名
   - デバイス側に公開鍵を埋め込み、OTA更新前に `openssl dgst -sha256 -verify public.key` で検証
2. S3バケット保護
   - S3バケットをプライベートに設定（パブリックアクセス禁止）
   - `ota_updates.s3_url` には署名付きURL（15分有効期限）を保存
   - CloudFront + 署名付きCookieでダウンロードを制御
3. ファームウェアのバージョンロールバック攻撃対策
   - デバイスに「受け入れ可能な最小バージョン」を設定
   - 古いバージョンへのダウングレードを拒否

**該当箇所**: セクション5（OTA更新API）、セクション7（セキュリティ要件）

---

### 1-3. 監視カメラ映像の保存・転送時の暗号化が欠落

**問題**: 設計書にカメラデバイスタイプの記載があるが、映像データの保存場所、転送プロトコル、暗号化方式が完全に欠落している。

**影響**:
- カメラ映像が平文でS3に保存された場合、AWS管理者や侵害されたIAMロールがプライバシーデータを閲覧可能
- MQTT経由で映像を送信する場合、TLSのみでは不十分（デバイスキー漏洩時に復号可能）

**推奨対策**:
1. エンドツーエンド暗号化の実装
   - カメラデバイスで映像をAES-256-GCMで暗号化してからMQTT送信
   - 暗号化キーはユーザーのパスワード由来（PBKDF2）またはデバイス固有のHSM鍵を使用
   - モバイルアプリ側でのみ復号（サーバー側は暗号化されたblobを中継）
2. S3保存時の対策
   - S3サーバーサイド暗号化（SSE-KMS）を有効化
   - バケットポリシーで暗号化されていないオブジェクトのアップロードを拒否
   - アクセスログの有効化とCloudWatch Logs Insightsでの監視
3. データ保持ポリシー
   - カメラ映像の自動削除ルール（例: 30日後に削除）をS3ライフサイクルポリシーで設定

**該当箇所**: セクション4（データモデル）、セクション5（API設計）に追加が必要

---

### 1-4. 権限チェックロジックとアクセス制御の実装が不明瞭

**問題**:
- `device_access.permission`（owner/write/read）の具体的な権限範囲が未定義
- APIエンドポイント単位での権限チェック実装方法が記載されていない
- 横方向アクセス制御（IDOR: Insecure Direct Object Reference）の防止策が欠落

**影響**:
- 攻撃者が他人のデバイスIDを推測し、`GET /api/devices/:id` でデバイス情報を窃取
- `read` 権限のユーザーが `POST /api/devices/:id/command` でドアロックを解錠
- デバイス招待機能（`POST /api/devices/:id/invite`）の権限チェック漏れで、第三者が勝手にアクセス権を付与

**推奨対策**:
1. 権限定義の明確化
   ```
   owner: デバイス削除、OTA更新強制、ユーザー招待、全ての設定変更
   write: デバイス制御コマンド送信、設定変更（削除・招待を除く）
   read: センサーデータ閲覧、デバイスステータス確認のみ
   ```
2. Express.jsミドルウェアでの実装
   ```javascript
   // 各APIルートに権限チェックミドルウェアを適用
   router.post('/devices/:id/command',
     authenticate,
     requireDeviceAccess(['owner', 'write']),
     commandHandler);

   router.delete('/devices/:id/access/:userId',
     authenticate,
     requireDeviceAccess(['owner']), // owner のみ許可
     deleteAccessHandler);
   ```
3. IDOR対策
   - デバイスIDをUUIDv4で生成（推測不可能）
   - 全てのAPIで `device_access` テーブルをJOINし、リクエストユーザーのアクセス権を確認
   - 不正アクセス試行を検知し、ログとアラート送信

**該当箇所**: セクション5（API設計）、セクション5（認証・認可方式）

---

### 1-5. リフレッシュトークンのローテーション未実装による窃取リスク

**問題**: リフレッシュトークンが7日間有効だが、トークンローテーション（使用後の無効化）が設計されていない。リフレッシュトークンが一度漏洩すると、攻撃者は7日間アクセス可能。

**影響**:
- XSS攻撃やネットワーク盗聴でリフレッシュトークンが窃取された場合、攻撃者は7日間ユーザーアカウントを乗っ取り可能
- 正規ユーザーがログアウトしても、攻撃者はリフレッシュトークンで再ログイン可能

**推奨対策**:
1. リフレッシュトークンローテーションの実装
   ```javascript
   // POST /api/auth/refresh
   // 1. 受信したリフレッシュトークンをRedisで検証
   // 2. 検証成功後、古いトークンをRedisから削除
   // 3. 新しいリフレッシュトークンを発行してRedisに保存
   // 4. 新しいアクセストークンと新しいリフレッシュトークンを返却
   ```
2. リフレッシュトークン再利用検知
   - 使用済みトークンの再利用を検知した場合、そのユーザーの全トークンを無効化（セッション全破棄）
   - ユーザーに不正アクセスの可能性を通知
3. Redisのデータ構造
   ```
   Key: refresh_token:{token_id}
   Value: {user_id, issued_at, device_fingerprint}
   TTL: 7日
   ```

**該当箇所**: セクション5（認証・認可方式）

---

## 2. 改善提案（設計の品質向上に有効）

### 2-1. APIレート制限の詳細設計が不足

**提案**: 現在「同一IPから1分間に100リクエスト」とあるが、エンドポイント別・ユーザー別のレート制限が未設計。特にログインエンドポイント、デバイス制御コマンド、招待機能は厳格な制限が必要。

**理由**:
- ログインエンドポイントはブルートフォース攻撃の標的
- デバイス制御コマンドの大量送信でDoS攻撃（例: 10万台の照明を1秒間に点滅させる）
- 招待機能の悪用でスパム送信

**推奨対策**:
1. express-rate-limit（v7.x）の導入と詳細設定
   ```javascript
   // 認証エンドポイント
   POST /api/auth/login: 5回/15分（IPベース） + 10回/時間（ユーザーベース）
   POST /api/auth/signup: 3回/時間（IPベース）

   // デバイス制御
   POST /api/devices/:id/command: 100回/分（デバイス別） + 500回/分（ユーザー別）

   // 招待機能
   POST /api/devices/:id/invite: 10回/日（デバイス別）
   ```
2. Redisを使った分散レート制限
   - ECS Fargateの複数タスク間でレート制限を共有
   - `rate_limit:{endpoint}:{user_id}` キーでカウンタを管理
3. レート制限超過時のレスポンス
   ```json
   {
     "error": {
       "code": "RATE_LIMIT_EXCEEDED",
       "message": "リクエスト制限を超過しました",
       "retry_after": 900
     }
   }
   ```

---

### 2-2. JWTトークンの保存方式が未記載

**提案**: アクセストークンとリフレッシュトークンの保存場所（localStorageかCookieか）が設計書に記載されていない。React Nativeアプリの場合、保存方式によってXSS/CSRF攻撃の対策が変わる。

**理由**:
- localStorageに保存すると、XSS攻撃でトークンを窃取可能
- AsyncStorageはセキュアストレージではなく、ルート化されたデバイスで読み取り可能

**推奨対策**:
1. React Nativeアプリの場合
   - `react-native-keychain`（iOS Keychain / Android Keystore）を使用
   - アクセストークンはメモリ上にのみ保持（アプリ再起動時にリフレッシュトークンで再取得）
   - リフレッシュトークンのみKeychainに保存
2. ブラウザ版（将来拡張の場合）
   - HttpOnly + Secure + SameSite=Strict属性のCookieに保存
   - CSRFトークンをカスタムヘッダー（X-CSRF-Token）で送信

---

### 2-3. センサーデータのアクセス制御とデータ保持期間が未設計

**提案**: InfluxDBに蓄積されるセンサーデータのアクセス制御、データ保持期間、削除ポリシーが未設計。長期間のデータ蓄積はプライバシーリスクとストレージコストを増大させる。

**理由**:
- 温度センサーデータから居住パターンを推測可能（プライバシー侵害）
- InfluxDBのデータ量が無制限に増加し、パフォーマンス劣化

**推奨対策**:
1. データ保持ポリシーの設計
   - リアルタイムデータ（1分粒度）: 7日間保持
   - 集計データ（1時間粒度）: 90日間保持
   - 月次サマリ: 2年間保持
2. InfluxDBのRetention Policy設定
   ```sql
   CREATE RETENTION POLICY "realtime" ON "iot_telemetry" DURATION 7d REPLICATION 1 DEFAULT
   CREATE RETENTION POLICY "hourly" ON "iot_telemetry" DURATION 90d REPLICATION 1
   ```
3. ダウンサンプリング自動化
   - Continuous Queryで1分データを1時間平均に集計
4. ユーザーによるデータ削除機能
   - `DELETE /api/devices/:id/telemetry` エンドポイントを追加（GDPR対応）

---

### 2-4. デバイスファームウェア更新の強制フラグとロールバック設計が不明

**提案**: OTA更新が任意更新か強制更新かの設計が欠落。重大な脆弱性修正の場合、強制更新が必要だが、更新失敗時のロールバック方式も未設計。

**理由**:
- セキュリティパッチを適用しないデバイスが攻撃の踏み台に
- OTA更新中のネットワーク切断でデバイスがブリック化（起動不能）

**推奨対策**:
1. `ota_updates` テーブルに `is_mandatory` フラグを追加
   - 強制更新の場合、デバイスが更新を拒否できない
   - デバイスがMQTT接続時に強制更新通知を受信
2. A/Bパーティション方式の採用
   - デバイスに2つのファームウェアパーティションを用意
   - 更新時、非アクティブパーティションに新ファームウェアを書き込み
   - 起動後、動作検証が成功したらアクティブパーティションを切り替え
   - 失敗時は自動的に旧パーティションから起動
3. デバイス側の更新前チェック
   - バッテリー残量（30%以上）、ストレージ空き容量の確認
   - 更新前にデバイスログをサーバーに送信（トラブルシューティング用）

---

### 2-5. PostgreSQLインジェクション対策の明示が欠落

**提案**: データ検証に `joi` を使用すると記載されているが、SQLインジェクション対策（パラメータ化クエリの使用）が明示されていない。

**理由**:
- ORMを使わずに生SQLを書く場合、開発者がパラメータ化を忘れる可能性
- デバイスIDやユーザーIDをクエリに埋め込む際の脆弱性

**推奨対策**:
1. PostgreSQL接続ライブラリの明示
   - `pg`（Node.js PostgreSQLクライアント）v8.x以上を使用
   - 全てのクエリでパラメータ化クエリを強制
   ```javascript
   // ❌ 危険
   const query = `SELECT * FROM devices WHERE id = '${deviceId}'`;

   // ✅ 安全
   const query = 'SELECT * FROM devices WHERE id = $1';
   const result = await client.query(query, [deviceId]);
   ```
2. コードレビューとlint設定
   - ESLintルール `no-template-curly-in-string` を有効化
   - プルリクエストテンプレートに「SQLインジェクション対策チェックリスト」を追加
3. 入力検証の強化
   - UUIDフォーマットの厳格な検証（`joi.string().uuid()`）
   - `device_access.permission` のホワイトリスト検証（`joi.string().valid('owner', 'write', 'read')`）

---

### 2-6. セッション無効化とログアウト機能の設計が欠落

**提案**: 設計書にログアウトエンドポイントが存在しない。リフレッシュトークンをRedisに保存しているが、ログアウト時の無効化方法が未設計。

**理由**:
- ユーザーがログアウトしてもトークンが有効なままだと、トークン窃取時のリスクが持続
- 「全デバイスからログアウト」機能が実装できない

**推奨対策**:
1. ログアウトエンドポイントの追加
   ```
   POST /api/auth/logout - 現在のセッションを無効化
   POST /api/auth/logout-all - 全デバイスのセッションを無効化
   ```
2. Redisでのトークン管理
   ```javascript
   // ログアウト時
   await redis.del(`refresh_token:${tokenId}`);

   // 全ログアウト時
   const keys = await redis.keys(`refresh_token:${userId}:*`);
   await redis.del(...keys);
   ```
3. アクセストークンのブラックリスト（オプション）
   - アクセストークンは短命（15分）なので通常はブラックリスト不要
   - セキュリティインシデント時のみ、Redisに `blacklist:{jti}` を追加

---

### 2-7. MQTT Brokerの認証・認可設計の詳細が不足

**提案**: MQTT Brokerとして何を使用するか（Mosquitto/EMQX等）が未記載。また、MQTTのトピック別アクセス制御（ACL）が設計されていない。

**理由**:
- デバイスが他のデバイスのトピックにパブリッシュ/サブスクライブ可能だと、クロスデバイス攻撃が発生
- 例: デバイスAが `devices/device-B/commands` にコマンドを送信し、デバイスBを乗っ取り

**推奨対策**:
1. MQTT BrokerとしてEMQX（オープンソース）を採用
   - PostgreSQL統合でACL管理が容易
   - WebSocketサポート（将来のブラウザ版対応）
2. トピック命名規則とACL設計
   ```
   devices/{device_id}/commands - サーバーからデバイスへのコマンド送信（デバイスはサブスクライブのみ）
   devices/{device_id}/telemetry - デバイスからサーバーへのテレメトリ送信（デバイスはパブリッシュのみ）
   devices/{device_id}/status - デバイスステータス（双方向）
   ```
3. EMQX ACLルール（PostgreSQL連携）
   ```sql
   -- devices テーブルにMQTT ACLを追加
   SELECT allow FROM device_acl
   WHERE device_id = $1
     AND topic = $2
     AND action = $3  -- 'publish' or 'subscribe'
   ```

---

### 2-8. 依存ライブラリの脆弱性管理プロセスが未設計

**提案**: 使用するライブラリのバージョンは記載されているが、脆弱性スキャンと更新プロセスが未設計。

**理由**:
- `jsonwebtoken` v9.0, `joi` v17.x等のライブラリに脆弱性が発見された場合の対応手順が不明
- npm auditの結果を無視すると、既知の脆弱性を抱えたまま本番運用

**推奨対策**:
1. 依存関係スキャンの自動化
   - GitHub Dependabotを有効化（自動PR作成）
   - CI/CDパイプラインに `npm audit --audit-level=high` を組み込み
   - Snyk等の商用ツール導入を検討
2. 更新ポリシー
   - CVSS 7.0以上の脆弱性は7日以内に対応
   - CVSS 4.0-6.9は30日以内に対応
   - メジャーバージョンアップグレードは四半期ごとに評価
3. 依存ライブラリの最小化
   - `crypto` モジュールはNode.js組み込みを使用（適切）
   - 不要なライブラリ（例: `lodash`全体をインポート）を避け、必要な関数のみインポート

---

## 3. 確認事項（ユーザーへの確認が必要）

### 3-1. デバイス共有シナリオにおけるプライバシー設定

**確認理由**: 家族間でデバイス共有する際、監視カメラの映像やセンサーデータを特定メンバーのみに制限する機能が必要か不明。

**選択肢とトレードオフ**:
- **オプションA: 全共有メンバーが全データにアクセス可能**
  - 実装が簡素（現在の `device_access.permission` で対応可能）
  - プライバシー懸念（子供部屋のカメラを全員が閲覧可能）
- **オプションB: データ種別ごとのアクセス制御**
  - 細粒度の権限設定（例: 温度データは閲覧可、カメラ映像は閲覧不可）
  - 実装複雑化（`device_access` テーブルに `allowed_data_types` カラム追加）

---

### 3-2. デバイスのオフライン時のコマンド処理方針

**確認理由**: デバイスがオフライン時にユーザーが制御コマンドを送信した場合の動作が未定義。

**選択肢とトレードオフ**:
- **オプションA: コマンドをキューイングし、デバイス復帰時に実行**
  - ユーザー体験向上（後で実行される保証）
  - 古いコマンドの実行リスク（例: 12時間前の「照明ON」が深夜に実行）
- **オプションB: 即座にエラー返却**
  - 安全性確保（予期しない動作を防止）
  - ユーザー体験低下（再操作が必要）
- **推奨**: オプションAを採用し、コマンドに有効期限（5分）を設定

---

### 3-3. GDPRおよびプライバシー規制への対応範囲

**確認理由**: EU圏のユーザーを対象とする場合、GDPRの「データポータビリティ」「削除の権利」への対応が必要。

**確認事項**:
- データエクスポート機能（`GET /api/users/me/data-export`）の実装が必要か
- アカウント削除時のデバイスデータ削除ポリシー（完全削除 or 匿名化）
- Cookie同意バナー、プライバシーポリシーページの実装範囲

---

## 4. 評価（良い点）

### 4-1. TLS通信の全面採用

HTTPS（API）とMQTT over TLS（デバイス通信）により、通信経路の暗号化が適切に設計されている。TLS 1.2以上の指定も適切。

---

### 4-2. JWTアクセストークンの短い有効期限

アクセストークンの有効期限を15分に設定し、リフレッシュトークンと分離している点は、トークン窃取時の被害を限定する上で優れた設計。

---

### 4-3. bcryptによるパスワードハッシュ化

bcryptのコストファクタ10は現在の標準的な設定であり、レインボーテーブル攻撃への耐性を確保している。

---

### 4-4. UUIDの採用

デバイスIDとユーザーIDにUUIDを使用することで、IDの推測攻撃（IDOR）のリスクを低減している。

---

### 4-5. ファームウェア署名検証の要件化

ファームウェア更新パッケージの署名検証を要件として明記している点は、サプライチェーン攻撃対策として適切。実装詳細の追加が必要だが、方向性は正しい。

---

### 4-6. 構造化ログとリクエストIDトレーシング

X-Request-IDヘッダーによるリクエストトレーシングと構造化ログは、セキュリティインシデント調査時の追跡を容易にする優れた設計。

---

## 補足: STRIDE脅威モデリング評価

| 脅威カテゴリ | 検出された問題 | 対策状況 |
|-------------|--------------|---------|
| Spoofing（なりすまし） | MQTT通信でのデバイスなりすまし | ❌ 未対策（device_keyのみ） |
| Tampering（改ざん） | MQTTメッセージ改ざん、SQLインジェクション | ❌ MQTT未対策、SQL対策未記載 |
| Repudiation（否認） | デバイスコマンド実行の監査ログ | ⚠️ ロギング方針あるが、コマンド監査の明記なし |
| Information Disclosure（情報漏洩） | センサーデータ、カメラ映像の暗号化 | ❌ 保存時暗号化未設計 |
| Denial of Service（サービス拒否） | APIレート制限 | ⚠️ 基本的な制限あるが、詳細設計不足 |
| Elevation of Privilege（権限昇格） | IDOR、権限チェック漏れ | ❌ 権限チェック実装が不明瞭 |
