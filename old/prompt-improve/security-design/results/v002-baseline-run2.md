# セキュリティ設計レビュー結果

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | STRIDE観点での体系的な脅威分析が設計書に含まれておらず、多数の脅威が未対処 |
| 認証・認可設計 | 1 | JWTのlocalStorage保存により重大なXSS窃取リスクがあり、即時修正が必須 |
| データ保護 | 2 | 暗号化方針・KYC書類保護・データ削除ポリシーが未設計で、規制違反リスクあり |
| 入力検証設計 | 2 | 入力検証の体系的な方針が不在で、インジェクション攻撃への対策が不明確 |
| インフラ・依存関係 | 3 | シークレット管理とサードパーティ脆弱性管理が未設計だが、基本構成は妥当 |
| **総合** | **2.0** | |

---

## 1. 重大な問題（設計の修正が必須）

### 1.1 JWTトークンの保存方式が危険（認証・認可設計）

**問題**: 設計書166行目「トークンはlocalStorageに保存（フロントエンド）」により、XSS攻撃でトークンを窃取可能

**影響**:
- XSS脆弱性が1つでもあれば、攻撃者はJavaScriptで`localStorage.getItem('token')`を実行し、15分有効なアクセストークンと7日有効なリフレッシュトークンを窃取可能
- 窃取されたリフレッシュトークンで7日間ユーザーアカウントを乗っ取り、決済・送金を不正実行できる
- 金融アプリケーションとしては致命的（PCI DSS 6.5.7違反の可能性）

**推奨対策**:
1. トークンをHttpOnly + Secure + SameSite=Strict属性のCookieに変更
2. アクセストークンの有効期限を15分維持、リフレッシュトークンにローテーション機能を追加（使用後に新トークン発行し、旧トークンを無効化）
3. React NativeアプリではSecure Storageライブラリ（react-native-keychain等）でOS管理の暗号化ストレージに保存

**該当箇所**: セクション5 API設計 - 認証・認可方式

---

### 1.2 KYC書類とPII（個人識別情報）の保護方針が未設計（データ保護）

**問題**: KYC書類メタデータをMongoDBに保存（33行目）とあるが、実際の本人確認書類（身分証画像等）の保存場所、暗号化方式、アクセス制御が未設計

**影響**:
- 身分証画像が暗号化されずに保存されれば、データベース侵害時に個人情報が漏洩
- GDPR/個人情報保護法の違反リスク（本人確認書類は要配慮個人情報）
- MongoDB監査ログにPII（email, phone_number等）が平文で記録される場合、監査ログ自体が攻撃対象になる

**推奨対策**:
1. KYC書類画像はAWS S3に保存し、サーバーサイド暗号化（SSE-KMS）を有効化
2. S3バケットポリシーでアクセスを制限（KYCService専用IAMロールのみ許可）
3. 画像ダウンロードURLは署名付きURL（有効期限5分）を発行
4. MongoDBの監査ログには、PIIを含めずユーザーIDのみ記録（email等はマスキング）
5. 暗号化対象カラムをテーブル定義に明記（users.email, users.phone_number, payment_methods.last_fourは検討対象）

**該当箇所**: セクション2 技術スタック - データベース、セクション4 データモデル

---

### 1.3 決済・送金APIの金額改ざん防止策が不明（脅威モデリング - Tampering）

**問題**: APIリクエストボディで送信される決済金額（amount）に対する改ざん防止策が設計に記載されていない

**影響**:
- クライアント側で決済金額を改ざんし、1円決済等の不正が可能になる可能性
- 中間者攻撃（MITM）でリクエストボディを書き換えられる場合、TLSだけでは防げない（アプリ内のロジック改変）
- 特にQRコード決済では、QRコードに含まれる金額とリクエストボディの金額の整合性チェックが重要

**推奨対策**:
1. QRコード決済の場合、QRコード文字列に`merchant_id|amount|nonce|timestamp|signature`を含め、サーバー側で署名検証
2. 署名はHMAC-SHA256（秘密鍵はmerchantsテーブルのmerchant_secretカラムに保存、暗号化）
3. P2P送金では、金額確認画面でユーザーに再確認を促すUXフローを設計に明記
4. サーバー側で異常な金額（0円、負の値、通常の100倍以上）を検出し、トランザクションを保留してアラート発報

**該当箇所**: セクション3 アーキテクチャ設計 - MerchantService、セクション5 API設計 - 決済エンドポイント

---

### 1.4 SQLインジェクション対策の明示が不足（入力検証設計）

**問題**: JPA Repositoryを使用（55行目）と記載があるが、Native Queryを使用する場合の対策や、動的クエリ組み立て時のパラメータバインディング方針が未設計

**影響**:
- Native Query使用時に文字列連結でクエリを組み立てれば、SQLインジェクション脆弱性が発生
- 取引履歴検索等で複雑な条件を扱う場合、動的クエリが必要になる可能性が高い
- 成功すれば全ユーザーのPII、決済情報、トークン等が漏洩

**推奨対策**:
1. Native Queryを使用する場合は必ず名前付きパラメータまたは位置パラメータでバインディング（例: `@Query("SELECT * FROM users WHERE email = :email")`）
2. Criteria APIまたはQueryDSLを使用した動的クエリ生成を標準とする方針を設計に明記
3. コードレビューチェックリストにSQLインジェクション対策を追加（String連結の禁止）
4. 入力値の検証ルールをAPI仕様書に追加（例: email形式、phone_number形式、amount範囲チェック）

**該当箇所**: セクション3 アーキテクチャ設計 - Data Access Layer、セクション6 実装方針

---

### 1.5 認可チェックの設計が不十分（認証・認可設計 - Elevation of Privilege）

**問題**: 「加盟店APIは加盟店オーナーのみアクセス可能（ユーザー属性で判定）」（167行目）とあるが、具体的な認可チェック実装方針が未設計

**影響**:
- 認可チェックの漏れにより、一般ユーザーが他のユーザーの取引履歴を閲覧できる脆弱性（IDOR: Insecure Direct Object Reference）
- 一般ユーザーが加盟店APIを呼び出し、不正にQRコードを生成できる
- P2P送金で他人の口座から送金を実行できる可能性

**推奨対策**:
1. Spring Securityの`@PreAuthorize`アノテーションで、エンドポイントごとに認可ルールを設計書に明記
   - 例: `@PreAuthorize("hasRole('MERCHANT') and #merchantId == authentication.principal.merchantId")`
2. リソースベースのアクセス制御（RBAC）を導入し、ユーザーが自分のリソースのみアクセス可能にする
   - 例: `GET /api/v1/payments/{id}` → idで指定されたトランザクションのuser_idが、リクエスト元ユーザーのIDと一致するか検証
3. 管理者API（`/api/admin/*`）を別エンドポイントに分離し、管理者ロール（ADMIN）必須とする
4. 認可チェック失敗時のログを監査ログに記録（不正アクセス試行の検出）

**該当箇所**: セクション5 API設計 - 認証・認可方式、セクション3 アーキテクチャ設計

---

## 2. 改善提案（設計の品質向上に有効）

### 2.1 レート制限の具体的設計が不足（DoS対策）

**提案**: 「APIには適切なレート制限を設定する」（207行目）とあるが、具体的なエンドポイント別の制限値と実装方式が未設計

**理由**:
- レート制限がなければ、攻撃者は決済APIを連続実行し、サービス妨害や外部API（Stripe/Plaid）の利用料金を不正に増大させることが可能
- ログインエンドポイントはブルートフォース攻撃の標的になりやすい

**推奨対策**:
1. Spring Boot Rate Limiter（Bucket4jライブラリ）をRedisバックエンドで実装
2. エンドポイント別のレート制限値を設計書に明記:
   - `POST /api/v1/auth/login`: 5回/15分（IPアドレスベース + ユーザーIDベース）
   - `POST /api/v1/payments`, `POST /api/v1/transfers`: 10回/分（ユーザーIDベース）
   - 一般API: 100回/分（ユーザーIDベース）
3. 制限超過時は429 Too Many Requestsを返し、Retry-Afterヘッダーで待機時間を通知
4. 連続ログイン失敗（5回）でアカウントを30分間ロック

**該当箇所**: セクション7 非機能要件 - セキュリティ要件

---

### 2.2 監査ログの改ざん検知機能が未設計（脅威モデリング - Repudiation）

**提案**: MongoDBに監査ログを書き込む（72行目）とあるが、ログ自体の改ざんを検知する仕組みが未設計

**理由**:
- 管理者権限が侵害された場合、攻撃者は監査ログを削除・改ざんして痕跡を隠蔽できる
- 金融アプリケーションでは、否認防止（Non-Repudiation）の証明として、改ざん不可能なログが必要

**推奨対策**:
1. 監査ログに書き込み専用（Append-Only）制約を設定（MongoDBのCapped Collectionまたはロールベースアクセス制御で削除・更新を禁止）
2. ログエントリにHMAC署名を付与し、改ざんを検出可能にする（署名鍵はAWS Secrets Managerで管理）
3. CloudWatch Logs等の外部ログサービスにも同時書き込みし、冗長化
4. 週次でログの整合性検証ジョブを実行（署名検証 + レコード数チェック）

**該当箇所**: セクション3 アーキテクチャ設計 - データフロー、セクション6 実装方針 - ロギング

---

### 2.3 外部API（Stripe/Plaid）のシークレット管理が未設計（インフラ・依存関係）

**提案**: Stripe API/Plaid APIの認証情報（APIキー、シークレット）の管理方法が設計書に記載されていない

**理由**:
- APIキーをアプリケーションコードや環境変数にハードコードすれば、コードリポジトリ侵害時に漏洩
- 漏洩したAPIキーで不正決済が実行され、金銭的損失が発生

**推奨対策**:
1. AWS Secrets Managerで外部APIキーを管理し、アプリケーション起動時に動的に取得
2. IAMロール（ECS Task Role）を使用し、Secrets Managerへのアクセス権限を最小化
3. 本番環境とステージング環境で別のAPIキーを使用（環境分離）
4. APIキーのローテーション方針を策定（3ヶ月ごと）し、旧キーの無効化手順をドキュメント化

**該当箇所**: セクション2 技術スタック - 主要ライブラリ、セクション3 アーキテクチャ設計 - External Integration Layer

---

### 2.4 P2P送金の二重実行防止策が未設計（脅威モデリング - Tampering）

**提案**: P2P送金APIでリクエストの重複送信（Idempotency）への対策が設計されていない

**理由**:
- ネットワークタイムアウト時にユーザーがリトライボタンを連続押下し、同一送金が2重に実行される可能性
- 金融取引では冪等性（Idempotency）の保証が必須

**推奨対策**:
1. クライアントが生成した`Idempotency-Key`ヘッダー（UUID v4）をリクエストに含める仕様を追加
2. サーバー側でRedisに`idempotency:{key}`をキーとしてトランザクション結果を24時間キャッシュ
3. 同一キーでの再リクエストはキャッシュから結果を返し、重複実行を防止
4. トランザクション実行前にキーの存在チェック、実行後に結果をキャッシュに保存（アトミックな処理）

**該当箇所**: セクション5 API設計 - 送金エンドポイント、セクション3 アーキテクチャ設計 - TransferService

---

### 2.5 依存ライブラリの脆弱性管理が未設計（インフラ・依存関係）

**提案**: サードパーティライブラリ（Spring Boot、Stripe SDK等）の脆弱性管理方針が設計に含まれていない

**理由**:
- 既知の脆弱性（CVE）が存在するライブラリを使用すれば、攻撃者に悪用される
- Spring Bootやその依存ライブラリは頻繁に脆弱性が報告される

**推奨対策**:
1. CI/CDパイプラインにOWASP Dependency-Check（GitHub Actions）を組み込み、ビルド時に脆弱性スキャン
2. Snyk等のSaaS型脆弱性管理ツールを導入し、自動PR生成でアップデート通知
3. 週次で依存ライブラリのバージョンチェック、Critical/High脆弱性は48時間以内にパッチ適用
4. ライブラリのバージョン管理方針を設計書に追加（例: Spring Boot最新マイナーバージョンを1ヶ月以内に適用）

**該当箇所**: セクション2 技術スタック - 主要ライブラリ、セクション6 実装方針 - デプロイメント方針

---

### 2.6 QRコードの署名検証と有効期限が未設計（脅威モデリング - Spoofing）

**提案**: QRコード（qr_code_data, 120行目）の生成方式と検証ロジックが未設計

**理由**:
- QRコードが単なるmerchant_idであれば、攻撃者は他店舗のIDを推測してQRコードを偽造可能
- 偽造QRコードで決済を受け取り、金銭を詐取できる

**推奨対策**:
1. QRコード文字列を`merchant_id|timestamp|nonce|signature`形式とし、HMAC-SHA256で署名
2. QRコード読み取り時にサーバー側で署名検証、タイムスタンプの有効期限チェック（発行から24時間以内）
3. 決済実行前にユーザーに店舗名を表示し、確認を求める（フィッシング対策）
4. QRコード署名用の秘密鍵はmerchantごとに異なる値を生成し、merchantsテーブルに暗号化して保存

**該当箇所**: セクション4 データモデル - merchants、セクション3 アーキテクチャ設計 - MerchantService

---

### 2.7 パスワードリセット機能の設計が不在（認証・認可設計）

**提案**: ユーザー登録・ログイン機能（130-132行目）はあるが、パスワードリセットの設計が記載されていない

**理由**:
- パスワード忘れユーザーがアカウントに再アクセスできなくなる
- 安全でないパスワードリセット実装（メールでパスワード平文送信等）は情報漏洩リスク

**推奨対策**:
1. `POST /api/v1/auth/password-reset-request`エンドポイントで、登録済みemailにリセットトークン（UUID、有効期限1時間）を送信
2. リセットトークンをRedisに保存（TTL 1時間）、メールのリンクに`https://app.example.com/reset?token={token}`を含める
3. `POST /api/v1/auth/password-reset`で新パスワードとトークンを受け取り、検証後にパスワードを更新
4. リセット完了時に既存のJWTトークンをすべて無効化（セッション管理）

**該当箇所**: セクション5 API設計 - 認証エンドポイント

---

### 2.8 HTTPS通信のクライアント証明書検証が未設計（脅威モデリング - Spoofing）

**提案**: 「通信はすべてHTTPS（TLS 1.3）」（205行目）とあるが、クライアント側での証明書ピンニング（Certificate Pinning）の検討が未設計

**理由**:
- 中間者攻撃（MITM）で偽の証明書を提示されても、デフォルトのTLS検証では検出できない場合がある（企業プロキシ、公衆Wi-Fi）
- モバイルアプリでは証明書ピンニングが推奨されるセキュリティベストプラクティス

**推奨対策**:
1. React Nativeアプリに証明書ピンニングライブラリ（react-native-ssl-pinning）を導入
2. サーバー証明書の公開鍵ハッシュ（SPKI）をアプリにハードコード
3. 証明書更新時の移行期間（古い証明書と新しい証明書の両方をピン）を設計に含める
4. 管理画面（Next.js）でもContent Security Policy（CSP）ヘッダーでHTTPSのみ許可

**該当箇所**: セクション7 非機能要件 - セキュリティ要件

---

### 2.9 ログに含まれる機密情報のマスキングが未設計（データ保護）

**提案**: 「全APIリクエスト/レスポンスをINFOレベルで記録」（180行目）とあるが、機密情報（パスワード、トークン、カード番号）のマスキングルールが未設計

**理由**:
- ログにパスワードやトークンが平文で記録されれば、ログ閲覧権限を持つ内部者が悪用可能
- ログ管理システム（CloudWatch Logs等）の侵害時に機密情報が漏洩

**推奨対策**:
1. Logbackのカスタムフィルターで、特定フィールド（password, token, cardNumber等）を`***MASKED***`に置換
2. ログ記録前に正規表現でクレジットカード番号パターン（16桁）を検出し、自動マスキング
3. 決済処理ログでは、amount, merchant_idは記録するが、provider_token（Stripe/Plaidトークン）は記録しない
4. ログマスキングのテストケースを追加（単体テスト）

**該当箇所**: セクション6 実装方針 - ロギング

---

### 2.10 データ削除ポリシー（GDPR対応）が未設計（データ保護）

**提案**: ユーザーが退会した場合のデータ削除方針が設計に含まれていない

**理由**:
- GDPR/個人情報保護法では、ユーザーの削除要求（Right to Erasure）に対応する義務がある
- 金融取引データは法的保存義務があるため、単純な削除は不可

**推奨対策**:
1. `DELETE /api/v1/users/me`エンドポイントで退会処理を実装
2. 法的保存義務のあるデータ（transactions, 監査ログ）は7年間保持し、user_idは保持するがPII（email, phone_number）は仮名化（`deleted_user_{id}`に置換）
3. KYC書類（S3）と決済手段（payment_methods）は即時削除
4. 退会処理はバッチジョブで非同期実行し、完了通知をメールで送信

**該当箇所**: セクション5 API設計、セクション4 データモデル

---

## 3. 確認事項（ユーザーへの確認が必要）

### 3.1 KYC（本人確認）の実装方式

**確認理由**: KYCの実装方式が設計に不明確で、セキュリティとコストのトレードオフが発生

**選択肢**:
1. **自社実装**: ユーザーが身分証画像をアップロード、管理者が手動で承認
   - メリット: 初期コスト低、カスタマイズ容易
   - デメリット: 人的コスト高、誤判定リスク、規制対応の負担
2. **外部KYCサービス（Onfido, Jumio等）**: APIで身分証OCRと顔認証を自動化
   - メリット: 高精度、規制準拠、スピード承認
   - デメリット: API利用料（1件あたり数ドル）、外部依存

**推奨**: 外部KYCサービス導入を推奨（規制対応とスケーラビリティの観点）

---

### 3.2 不正検出（Fraud Detection）の実装レベル

**確認理由**: FraudDetectionServiceの実装レベル（64行目）が「外部サービス連携も検討」と曖昧

**選択肢**:
1. **ルールベース（自社実装）**: 単純なしきい値チェック（1日の送金上限、異常な金額）
   - メリット: 実装容易、コスト低
   - デメリット: 検出精度低、誤検知多い、巧妙な不正を見逃す
2. **機械学習ベース（外部サービス: Stripe Radar, Sift等）**: 行動パターン分析で異常検出
   - メリット: 高精度、誤検知少ない、アダプティブ
   - デメリット: API利用料、初期学習期間必要

**推奨**: フェーズ1はルールベース、フェーズ2で外部サービス導入（段階的な実装）

---

### 3.3 Multi-Factor Authentication（MFA）の導入範囲

**確認理由**: 高額送金や設定変更時のMFAが設計に含まれていない

**選択肢**:
1. **MFA不要**: 現状設計のまま（JWT認証のみ）
   - メリット: UX簡潔、実装容易
   - デメリット: トークン窃取時の被害拡大
2. **オプションMFA**: ユーザーが有効化可能（TOTP: Google Authenticator等）
   - メリット: セキュリティ向上、UXへの影響小
   - デメリット: 実装コスト中程度
3. **必須MFA**: 一定額以上の送金時は強制（例: 10万円以上）
   - メリット: 高額不正の防止
   - デメリット: UX低下、ユーザー反発の可能性

**推奨**: オプションMFAの導入（セキュリティ意識の高いユーザー向け）

---

## 4. 評価（良い点）

### 4.1 クレジットカード情報のトークン化

「PCI DSS準拠（クレジットカード情報は自システムに保存せず、Stripeトークン化）」（204行目）により、カード番号を自システムで保持しないアーキテクチャは適切。PCI DSS SAQ Aレベルで済み、監査コストとセキュリティリスクを大幅に削減できる。

### 4.2 パスワードのハッシュ化方式

「パスワードはbcryptでハッシュ化（ストレッチング係数12）」（206行目）は、現代的な推奨方式に準拠。bcryptはレインボーテーブル攻撃に耐性があり、係数12は計算コストとセキュリティのバランスが良い。

### 4.3 データベースのMulti-AZ構成

「データベース: Multi-AZ構成（フェイルオーバー自動）」（212行目）により、可用性と耐障害性を確保。DDoS攻撃やインフラ障害時もサービス継続可能。

### 4.4 TLS 1.3の採用

「通信はすべてHTTPS（TLS 1.3）」（205行目）により、最新の暗号化プロトコルを採用。TLS 1.2以下の既知脆弱性（POODLE, BEAST等）を回避でき、前方秘匿性（Forward Secrecy）も確保。

### 4.5 JWTトークンの有効期限設定

「Access Token: 15分, Refresh Token: 7日」（164行目）の有効期限設定は、セキュリティとUXのバランスが良い（ただし、localStorage保存の問題は1.1で指摘）。短いアクセストークンで窃取リスクを低減し、リフレッシュトークンで再認証の頻度を抑制。

---

## 総評

デジタルウォレット決済システムとして、基本的なアーキテクチャ構成（3層アーキテクチャ、外部API連携、Multi-AZ）は妥当であり、PCI DSS準拠のためのトークン化やbcryptハッシュ化等のベストプラクティスも採用されています。

しかし、**アーキテクチャレベルでのセキュリティ設計に重大な欠陥**が複数存在します。特に、JWTのlocalStorage保存（1.1）、KYC書類保護の未設計（1.2）、認可チェックの不十分さ（1.5）は、金融アプリケーションとして致命的であり、即時の設計修正が必須です。

また、脅威モデリング（STRIDE）の体系的な分析が設計書に含まれておらず、Tampering（改ざん）、Repudiation（否認）、Spoofing（なりすまし）への対策が断片的です。設計フェーズで脅威分析ワークショップを実施し、各脅威への対策を設計書に明記することを強く推奨します。

データ保護の観点では、GDPR/個人情報保護法への対応（データ削除ポリシー、暗号化方針、監査ログのPIIマスキング）が未設計であり、規制違反リスクがあります。金融サービスとして法的要件を満たす設計への改修が必要です。

インフラ・依存関係では、外部APIシークレット管理と脆弱性管理の方針が不在です。これらは運用フェーズで重大なインシデントにつながる可能性があり、設計段階での方針策定が必要です。

総合スコア2.0は「重要な問題が複数存在し、本番環境で攻撃を受ける可能性が高い」状態を示しています。重大な問題（セクション1）を最優先で修正し、改善提案（セクション2）を段階的に実装することで、セキュリティレベルを大幅に向上できます。
