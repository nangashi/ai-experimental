# セキュリティレビュー結果: SmartHome IoTデバイス管理プラットフォーム

**レビュー日時**: 2026-02-10
**レビュー対象**: test-document-round-003.md
**プロンプトバリアント**: v003-variant-decomposition (M1a)

---

## Step 1: 全体構造の把握

### システムの主要コンポーネントとその責務
1. **API Server (ECS Fargate)**: REST APIを提供し、ユーザー認証・デバイス管理・データ取得を担当
2. **MQTT Broker (ECS Fargate)**: IoTデバイスとの双方向通信（コマンド送信・テレメトリ受信）
3. **Device Gateway Service**: デバイス認証、コマンド検証、データ正規化を実行
4. **OTA Update Service**: ファームウェア配信管理
5. **ALB**: HTTPSトラフィックのロードバランシング
6. **PostgreSQL**: ユーザー・デバイス登録情報の永続化
7. **Redis**: セッション管理、リアルタイムステータスキャッシュ
8. **InfluxDB**: 時系列センサーデータの蓄積
9. **S3**: ファームウェアイメージの保存

### データフロー
1. **制御フロー**: Mobile App → (HTTPS) → ALB → API Server → Redis → MQTT Broker → IoT Device
2. **テレメトリフロー**: IoT Device → (MQTT/TLS) → MQTT Broker → Device Gateway Service → InfluxDB
3. **リアルタイム通知**: Device Gateway Service → Socket.IO → Mobile App

### 認証・認可のフロー
- **ユーザー認証**: JWT（アクセストークン15分、リフレッシュトークン7日・Redis保存）
- **デバイス認証**: 一意の`device_key`をMQTT接続時のクライアントIDとして使用
- **APIアクセス制御**: JWTトークン（ユーザーAPI）、`device_key`（デバイスAPI）、権限レベル（owner/write/read）

### 外部システムとの統合ポイント
- **デバイスメーカーAPI**: `POST /api/devices`でデバイス登録
- **IoTデバイス**: MQTT/TLS経由で接続
- **モバイルアプリ**: HTTPS REST API + Socket.IO

### インフラ構成
- **AWS ECS Fargate**: API Server, MQTT Broker, Device Gateway Service, OTA Update Service
- **AWS ALB**: HTTPSロードバランサ
- **AWS S3**: ファームウェアイメージストレージ
- **データベース**: PostgreSQL, Redis, InfluxDB（デプロイ先は明記なし）

---

## Step 2: セキュリティ問題の検出

### 重大な問題（設計の修正が必須）

#### 1. JWTトークンの保存場所が未定義（XSS攻撃リスク）
- **問題**: 設計書にJWTトークン（アクセストークン・リフレッシュトークン）をモバイルアプリおよびWebクライアントでどこに保存するかが明示されていない。React NativeではlocalStorageやAsyncStorageへの保存がデフォルトで使用されやすく、これらはXSS攻撃で窃取可能
- **影響**: XSS脆弱性が1つでもあれば、攻撃者は7日間有効なリフレッシュトークンを取得し、継続的なアクセス権を獲得。特にIoTプラットフォームでは家のドアロックやカメラへのアクセス権が盗まれると物理的な被害につながる
- **推奨対策**:
  - React Nativeの場合: `react-native-keychain` (v8.x) を使用してOS管理のキーチェーン（iOS Keychain / Android Keystore）に保存
  - Webクライアントの場合: HttpOnly + Secure + SameSite=Strict属性のCookieに変更（BFF経由で発行）
  - リフレッシュトークンにローテーション機構を追加（使用後に無効化し新トークン発行）
- **該当箇所**: セクション5「API設計 > 認証・認可方式 > ユーザー認証」

#### 2. デバイス認証キー（device_key）の発行・配布プロセスが未設計
- **問題**: `device_key`がどのように生成され、デバイスに安全に配布されるかが設計されていない。製造時の書き込み、ユーザー登録時のQRコード読み取り、初回接続時のプロビジョニングなど複数の方式が考えられるが、方式が不明瞭
- **影響**:
  - 予測可能なキー生成（例: デバイスIDの単純ハッシュ）の場合、攻撃者が未登録デバイスのキーを推測し、不正なデバイスを登録可能
  - キーの平文通信や不適切な保存により、中間者攻撃やキー漏洩のリスク
- **推奨対策**:
  - 製造時にハードウェアセキュアエレメント（SE）またはTPMに128ビット以上のランダムキーを書き込み
  - 初回ユーザー登録時にQRコード + 短時間（5分）有効なワンタイムトークンでデバイスとユーザーを紐付け
  - `device_key`をデバイス側で暗号化保存（SEまたはフラッシュ暗号化）
  - キーのローテーション機構（年1回または侵害検知時）
- **該当箇所**: セクション5「API設計 > 認証・認可方式 > デバイス認証」、セクション4「データモデル > devices テーブル」

#### 3. MQTT Brokerの認証・認可メカニズムが不明確
- **問題**: 設計書では「MQTT接続時にdevice_keyをクライアントIDとして使用」とあるが、MQTT BrokerがクライアントIDだけで認証を行うのは危険。MQTTのクライアントIDは接続識別子であり認証情報ではない。また、Device Gateway Serviceがキー検証を行うと記載されているが、MQTT Brokerとの連携方式が不明
- **影響**:
  - 攻撃者が他のデバイスの`device_key`を知っていれば、そのデバイスになりすましてコマンドを受信・送信可能
  - トピックレベルのACLが未設計の場合、あるデバイスが他のデバイスのトピックを購読・発行可能
- **推奨対策**:
  - MQTTのusername/password認証を使用（username=device_key、password=デバイスごとの秘密鍵またはワンタイムトークン）
  - MQTT BrokerにACLプラグイン（例: Mosca/Aedes用の認証プラグイン）を実装し、各デバイスが自分専用のトピック（`devices/{device_id}/*`）のみアクセス可能にする
  - Device Gateway Serviceをプロキシとして配置し、MQTT Brokerへの接続前に認証・認可を実行
  - 接続後も定期的にトークン再検証（5分ごとの再認証）
- **該当箇所**: セクション3「アーキテクチャ設計 > 全体構成」、セクション5「API設計 > 認証・認可方式 > デバイス認証」

#### 4. OTA更新のS3 URL公開範囲と署名検証の実装詳細が未定義
- **問題**:
  - `ota_updates`テーブルに`s3_url`が平文で保存されているが、このURLの公開範囲（パブリック/署名付きURL/プライベート+認証）が不明
  - 「ファームウェア更新パッケージの署名検証」が非機能要件に記載されているが、具体的な実装方式（署名アルゴリズム、公開鍵配布方法、検証タイミング）が設計されていない
- **影響**:
  - S3 URLがパブリックまたは長期有効な署名付きURLの場合、第三者がファームウェアをダウンロードしてリバースエンジニアリング可能（ハードコードされた秘密鍵や脆弱性の発見）
  - 署名検証が未実装またはデバイス側で検証をスキップ可能な場合、攻撃者が改ざんしたファームウェアを配布し、デバイスを完全に制御可能（永続的なバックドア）
- **推奨対策**:
  - S3バケットをプライベートに設定し、デバイスがOTA APIを経由して短時間（15分）有効な署名付きURLを取得
  - ファームウェア署名にRSA-PSS 3072ビットまたはEd25519を使用
  - 公開鍵をデバイスファームウェアにハードコード（製造時）し、ブートローダーレベルで署名検証を強制
  - 署名検証失敗時はロールバック機構を動作させ、前バージョンで起動
  - OTA APIで配信前にファームウェアの脆弱性スキャン（SBOM生成 + CVE照合）
- **該当箇所**: セクション4「データモデル > ota_updates テーブル」、セクション7「非機能要件 > セキュリティ要件」

#### 5. センサーデータ（telemetry）の機密性評価と暗号化方針が未定義
- **問題**: 設計書ではカメラ映像や温度センサーデータを扱うとあるが、これらのデータの機密性レベル（個人情報・プライバシーデータかどうか）と保存時の暗号化方針が明記されていない。特にカメラ映像は高機密データであり、InfluxDBに平文保存されると重大なプライバシー侵害リスク
- **影響**:
  - データベース侵害時にユーザーの生活パターン（在宅時間、温度設定、カメラ映像）が漏洩し、空き巣などの物理的犯罪のターゲットになる
  - GDPRやCCPA等のプライバシー規制違反（データ保護義務違反）
- **推奨対策**:
  - カメラ映像はInfluxDBではなくS3に保存し、S3バケット暗号化（SSE-KMS、カスタマー管理キー）を有効化
  - 温度・照度などのセンサーデータもInfluxDBのat-rest暗号化を有効化
  - データ保持期間を定義（例: カメラ映像7日、センサーデータ90日）し、自動削除ポリシーを実装
  - ユーザーによるデータ削除リクエスト機能（GDPR Right to Erasure）
  - 映像データアクセスログの記録（誰がいつアクセスしたか）
- **該当箇所**: セクション1「概要 > 主要機能」、セクション2「技術スタック > データベース」、セクション5「API設計 > センサーデータ」

#### 6. 権限管理における権限昇格防止策が未設計
- **問題**: `device_access`テーブルで権限レベル（owner/write/read）が定義されているが、以下の権限昇格リスクへの対策が設計されていない：
  - 非ownerユーザーが自分の権限を変更する攻撃
  - 非ownerユーザーが他のユーザーを招待する攻撃
  - 権限変更APIの存在が不明（`PUT /api/devices/:id/access/:userId`など）
- **影響**:
  - 限定的なアクセス権（read）を持つ家族メンバーが、API操作で自分をownerに昇格させ、元のownerを削除可能
  - 招待されていない第三者を家族として追加し、デバイス制御権を不正に共有
- **推奨対策**:
  - 権限変更API（`PUT /api/devices/:id/access/:userId`）を実装し、以下を検証：
    - リクエストユーザーがowner権限を持つことを確認
    - ownerは1デバイスにつき1名のみとし、owner権限の譲渡は明示的なトランザクション（現owner削除 + 新owner追加）でのみ許可
  - ユーザー招待API（`POST /api/devices/:id/invite`）でもowner権限チェック
  - 権限変更の監査ログをPostgreSQLに記録（誰が誰の権限をいつ変更したか）
  - 非ownerユーザーは自分の権限を変更不可（403 Forbidden）
- **該当箇所**: セクション4「データモデル > device_access テーブル」、セクション5「API設計 > ユーザー招待・権限管理」

#### 7. Socket.IOのリアルタイム通知における認証・認可が未設計
- **問題**: データフローに「Device Gateway Service → Socket.IO → Mobile App」とあるが、Socket.IO接続時の認証方式と、どのユーザーがどのデバイスの通知を受信できるかの認可ロジックが設計されていない
- **影響**:
  - Socket.IO接続時に認証がない場合、第三者が任意のデバイスIDをリスンして他人の家のデバイス状態変更を盗聴可能
  - 認可チェックがない場合、読み取り権限のないデバイスの通知も受信可能
- **推奨対策**:
  - Socket.IO接続時にJWTトークンをクエリパラメータまたはAuth handshakeで送信し、ユーザー認証を実施
  - 接続確立後、ユーザーが購読可能なチャネル（デバイスID）をPostgreSQLの`device_access`テーブルで検証
  - Socket.IOのnamespace/roomを使用し、各デバイスを個別のroomとして分離（例: `device:{device_id}`）
  - ユーザーがアクセス権を持つデバイスのroomにのみ参加を許可
  - 権限変更時にSocket.IO接続を再検証（アクセス権削除時は強制切断）
- **該当箇所**: セクション3「アーキテクチャ設計 > データフロー」、セクション2「技術スタック > リアルタイム通信」

---

### 改善提案（設計の品質向上に有効）

#### 1. APIレート制限の設計が単純すぎる（同一IPベースのみ）
- **問題**: 非機能要件に「APIレート制限: 同一IPから1分間に100リクエストまで」とあるが、以下の問題がある：
  - NATの背後にいる大量のユーザーが同一IPでアクセスする場合、正当なユーザーがブロックされる（false positive）
  - 攻撃者が分散IPを使用すれば制限を回避可能
  - エンドポイントごとの制限がなく、重要なエンドポイント（ログイン、パスワードリセット）も一律100リクエスト/分
- **理由**: IoTプラットフォームでは特に認証エンドポイントとデバイス制御コマンドAPIが攻撃対象になりやすく、これらにエンドポイント固有の厳しい制限が必要
- **推奨対策**:
  - IPベースとユーザーIDベースの二重レート制限を実装
    - IPベース: 100リクエスト/分（全体）
    - ユーザーIDベース: 20リクエスト/分（認証済みAPI）
  - エンドポイント固有の制限：
    - `POST /api/auth/login`: 5リクエスト/5分/IP（ブルートフォース対策）
    - `POST /api/devices/:id/command`: 10リクエスト/分/ユーザー（DoS対策）
    - `POST /api/auth/signup`: 3リクエスト/時間/IP（自動登録防止）
  - express-rate-limit（v6.x）+ Redis storeを使用
  - レート制限超過時は429 Too Many Requestsとともに`Retry-After`ヘッダーを返す
- **該当箇所**: セクション7「非機能要件 > セキュリティ要件」

#### 2. パスワードリセット機能の設計が欠落
- **問題**: 認証系APIに`POST /api/auth/signup`と`POST /api/auth/login`はあるが、パスワードリセット機能（`POST /api/auth/password-reset-request`, `POST /api/auth/password-reset-confirm`）が設計されていない
- **理由**: パスワードリセット機能は以下のセキュリティリスクを持ち、適切に設計しないとアカウント乗っ取りの入口になる：
  - メールアドレス列挙攻撃（登録済みアドレスの判別）
  - リセットトークンの予測可能性
  - リセットトークンの有効期限切れ未実装
- **推奨対策**:
  - `POST /api/auth/password-reset-request`を実装：
    - メールアドレスを受け取り、登録済みかどうかに関わらず「リセットメールを送信しました」と返答（タイミング攻撃対策）
    - リセットトークンは128ビットのランダム値（`crypto.randomBytes(16).toString('hex')`）
    - トークンをRedisに保存（有効期限15分、キー: `password_reset:{token}`, 値: `user_id`）
  - `POST /api/auth/password-reset-confirm`を実装：
    - トークンと新パスワードを受け取り、Redisで検証
    - 使用後のトークンは即座に削除（ワンタイム性）
    - パスワード変更後は全てのリフレッシュトークンを無効化（Redisから削除）
  - リセットリクエストにもレート制限（5リクエスト/時間/IP）
- **該当箇所**: セクション5「API設計 > 認証系」

#### 3. デバイスコマンド検証ロジックの詳細が不明
- **問題**: Device Gateway Serviceが「コマンド検証」を行うと記載されているが、どのような検証を行うかが不明。不適切なコマンドパラメータ（例: brightness=999999）やコマンドインジェクションのリスクがある
- **理由**: IoTデバイスはリソース制約があり、異常な入力で故障・再起動する可能性。また、コマンドがシェルスクリプトとして実行される設計の場合、コマンドインジェクション攻撃のリスク
- **推奨対策**:
  - 各デバイスタイプごとに許可コマンドとパラメータスキーマを定義（Joiスキーマ）
    ```javascript
    // 例: light デバイス
    const lightCommandSchema = Joi.object({
      command: Joi.string().valid('set_brightness', 'set_color', 'toggle').required(),
      params: Joi.when('command', {
        is: 'set_brightness',
        then: Joi.object({ brightness: Joi.number().min(0).max(100).required() }),
        otherwise: Joi.object()
      })
    });
    ```
  - Device Gateway Serviceでスキーマ検証を実行し、不正なコマンドは拒否（400 Bad Request）
  - デバイス側でもパラメータ範囲チェックを実施（defense in depth）
  - コマンド実行ログをPostgreSQLに記録（誰がいつどのコマンドを実行したか）
- **該当箇所**: セクション3「アーキテクチャ設計 > 主要コンポーネント > Device Gateway Service」

#### 4. データベース接続の認証情報管理が未設計
- **問題**: PostgreSQL、Redis、InfluxDBへの接続情報（ホスト、ポート、ユーザー名、パスワード）の管理方法が設計されていない。環境変数に平文保存すると、コンテナログやプロセスリストから漏洩リスク
- **理由**: データベース認証情報の漏洩は全データへのアクセス権を意味し、最も重大な侵害シナリオの1つ
- **推奨対策**:
  - AWS Secrets Managerにデータベース認証情報を保存
  - ECS Fargateタスク定義で`secrets`フィールドを使用し、環境変数として注入
    ```json
    {
      "secrets": [
        {
          "name": "DB_PASSWORD",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:prod/db/password"
        }
      ]
    }
    ```
  - Secrets Managerの自動ローテーション機能を有効化（30日ごと）
  - アプリケーションコードではSecrets Manager SDKを使用し、起動時に認証情報を取得（環境変数からの読み取りよりも安全）
  - データベース接続にIAM認証を使用（PostgreSQL IAM認証、RedisのAuth）
- **該当箇所**: セクション2「技術スタック > データベース」、セクション3「アーキテクチャ設計」

#### 5. ロギングにおける機密情報の除外ルールが未定義
- **問題**: ロギング方針で「ユーザーID、デバイスID、APIエンドポイント」を記録するとあるが、パスワード、トークン、device_keyなどの機密情報を誤ってログに記録しないための除外ルールが設計されていない
- **理由**: ログに機密情報が記録されると、ログ閲覧権限を持つ開発者・運用担当者がユーザーアカウントを乗っ取り可能。また、ログがCloudWatch等に転送される場合、ログストレージ侵害時のリスクも増大
- **推奨対策**:
  - ログミドルウェアに機密情報マスキング機能を実装：
    - リクエストボディから`password`, `token`, `device_key`フィールドを検出し、`[REDACTED]`に置換
    - Authorizationヘッダーは最初の8文字のみ記録（例: `Bearer ey...` → `Bearer ey******`）
  - 構造化ログライブラリ（例: pino + pino-noir）を使用し、自動マスキング
    ```javascript
    const pino = require('pino');
    const noir = require('pino-noir');
    const logger = pino(noir(['req.body.password', 'req.headers.authorization']));
    ```
  - ログアクセス制限（CloudWatch Logsのアクセスポリシー）
  - ログ保持期間を30日に制限（古いログは自動削除）
- **該当箇所**: セクション6「実装方針 > ロギング方針」

#### 6. Blue/Greenデプロイメント時のデータベースマイグレーション戦略が未設計
- **問題**: デプロイメント方針で「Blue/Greenデプロイメント」とあるが、データベーススキーマ変更を伴うデプロイ時の戦略（後方互換性、マイグレーション順序）が設計されていない
- **理由**: Blue環境（旧バージョン）とGreen環境（新バージョン）が同時に動作するため、スキーマ変更が後方互換性を持たないと、Blue環境でエラーが発生
- **推奨対策**:
  - データベースマイグレーションを3段階で実施（Expand-Contract パターン）：
    1. Expand: 新カラム追加（旧バージョンは無視）
    2. Deploy: アプリケーションを新バージョンに切り替え
    3. Contract: 旧カラム削除（数日後、旧バージョンが完全に停止したことを確認後）
  - カラム名変更・削除は非推奨とし、新カラム追加 + データマイグレーション + 旧カラム削除の手順を踏む
  - マイグレーションツール（例: db-migrate, Flyway）を使用し、バージョン管理
  - ロールバック時のマイグレーション逆適用スクリプトを用意
- **該当箇所**: セクション6「実装方針 > デプロイメント方針」

#### 7. デバイスの不正検知・異常行動検出メカニズムが未設計
- **問題**: 設計書にはデバイスの正常動作を前提とした機能のみが記載され、侵害されたデバイス（マルウェア感染、改ざんされたファームウェア）の検出機構がない
- **理由**: IoTデバイスは攻撃者に物理的にアクセス可能であり、ファームウェア改ざんやルート権限取得のリスクが高い。侵害されたデバイスが他のデバイスやクラウドを攻撃する踏み台になる可能性
- **推奨対策**:
  - デバイス異常行動検出ルールを実装：
    - 短時間に大量のコマンド送信（10リクエスト/分超過）
    - 通常と異なる時間帯の接続（深夜に突然接続）
    - 不正なMQTTトピックへの発行試行
    - ファームウェアバージョンのダウングレード試行
  - Device Gateway Serviceで異常検出時にデバイスを隔離（MQTT接続切断 + API経由のコマンド拒否）
  - ユーザーにアラート通知（「デバイスXで異常な動作が検出されました。確認してください」）
  - 隔離解除はユーザーの明示的な承認または管理者の調査後のみ
  - セキュリティイベントログをSIEM（AWS Security Hub等）に転送
- **該当箇所**: セクション1「概要」、セクション3「アーキテクチャ設計」

---

### 確認事項（ユーザーへの確認が必要）

#### 1. データベース（PostgreSQL, Redis, InfluxDB）のデプロイ先とバックアップ戦略
- **確認理由**: 設計書にはデータベースの技術スタックは記載されているが、これらがどこにデプロイされるか（AWS RDS, ElastiCache, 自前EC2/ECS）、バックアップ頻度・保持期間が不明。これによりDR戦略とコストが大きく変わる
- **選択肢とトレードオフ**:
  - **Option A: マネージドサービス（RDS PostgreSQL, ElastiCache Redis, InfluxDB Cloud）**
    - メリット: 自動バックアップ、Multi-AZ高可用性、パッチ管理自動化
    - デメリット: コスト増（特にInfluxDB Cloud）、InfluxDB 2.xのマネージドサービスが限定的
  - **Option B: ECS Fargate上にデータベースコンテナをデプロイ**
    - メリット: コスト削減、アーキテクチャの一貫性
    - デメリット: バックアップ・冗長化を自前実装、データ永続化にEFSまたはEBS必要
  - **推奨**: PostgreSQLとRedisはマネージドサービス（RDS/ElastiCache）を使用し、InfluxDBはECS Fargate + EFS + 日次スナップショットをS3に保存

#### 2. カメラデバイスの映像データ伝送方式（MQTT vs RTSP/WebRTC）
- **確認理由**: 設計書ではカメラもMQTT経由で通信するように読めるが、映像ストリーミングをMQTTで行うのは帯域・レイテンシの面で非効率。RTSP/WebRTCなどの専用プロトコルを使用すべきか確認が必要
- **選択肢とトレードオフ**:
  - **Option A: カメラ映像もMQTT経由で送信（Base64エンコード等）**
    - メリット: アーキテクチャの一貫性、認証機構の再利用
    - デメリット: 帯域消費大、リアルタイム性低下、MQTT Brokerの負荷増大
  - **Option B: カメラはRTSP/HLSで直接配信、制御コマンドのみMQTT**
    - メリット: 低レイテンシ、帯域効率
    - デメリット: カメラへの直接アクセス経路が必要（ファイアウォール設定複雑化）
  - **Option C: WebRTC経由でP2P接続、シグナリングのみAPI Server経由**
    - メリット: 最低レイテンシ、サーバー負荷軽減
    - デメリット: NAT traversal複雑、実装コスト大
  - **推奨**: Option B（RTSP/HLS）で、カメラがAWS Kinesis Video Streamsにストリームをプッシュし、モバイルアプリがHLS経由で視聴。制御コマンド（録画開始/停止）はMQTT経由

#### 3. 多要素認証（MFA）の実装範囲
- **確認理由**: IoTプラットフォームでは物理デバイス（ドアロック）へのアクセスが可能であり、パスワードのみの認証ではリスクが高い。MFA実装の優先度と範囲を確認すべき
- **選択肢とトレードオフ**:
  - **Option A: 全ユーザーにMFA必須（TOTP, SMS, WebAuthn）**
    - メリット: 最高レベルのセキュリティ
    - デメリット: UX低下（特に高齢者ユーザー）、SMSコスト、実装コスト大
  - **Option B: 管理者およびデバイスメーカーAPIのみMFA必須**
    - メリット: 重要な操作のみ保護、UX影響最小
    - デメリット: エンドユーザーアカウント乗っ取りリスクは残る
  - **Option C: MFAはオプション（ユーザーが有効化可能）**
    - メリット: 柔軟性、段階的導入可能
    - デメリット: 多くのユーザーが有効化しない可能性
  - **推奨**: Phase 1でOption C（オプションMFA）を実装し、Phase 2で機密操作（デバイス削除、権限変更）時に追加認証を要求

#### 4. GDPR/CCPA等のプライバシー規制への準拠範囲
- **確認理由**: 設計書に地域・対象ユーザーの法的要件が記載されていない。欧州ユーザーを対象とする場合はGDPR準拠（データ保護影響評価、DPO任命等）が必須
- **選択肢とトレードオフ**:
  - **Option A: グローバル対応（GDPR, CCPA, LGPD全て準拠）**
    - メリット: 全市場に展開可能
    - デメリット: 実装コスト大（Cookie同意管理、データポータビリティAPI、DPO任命）
  - **Option B: 特定地域のみ対応（例: 米国のみ、GDPR対象外）**
    - メリット: 実装簡素化、コスト削減
    - デメリット: 欧州市場展開不可
  - **推奨**: 初期はOption Bで米国市場のみ、Phase 2でGDPR準拠機能追加（データエクスポートAPI、削除リクエスト処理、Cookie同意管理）

---

### 評価（良い点）

1. **JWTトークンの有効期限設定が適切**: アクセストークン15分、リフレッシュトークン7日という設定は、利便性とセキュリティのバランスが取れている。特にアクセストークンの短い有効期限は、トークン窃取時の被害期間を最小化する

2. **TLS 1.2以上の全通信暗号化**: 全ての通信（HTTPS, MQTT/TLS）をTLS 1.2以上で暗号化する方針は、中間者攻撃やパケット盗聴を防ぐ基本対策として評価できる

3. **bcryptによるパスワードハッシュ化（コストファクタ10）**: 業界標準のハッシュアルゴリズムと適切なコストファクタの使用により、レインボーテーブル攻撃やブルートフォース攻撃に対する耐性を確保

4. **ファームウェア署名検証の要件定義**: 非機能要件に「ファームウェア更新パッケージの署名検証」が記載されており、OTA更新の完全性保証の重要性を認識している点は評価できる（ただし実装詳細は要設計）

5. **権限レベルの明確な分離（owner/write/read）**: `device_access`テーブルで3段階の権限レベルを定義し、最小権限の原則を適用する設計は、家族共有シナリオにおける適切なアクセス制御を可能にする

6. **構造化ログとリクエストID**: 構造化ログ（JSON形式）とリクエストIDトレーシングの設計により、セキュリティインシデント発生時の迅速な調査・分析が可能

7. **Blue/Greenデプロイメントによるロールバック可能性**: 前バージョンのタスク定義を保持することで、セキュリティパッチ適用時の問題発生時に迅速にロールバック可能な設計は、可用性とセキュリティの両立に貢献

---

## スコアサマリ

| 観点 | スコア (1-5) | 主な理由 |
|-----|-------------|---------|
| 脅威モデリング（STRIDE） | 2 | MQTT認証の脆弱性（Spoofing）、デバイスキー発行プロセス未設計（Spoofing/Tampering）、Socket.IO認証欠落（Information Disclosure） |
| 認証・認可設計 | 2 | JWTトークン保存場所未定義（XSS窃取リスク）、権限昇格防止策未設計、MQTTトピックレベルACL欠落 |
| データ保護 | 2 | センサーデータ（特にカメラ映像）の暗号化方針未定義、データ保持期間・削除ポリシー欠落、GDPR準拠未考慮 |
| 入力検証設計 | 3 | Joiによるデータ検証は実装予定だが、デバイスコマンド検証の詳細不明、SQLインジェクション対策未言及 |
| インフラ・依存関係 | 2 | OTA更新のS3 URL公開範囲未定義、ファームウェア署名検証の実装詳細欠落、データベース認証情報管理未設計 |
| **総合** | **2.2** | **重大な設計不足が多数存在。認証・認可、データ保護、デバイスセキュリティの3領域で即時の設計修正が必要** |

---

## 総評

本設計書は、IoTプラットフォームの基本的なアーキテクチャと技術スタックを定義しているが、**セキュリティ設計の詳細が不足しており、現状では本番環境への展開は推奨できない**。特に以下の3領域で重大な問題がある：

1. **認証・認可の脆弱性**: JWTトークンの安全な保存方式、MQTT接続の認証・認可、Socket.IO通信の保護が未設計であり、これらはアカウント乗っ取りやデバイス不正制御の直接的な経路となる
2. **データ保護の不足**: カメラ映像などの高機密データの暗号化・保持期間・削除ポリシーが未定義であり、プライバシー侵害およびGDPR等の規制違反リスクが高い
3. **デバイスセキュリティの不備**: デバイス認証キーの発行・配布プロセス、OTA更新の署名検証実装、侵害デバイス検出機構が欠落しており、デバイス層での攻撃に対する防御が脆弱

**推奨アクション**：
- 「重大な問題」セクションの7項目をすべて設計に反映し、再レビューを実施
- Phase 1実装前にセキュリティアーキテクトによる脅威モデリングセッションを開催（STRIDE分析）
- 最低限、項目1（JWTトークン保存）、項目2（device_key発行）、項目3（MQTT認証）、項目4（OTA署名検証）の4項目を設計完了後でなければ実装を開始しない

本レビューで指摘した問題のうち、「重大な問題」は設計段階で修正することで実装コストを大幅に削減できる。実装後の修正はアーキテクチャ変更を伴い、数倍のコストがかかる可能性が高い。
