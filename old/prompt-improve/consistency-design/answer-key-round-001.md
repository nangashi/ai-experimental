# 正解キー

## 実行条件
- **観点**: consistency（一貫性）
- **対象**: design
- **埋め込み問題数**: 9問

## 埋め込み問題一覧

### P01: テーブル名の命名規則の不統一
- **カテゴリ**: 命名規約の既存パターンとの一致
- **深刻度**: 中
- **該当箇所**: セクション4「データモデル」
- **問題の説明**: テーブル名の命名規則が統一されていない。`users` と `automation_rule` は単数形だが、`Devices` は複数形かつ大文字始まりとなっている。既存コードベースで一貫した命名規則（全て複数形小文字または全て単数形小文字等）が採用されている場合、この不統一は開発時の混乱を招く。
- **検出判定基準**:
  - ○（検出）: テーブル名の命名規則が不統一であり、`users` は複数形、`Devices` は複数形＋大文字始まり、`automation_rule` は単数形となっている点を指摘し、既存パターンとの一致確認または統一の必要性を述べている
  - △（部分検出）: 命名規則の不統一について言及しているが、具体的なテーブル名の比較がない、または既存パターンとの一致確認の観点が欠けている
  - ×（未検出）: テーブル名の命名規則について指摘がない

### P02: カラム名の命名規則の混在
- **カテゴリ**: 命名規約の既存パターンとの一致
- **深刻度**: 中
- **該当箇所**: セクション4「データモデル」の各テーブル定義
- **問題の説明**: カラム名の命名規則が混在している。`users` テーブルは `userId` (camelCase) と `created_at` (snake_case)、`Devices` テーブルは `device_id` (snake_case) と `DeviceName` (PascalCase) と `last_updated` (snake_case)、`automation_rule` テーブルは `rule_id` (snake_case) と `RuleName` (PascalCase) と `createdAt` (camelCase) が混在している。既存コードベースでカラム命名規則が統一されている場合、この不統一は重大な問題となる。
- **検出判定基準**:
  - ○（検出）: カラム名の命名規則に camelCase/snake_case/PascalCase の混在があり、具体的なカラム名（例: `userId` と `created_at`、`DeviceName` と `device_id`）を挙げて既存パターンとの一致確認または統一の必要性を述べている
  - △（部分検出）: カラム名の命名規則の不統一に言及しているが、具体例が不十分または既存パターンとの一致確認の観点が欠けている
  - ×（未検出）: カラム名の命名規則について指摘がない

### P03: APIレスポンス形式が既存パターンと異なる可能性
- **カテゴリ**: API/インターフェース設計・依存関係の既存パターンとの一致
- **深刻度**: 中
- **該当箇所**: セクション5「API設計」のレスポンス例
- **問題の説明**: 新API設計のレスポンス形式は `{result, devices/device, message}` の構造だが、設計書には既存APIのレスポンス形式との一致を確認する記述がない。既存APIが `{data, error}` や `{success, payload}` などの別形式を採用している場合、クライアント側の統一的なエラーハンドリングが困難になる。API設計方針に既存パターンとの一致を明記すべき。
- **検出判定基準**:
  - ○（検出）: APIレスポンス形式（`result`, `message`, `devices/device` の構造）が設計書に明記されているが、既存APIとの一致確認またはレスポンス形式の標準化方針が欠落している点を指摘している
  - △（部分検出）: APIレスポンス形式について言及しているが、既存パターンとの一致確認の必要性に触れていない、またはレスポンス形式の具体的な構造（フィールド名等）に言及がない
  - ×（未検出）: APIレスポンス形式の一貫性について指摘がない

### P04: エラーハンドリングパターンが既存の実装方針と異なる可能性
- **カテゴリ**: 実装パターンの既存パターンとの一致
- **深刻度**: 重大
- **該当箇所**: セクション6「実装方針」のエラーハンドリング方針
- **問題の説明**: 新設計では各Controllerメソッド内での個別try-catchによるエラーハンドリングを採用しているが、既存コードベースがグローバルエラーハンドラー（例: Express.jsのエラーミドルウェア）で集中管理している場合、パターンの不一致が発生する。設計書には既存のエラーハンドリングパターン（グローバルハンドラー/個別catch/その他）との一致を確認する記述が欠けている。
- **検出判定基準**:
  - ○（検出）: エラーハンドリング方針として「個別try-catchブロック」が明記されているが、既存コードベースのパターン（グローバルエラーハンドラー等）との一致確認が欠落している点、またはパターンの不一致の可能性について指摘している
  - △（部分検出）: エラーハンドリングパターンについて言及しているが、既存パターンとの一致確認の必要性に触れていない、または「個別catch」と「グローバルハンドラー」の違いに言及がない
  - ×（未検出）: エラーハンドリングパターンの一貫性について指摘がない

### P05: データアクセスパターンとトランザクション管理方針の欠落
- **カテゴリ**: 実装パターン（情報欠落）
- **深刻度**: 重大
- **該当箇所**: セクション3「アーキテクチャ設計」およびセクション6「実装方針」
- **問題の説明**: 設計書には「Sequelize 6.xをORMとして使用」と記載されているが、データアクセスの具体的な実装パターン（Repository経由でSequelizeを呼び出すのか、Service層から直接ORMを呼ぶのか）およびトランザクション管理方針（どのレイヤーでトランザクションを開始/コミットするか）が明記されていない。既存コードベースで一貫したパターンが採用されている場合、この情報欠落により一貫性が検証できない。
- **検出判定基準**:
  - ○（検出）: データアクセスパターン（Repository/Service層からのORM呼び出し方針）またはトランザクション管理方針（どのレイヤーで開始/コミットするか）が設計書に明記されておらず、既存パターンとの一貫性が検証できない点を指摘している
  - △（部分検出）: データアクセスまたはトランザクション管理について言及しているが、既存パターンとの一致確認の必要性に触れていない、またはどちらか一方のみの指摘
  - ×（未検出）: データアクセスパターンおよびトランザクション管理方針の欠落について指摘がない

### P06: HTTP通信ライブラリの選定が既存と異なる可能性
- **カテゴリ**: API/インターフェース設計・依存関係の既存パターンとの一致
- **深刻度**: 中
- **該当箇所**: セクション2「技術スタック」の主要ライブラリ
- **問題の説明**: 新設計では `node-fetch 3.x` を使用しているが、既存コードベースで `axios` や標準の `http/https` モジュールを統一的に使用している場合、異なるライブラリの導入は依存管理の複雑化とコードスタイルの不統一を招く。設計書には既存のHTTP通信ライブラリ選定基準との一致を確認する記述が欠けている。
- **検出判定基準**:
  - ○（検出）: `node-fetch` の採用について、既存コードベースで使用中のHTTP通信ライブラリ（axios等）との整合性確認が欠落している点、または同機能の別ライブラリを新たに導入することの妥当性確認が必要である点を指摘している
  - △（部分検出）: ライブラリ選定について言及しているが、既存との一致確認の必要性に触れていない、または具体的なライブラリ名（node-fetch, axios等）に言及がない
  - ×（未検出）: HTTP通信ライブラリの一貫性について指摘がない

### P07: 環境変数命名規則の方針が欠落
- **カテゴリ**: API/インターフェース設計・依存関係の既存パターンとの一致（情報欠落）
- **深刻度**: 軽微
- **該当箇所**: セクション6「実装方針」のデプロイメント方針
- **問題の説明**: 設計書には「環境変数管理: AWS Systems Manager Parameter Storeで管理」と記載されているが、環境変数の命名規則（大文字スネークケース/camelCase等）が明記されていない。既存コードベースで統一された命名規則が採用されている場合、この情報欠落により一貫性が検証できない。
- **検出判定基準**:
  - ○（検出）: 環境変数の命名規則が設計書に明記されておらず、既存パターン（大文字スネークケース等）との一貫性が検証できない点を指摘している
  - △（部分検出）: 環境変数の管理方法について言及しているが、命名規則の明記が必要という点に触れていない、または既存パターンとの一致確認の必要性に触れていない
  - ×（未検出）: 環境変数命名規則について指摘がない

### P08: ログ出力パターンの設計書記載と実装例の不一致
- **カテゴリ**: 実装パターンの既存パターンとの一致
- **深刻度**: 軽微
- **該当箇所**: セクション6「実装方針」のロギング方針
- **問題の説明**: ロギング方針として「構造化ログをJSON形式で出力」と記載されており、ログ形式例も提示されている。ただし、設計書には既存コードベースのログ出力パターン（Winston/Bunyan/console.log等のライブラリ選定、ログレベル分類、メッセージ形式）との一致を確認する記述が欠けている。また、実装方針セクションのエラーハンドリング例ではロギング処理が記載されておらず、ロギング方針との一貫性が不明確。
- **検出判定基準**:
  - ○（検出）: ログ出力パターン（Winston使用、JSON形式）が明記されているが、既存コードベースのロギングパターンとの一致確認が欠落している点、またはエラーハンドリング例でロギング処理が省略されている点を指摘している
  - △（部分検出）: ロギングパターンについて言及しているが、既存パターンとの一致確認の必要性に触れていない、またはエラーハンドリング例との一貫性に言及がない
  - ×（未検出）: ログ出力パターンの一貫性について指摘がない

### P09: API命名規則・エンドポイント設計方針の欠落
- **カテゴリ**: API/インターフェース設計・依存関係の既存パターンとの一致（情報欠落）
- **深刻度**: 中
- **該当箇所**: セクション5「API設計」
- **問題の説明**: 新API設計でエンドポイント例（`GET /api/devices`, `POST /api/automation/rules`等）は提示されているが、API命名規則（RESTful設計、リソース名の複数形/単数形、動詞の使用可否等）や既存APIとの一致を確認する記述が設計書に欠けている。既存APIが異なる命名規則（例: `/device/list` のような動詞使用）を採用している場合、一貫性が検証できない。
- **検出判定基準**:
  - ○（検出）: API命名規則（エンドポイントの命名パターン、リソース表現等）が設計書に明記されておらず、既存APIとの一貫性が検証できない点を指摘している
  - △（部分検出）: API設計について言及しているが、命名規則の明記が必要という点に触れていない、または既存パターンとの一致確認の必要性に触れていない
  - ×（未検出）: API命名規則の一貫性について指摘がない

## ボーナス問題リスト

正解キーに含めないが、検出された場合にボーナスとして加点する問題の候補:

| ID | カテゴリ | 内容 | ボーナス条件 |
|----|---------|------|------------|
| B01 | 命名 | 外部キー制約のカラム名が参照先と異なる（`Devices.user_id` → `users.userId`） | 外部キー制約のカラム名（snake_case vs camelCase）の不一致を指摘 |
| B02 | 実装パターン | 認証トークンの保存先（localStorage）のセキュリティリスク | localStorageの使用がセキュリティ観点で問題であることを指摘（ただしこれはsecurityのスコープなので、consistencyとしては「既存の認証トークン保存パターンと異なる」という指摘のみ評価） |
| B03 | 依存管理 | バリデーションライブラリ（joi）の選定が既存と異なる可能性 | 既存で別のバリデーションライブラリ（yup, zod等）を使用している場合の不一致を指摘 |
| B04 | ディレクトリ構造 | ファイル配置方針が設計書に明記されていない | Controller/Service/Repositoryのファイル配置ルール（ドメイン別/レイヤー別）が明記されておらず、既存パターンとの一貫性が検証できない点を指摘 |
| B05 | 実装パターン | 非同期処理パターンが設計書に明記されていない | async/await/Promise/callbackの使用方針が明記されておらず、既存パターンとの一貫性が検証できない点を指摘 |
