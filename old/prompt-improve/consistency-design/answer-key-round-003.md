# 正解キー

## 実行条件
- **観点**: consistency
- **対象**: design
- **埋め込み問題数**: 10問

## 埋め込み問題一覧

### P01: テーブル命名規則の混在（live_streamとChatMessage）
- **カテゴリ**: 命名規約
- **深刻度**: 重大
- **該当箇所**: セクション4（データモデル）
- **問題の説明**: `live_stream` テーブルはスネークケースだが、`ChatMessage` テーブルはパスカルケースになっており、既存の支配的パターン（スネークケース: `live_stream`, `viewer_sessions`）と不一致。データモデル命名規則の一貫性が損なわれている。
- **検出判定基準**:
  - ○（検出）: `ChatMessage` テーブルの命名がスネークケースの他テーブル（`live_stream`, `viewer_sessions`）と不統一であることを指摘している
  - △（部分検出）: テーブル命名規則の不一致に言及しているが、具体的なテーブル名を挙げていない
  - ×（未検出）: テーブル命名規則の不一致について言及していない

### P02: カラム命名規則の混在（snake_caseとcamelCase）
- **カテゴリ**: 命名規約
- **深刻度**: 中
- **該当箇所**: セクション4（データモデル）
- **問題の説明**: `live_stream` テーブルのカラムはスネークケース（`stream_id`, `streamer_user_id`）だが、`ChatMessage` テーブルのカラムはキャメルケース（`messageId`, `streamId`, `userId`）になっており、一貫性がない。
- **検出判定基準**:
  - ○（検出）: `ChatMessage` テーブルのカラム命名がキャメルケースであり、他テーブルのスネークケースと不統一であることを指摘している
  - △（部分検出）: カラム命名規則に触れているが、具体的なテーブルやカラム名を挙げていない
  - ×（未検出）: カラム命名規則の不一致について言及していない

### P03: レスポンス形式の既存パターンとの不一致
- **カテゴリ**: API設計
- **深刻度**: 重大
- **該当箇所**: セクション5（API設計）
- **問題の説明**: 既存APIは `{data, error}` 形式だが、新設計は `{success, stream/error}` 形式を採用しており、レスポンス形式の一貫性が欠如している。設計書内に既存パターンの記述はないが、新設計のレスポンス形式が統一されていないことから不整合が推測される。
- **検出判定基準**:
  - ○（検出）: レスポンス形式（`{success, stream}` と `{success, error}` の混在、または既存パターンとの不一致の可能性）を指摘している
  - △（部分検出）: API設計の一貫性について言及しているが、レスポンス形式の具体的な不一致には触れていない
  - ×（未検出）: レスポンス形式の不一致について言及していない

### P04: エラーハンドリングパターンの既存との不一致
- **カテゴリ**: 実装パターン
- **深刻度**: 重大
- **該当箇所**: セクション6（実装方針）
- **問題の説明**: 既存システムは「グローバルハンドラによる一元的なエラー処理」だが、新設計は「Controller層の個別catchブロックで処理」という異なるパターンを採用している。設計書内には「既存のレイヤー構成に従い」との記述があるが、エラーハンドリングパターンの既存方式は明記されておらず、個別catchという新方式との不一致が設計書の記述から読み取れる。
- **検出判定基準**:
  - ○（検出）: エラーハンドリングパターンが個別catchブロック方式であり、既存のグローバルハンドラパターンとの一貫性が欠如している可能性を指摘している
  - △（部分検出）: エラーハンドリング方針について言及しているが、既存パターンとの不一致には触れていない
  - ×（未検出）: エラーハンドリングパターンの不一致について言及していない

### P05: API命名規則の情報欠落
- **カテゴリ**: API設計（情報欠落）
- **深刻度**: 中
- **該当箇所**: セクション5（API設計）
- **問題の説明**: API命名規則（エンドポイントパスの命名方式、ケバブケースかスネークケースか等）が設計書に明記されておらず、既存APIパターンとの一貫性を検証できない。エンドポイント例は示されているが、命名規則の方針が記載されていない。
- **検出判定基準**:
  - ○（検出）: API命名規則（エンドポイントパスの命名方式）が設計書に明記されておらず、既存パターンとの一貫性が検証できないことを指摘している
  - △（部分検出）: API設計の情報不足に言及しているが、命名規則の欠落には具体的に触れていない
  - ×（未検出）: API命名規則の情報欠落について言及していない

### P06: データアクセスパターンの情報欠落
- **カテゴリ**: 実装パターン（情報欠落）
- **深刻度**: 中
- **該当箇所**: セクション3（アーキテクチャ設計）、セクション6（実装方針）
- **問題の説明**: データアクセスパターン（Repository経由かORM直接呼び出しか）およびトランザクション管理方針が設計書に明記されておらず、既存パターンとの一貫性を検証できない。Repository層の存在は記載されているが、具体的な実装方式が不明。
- **検出判定基準**:
  - ○（検出）: データアクセスパターンまたはトランザクション管理方針が設計書に明記されておらず、既存パターンとの一貫性が検証できないことを指摘している
  - △（部分検出）: 実装方針の情報不足に言及しているが、データアクセスパターンやトランザクション管理には具体的に触れていない
  - ×（未検出）: データアクセスパターン/トランザクション管理の情報欠落について言及していない

### P07: ログ出力形式の既存との不一致
- **カテゴリ**: 実装パターン
- **深刻度**: 軽微
- **該当箇所**: セクション6（実装方針）
- **問題の説明**: 既存システムは構造化ログ（JSON形式）だが、新設計は平文形式（`[LEVEL] [YYYY-MM-DD HH:MM:SS] [ClassName.methodName] - Log message (key1=value1, key2=value2)`）を採用しており、ログ出力パターンの一貫性が欠如している。設計書内に既存パターンの記述はないが、新設計のフォーマットが一般的なプレーンテキストであることから、構造化ログとの不一致が推測される。
- **検出判定基準**:
  - ○（検出）: ログ出力形式が平文形式であり、既存の構造化ログ（JSON）パターンとの一貫性が欠如している可能性を指摘している
  - △（部分検出）: ログ出力形式について言及しているが、既存パターンとの不一致には触れていない
  - ×（未検出）: ログ出力形式の不一致について言及していない

### P08: 設定ファイル形式の情報欠落
- **カテゴリ**: 依存関係（情報欠落）
- **深刻度**: 軽微
- **該当箇所**: セクション2（技術スタック）、セクション6（実装方針）
- **問題の説明**: 設定ファイル形式（YAML/JSON等）および環境変数命名規則が設計書に明記されておらず、既存パターンとの一貫性を検証できない。Spring Bootプロジェクトであることは明記されているが、設定管理の具体的方式が不明。
- **検出判定基準**:
  - ○（検出）: 設定ファイル形式または環境変数命名規則が設計書に明記されておらず、既存パターンとの一貫性が検証できないことを指摘している
  - △（部分検出）: 設定管理の情報不足に言及しているが、ファイル形式や環境変数規則には具体的に触れていない
  - ×（未検出）: 設定ファイル形式/環境変数規則の情報欠落について言及していない

### P09: 非同期処理パターンの情報欠落
- **カテゴリ**: 実装パターン（情報欠落）
- **深刻度**: 中
- **該当箇所**: セクション3（データフロー）、セクション6（実装方針）
- **問題の説明**: 非同期処理パターン（async/await、CompletableFuture、@Async等）が設計書に明記されておらず、既存パターンとの一貫性を検証できない。RabbitMQによる非同期イベント処理は記載されているが、Javaコード側での非同期実装方式が不明。
- **検出判定基準**:
  - ○（検出）: 非同期処理パターン（Java側での実装方式）が設計書に明記されておらず、既存パターンとの一貫性が検証できないことを指摘している
  - △（部分検出）: 非同期処理について言及しているが、Javaコード側の実装パターンの情報欠落には具体的に触れていない
  - ×（未検出）: 非同期処理パターンの情報欠落について言及していない

### P10: 依存ライブラリの既存との重複
- **カテゴリ**: 依存管理
- **深刻度**: 中
- **該当箇所**: セクション2（技術スタック）
- **問題の説明**: 既存システムで使用中の HTTP 通信ライブラリがある場合（例: RestTemplate）、新設計で Spring WebClient を導入することは同機能の別ライブラリの重複導入となる可能性がある。設計書内に既存ライブラリの記述はないが、Spring WebClient の導入理由や既存ライブラリとの関係が明記されていない。
- **検出判定基準**:
  - ○（検出）: Spring WebClient の導入について、既存のHTTP通信ライブラリとの関係や重複の可能性を指摘している
  - △（部分検出）: HTTP通信ライブラリの選定について言及しているが、既存ライブラリとの重複や一貫性には触れていない
  - ×（未検出）: 依存ライブラリの重複について言及していない

## ボーナス問題リスト

正解キーに含めないが、検出された場合にボーナスとして加点する問題の候補:

| ID | カテゴリ | 内容 | ボーナス条件 |
|----|---------|------|------------|
| B01 | 命名規約 | エンドポイントパスの命名混在（`/streams` はケバブケース、`/chat-messages` もケバブケースで一貫しているが、設計書内にリソース名の複数形/単数形ルールが明記されていない） | エンドポイント命名のリソース複数形/単数形ルールの情報欠落を指摘している |
| B02 | アーキテクチャ | WebSocketHandlerの配置層（Presentation層）が既存のアーキテクチャガイドラインと一致しているか不明 | WebSocketHandlerの層配置について既存パターンとの一貫性検証が必要であることを指摘している |
| B03 | 実装パターン | バリデーションライブラリ（Jakarta Validation）の使用が既存システムとの一貫性を保っているか不明（既存が別のバリデーション方式を採用している可能性） | バリデーション実装方式の既存パターンとの一貫性検証が必要であることを指摘している |
| B04 | 実装パターン | メッセージキュー（RabbitMQ）のメッセージフォーマットやトピック命名規則が設計書に明記されておらず、既存パターンとの一貫性が検証できない | RabbitMQメッセージフォーマット/トピック命名規則の情報欠落を指摘している |
