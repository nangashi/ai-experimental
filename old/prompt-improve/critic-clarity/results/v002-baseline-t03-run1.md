### 明確性批評結果

#### 重大な問題（AIの動作に大きなブレが生じる）
- [可読性 - ネスト深度]: 「3階層以内を推奨」と問題バンクの「4-5階層は中程度問題」の間に境界の曖昧さがある（3階層と4階層の境界ケースでAI判断が分かれる可能性）→ 明確な基準を設定（例: 「3階層以内。4階層は警告、5階層以上は問題」）
- [保守性 - 重複コード]: 「適度に削減されているか（完全なDRY原則ではなく、バランスを考慮）」という表現で、「適度」「バランス」の判断基準が不明確 → 具体的な基準を追加（例: 「同一ロジックが3箇所以上に重複している場合は削減を検討。ただし5行以下の短いコードは許容」）
- [保守性 - テストカバレッジ]: 「テストコードがある場合、カバレッジが十分か」の「十分」が曖昧で、条件付き基準（「〜の場合」）がAI判断を分岐させる → 数値基準を明示（例: 「テストコードがある場合、主要機能のカバレッジが70%以上か」）
- [ボーナス/ペナルティ]: 「型安全性が高い設計」の「高い」、「グローバル変数の過度な使用」の「過度」が主観的で判定基準が不明確 → 具体基準を追加（例: 「ボーナス: TypeScript使用、または型ヒント使用率が80%以上」「ペナルティ: グローバル変数が5個以上、または複数モジュールから変更される」）

#### 改善提案
- [可読性 - 変数名・関数名]: 「意味を表しているか」は抽象的だが、問題バンクの「1文字変数名（ループカウンタ除く）」との対応で補完されている。ただし「意味を表す」の具体基準を追加すると一貫性が向上（例: 「変数名が3文字以上で、役割が推測可能か」）
- [可読性 - コメント]: 「複雑なロジックにコメントがあるか」の「複雑」を定義する（例: 「ネストが3階層以上、または条件分岐が3つ以上含まれるロジック」）
- [保守性 - 単一責任]: 「関数が単一責任を守っているか」は抽象的で、AIが何を具体的に確認すべきか不明確 → 検出可能な基準に変換（例: 「関数名に"And"が含まれていないか、複数の異なるデータ構造を操作していないか」）

#### 確認（良い点）
- 数値基準が明確な項目がある（「3階層以内を推奨」「関数が200行を超える」「ネストが4-5階層」）
- 問題バンクの例外処理の記述が具体的（「変数名が1文字（ただしループカウンタを除く）」）
- スコープ外が明確に定義されている（パフォーマンス最適化、特定のコーディング規約）
