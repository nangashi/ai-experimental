# Nexamart プラットフォーム システム設計書

**バージョン**: 1.4.0
**作成日**: 2026-02-01
**対象**: マルチテナント型マーケットプレイス（Nexamart）

---

## 1. 概要

Nexamartは、複数のテナント（出店事業者）が独立したオンラインショップを運営できるマルチテナント型マーケットプレイスプラットフォームである。プラットフォームは以下の参加者を持つ:

- **テナント**: 商品出品・在庫管理・注文管理を行う事業者
- **エンドユーザー（買い手）**: 複数テナントの商品を横断的に購入可能なユーザー
- **プラットフォーム管理者**: 全テナントの監視・設定・KYC審査を行う管理者

システムはSaaS形式でクラウド（AWS）上に展開し、全テナントは同一インフラを共有する。

---

## 2. 技術スタック

| コンポーネント | 技術 | バージョン |
|-------------|------|---------|
| フロントエンド | Next.js (App Router) | 14.x |
| バックエンドAPI | Node.js / Fastify | 20.x |
| データストア | PostgreSQL | 16.x |
| キャッシュ | Redis | 7.x |
| ファイルストレージ | AWS S3 | - |
| コンテナ基盤 | AWS ECS (Fargate) | - |
| CDN | AWS CloudFront | - |
| メッセージキュー | AWS SQS | - |
| 認証ライブラリ | jsonwebtoken | 9.0.0 |
| ファイルアップロード | multer | 1.4.4 |

---

## 3. アーキテクチャ設計

### 3.1 全体構成

```
[ユーザーブラウザ]
       |
[CloudFront CDN]
       |
[API Gateway (Kong)]
       |
  ┌────┴────┐
  │         │
[認証サービス] [コアAPIサービス]
              |
   ┌──────────┼──────────┐
   |          |          |
[注文サービス] [商品サービス] [テナント管理サービス]
              |
   [PostgreSQL] [Redis] [S3]
```

### 3.2 マルチテナント分離方式

- **データ分離**: 全テーブルに `tenant_id` カラムを持つ共有スキーマ方式。アプリケーション層でのクエリフィルタリングにより他テナントデータへのアクセスを防止する
- **URL分離**: `{tenant-slug}.nexamart.com` のサブドメイン方式
- **テナント識別**: リクエストヘッダー `X-Tenant-ID` を Kong ゲートウェイが付与する

エンドユーザーはサブドメインからテナントIDを解決するため、リクエスト本文にテナントIDを含めることはない。Kong ゲートウェイが付与する `X-Tenant-ID` ヘッダーはエンドユーザーのリクエストでは検証済みの値として扱われ、コアAPIサービスはこの値を信頼してデータアクセスの絞り込みに使用する。

### 3.3 APIサービス設計方針

- RESTful API、JSON形式
- バージョニング: `/api/v1/`
- Kong ゲートウェイにて認証トークン検証とルーティングを実施
- コアAPIサービスはゲートウェイを通過したリクエストを信頼済みとして処理する

---

## 4. 認証・認可設計

### 4.1 認証フロー

エンドユーザーはメールアドレス＋パスワードによる認証を行う。認証成功後、JWTアクセストークン（有効期限: 60分）とリフレッシュトークン（有効期限: 30日）を発行する。

**トークン保存場所:**
- アクセストークン: ブラウザの `localStorage` に保存
- リフレッシュトークン: `HttpOnly` Cookie として保存

ユーザーパスワードは bcrypt（cost factor: 12）でハッシュ化して保存する。

**テナント管理者認証:**
テナント管理者は管理ダッシュボード（`admin.nexamart.com`）に対して別途ログインを行う。管理者JWTにはテナントIDクレームを含め、操作可能なテナントを制限する。

### 4.2 セッション管理

- ログアウト時にサーバーサイドでリフレッシュトークンをブラックリスト（Redis）へ追加
- アクセストークンの失効管理はトークン有効期限のみで実施（サーバーサイドのブロックリストなし）
- 不正検知や権限変更が発生した場合のトークン即時無効化は、リフレッシュトークンの期限切れに依存する設計とする

### 4.3 認可モデル

RBAC（Role-Based Access Control）を採用する。

**ロール定義:**

| ロール | 権限範囲 |
|-------|---------|
| `platform_admin` | 全テナント・全リソースの読み書き |
| `tenant_admin` | 自テナントの全リソース管理 |
| `tenant_staff` | 自テナントの商品・注文の読み書き（設定変更不可）|
| `buyer` | 商品閲覧・購入・自分の注文管理 |

認可チェックはコアAPIサービスの各ハンドラで実施する。テナントスコープのリソースアクセスはJWTの `tenantId` クレームと `X-Tenant-ID` ヘッダーを照合する。

### 4.4 認証エンドポイント

| メソッド | パス | 概要 |
|---------|------|------|
| POST | /api/auth/login | ログイン（JWT発行） |
| POST | /api/auth/logout | ログアウト |
| POST | /api/auth/refresh | トークンリフレッシュ |
| POST | /api/auth/register | エンドユーザー登録 |

---

## 5. データ保護

### 5.1 保存データの暗号化

- **保存時暗号化**: AWS RDS の Transparent Data Encryption (TDE) を利用
- **個人情報フィールドの暗号化**: 氏名・住所・電話番号などの個人情報は平文で保存する。RDS暗号化により保護されているため、フィールドレベルでの追加暗号化は不要と判断する
- **クレジットカード情報**: Stripe に委譲し、本システムには保持しない
- **鍵管理**: AWS KMS を使用、ローテーション周期: 年1回

### 5.2 転送時の保護

- 全通信は HTTPS/TLS 1.2以上を強制
- CloudFront → ECS 間も内部的に HTTPS を使用

### 5.3 個人情報（PII）管理

- 保存対象: 氏名、メールアドレス、住所、電話番号
- **データ保持期間・削除方針**: 現時点では未定義。退会申請があった場合の対応フローは今後設計する
- **ログへのPII出力**: アプリケーションログへの個人情報出力は禁止。エラー調査時に必要な場合はユーザーIDのみ記録する

### 5.4 S3ストレージセキュリティ

- テナントのロゴ・商品画像: パブリックバケット（CloudFront配信）
- 請求書・契約書類: プライベートバケット（署名付きURL発行、有効期限7日）

---

## 6. 入力検証・攻撃防御

### 6.1 入力検証方針

- バックエンドAPIはすべてのリクエストパラメータをZodスキーマで検証する
- SQLインジェクション対策: Prisma ORMのパラメータ化クエリを使用
- コマンドインジェクション: ユーザー入力をシェルコマンドに渡す処理は存在しない

### 6.2 XSS対策

- Next.jsのJSXレンダリングによる自動エスケープ
- CSP（Content Security Policy）を設定: `default-src 'self'`
- ユーザー投稿のリッチテキスト（商品説明等）: DOMPurifyによるサニタイズ

### 6.3 CSRF対策

state-changingな操作（POST/PUT/PATCH/DELETE）はすべてAuthorizationヘッダーにJWTを付与することを必須とする。JWTは認証済みユーザーのみ保持できるため、CSRF対策として十分と判断する。

### 6.4 CORS設定

許可オリジン: `*.nexamart.com` を正規表現マッチで許可する。

実装方針:
```javascript
const allowedOrigin = /\.nexamart\.com$/;
if (allowedOrigin.test(origin)) {
  reply.header('Access-Control-Allow-Origin', origin);
  reply.header('Access-Control-Allow-Credentials', 'true');
}
```

### 6.5 ファイルアップロード

商品画像・テナントロゴのアップロードを受け付ける。

- アップロード方式: S3署名付きURL（Presigned URL）経由でのクライアント直接アップロード
- ファイルサイズ上限: 10MB（Presigned URL生成時に指定）
- MIME型チェック: `Content-Type` ヘッダーによる判定のみ（拡張子検証なし）
- ウイルススキャン: 未導入（将来対応）

---

## 7. API設計

### 7.1 商品API

| メソッド | パス | 権限 | 概要 |
|---------|------|------|------|
| GET | /api/products | 全員 | 公開商品の横断検索 |
| GET | /api/products/:id | 全員 | 商品詳細取得 |
| POST | /api/products | tenant_admin, tenant_staff | 商品登録 |
| PUT | /api/products/:id | tenant_admin, tenant_staff | 商品更新 |
| DELETE | /api/products/:id | tenant_admin | 商品削除 |

### 7.2 注文API

| メソッド | パス | 権限 | 概要 |
|---------|------|------|------|
| POST | /api/orders | buyer | 注文作成 |
| GET | /api/orders/:id | buyer, tenant_admin | 注文詳細取得 |
| PATCH | /api/orders/:id/status | tenant_admin, tenant_staff | 注文ステータス更新 |
| GET | /api/orders | tenant_admin, tenant_staff | 注文一覧（自テナント） |

### 7.3 外部サービス連携

- **Stripe**: 決済処理。Webhookエンドポイント `/api/webhooks/stripe` にてイベント受信後、支払いステータスを注文に反映する
- **SendGrid**: トランザクションメール送信（注文確認、発送通知等）

---

## 8. インフラ・依存関係・監査

### 8.1 シークレット管理

- DBパスワード、外部APIキー、JWT署名鍵は AWS Secrets Manager で管理
- ECSタスク定義でシークレットを環境変数として注入
- ローカル開発環境用の設定は `.env` ファイルに記載し、`.gitignore` に追加済み
- 本番環境のシークレット値はデプロイ担当者の参照用に `config/secrets.prod.yaml` へも記録し、アクセス制限を設けたうえでリポジトリに含める

### 8.2 依存ライブラリ管理

- 主要ライブラリのバージョンは `package-lock.json` で固定
- セキュリティアップデートは四半期ごとに確認・適用を計画
- `multer@1.4.4` を使用（マルチパートフォーム処理）

### 8.3 ネットワーク・アクセス制御

- ECSコンテナはプライベートサブネットに配置
- 管理コンソールへのアクセスはVPN経由を必須とする（IP制限）
- 各サービス間通信はSecurity Groupで最小権限を設定

### 8.4 監査ログ

プラットフォーム操作の透明性確保のため、以下のイベントをCloudWatch Logsに記録する:

- テナント登録・停止
- 商品公開・非公開切り替え
- 注文ステータス変更
- テナント管理者によるユーザーデータエクスポート

ログはアプリケーションの通常ログと同一のCloudWatch Logsストリームに出力する。認証失敗やロール変更の記録はセキュリティ要件（7.4節）に従い実施する。

---

## 9. 非機能要件

### 9.1 可用性

- 目標稼働率: 99.9%（月間ダウンタイム約43分）
- マルチAZ構成（RDS Multi-AZ、ECSマルチAZ展開）

### 9.2 スケーラビリティ

- ECS Fargateの Auto Scaling（CPU使用率70%を閾値）
- RDS Read Replicaによる読み取り負荷分散

### 9.3 パフォーマンス

- API p99レイテンシ目標: 500ms以内
- Redisキャッシュ活用（商品一覧、テナント設定）

### 9.4 セキュリティ要件

- 全通信はHTTPS（TLS 1.2以上）
- 依存ライブラリの脆弱性スキャンを四半期ごとに実施
- 認証失敗・権限変更等の重要イベントをアプリケーションログに記録する

### 9.5 監視・アラート

- CloudWatchメトリクスによるリソース監視
- エラーレートのアラート設定（5xx: 1%超でアラート）
- PagerDuty連携によるon-callローテーション
