# セキュリティ設計レビュー: Nexamart プラットフォーム システム設計書 v1.4.0

**レビュー対象**: test-document-2.md (Nexamart プラットフォーム)
**プロンプト**: v002-variant-input-validation-stable
**実施日**: 2026-02-18

---

## 総評

Nexamartのマルチテナント型マーケットプレイス設計には、複数の重大なセキュリティ問題が存在する。特にシークレット管理の致命的な欠陥、CSRF対策の不備、CORS設定の問題が早急な対処を要する。

---

## 重大な問題 (Critical)

### C-01: 本番シークレットのリポジトリへの格納

**該当箇所**: セクション 8.1 シークレット管理

**問題**:
> 本番環境のシークレット値はデプロイ担当者の参照用に `config/secrets.prod.yaml` へも記録し、アクセス制限を設けたうえでリポジトリに含める

本番環境のシークレット値（DBパスワード、APIキー、JWT署名鍵を含む）をGitリポジトリに格納することは、設計上の致命的欠陥である。

**影響分析**:
- リポジトリへのアクセス権を持つすべての開発者・CI/CDシステムが本番シークレットにアクセス可能となる
- リポジトリ履歴にシークレットが残存し、アクセス制限変更後も過去コミットから取得可能
- JWT署名鍵が漏洩した場合、攻撃者は任意のJWTを偽造できる（認証の完全な破綻）
- DBパスワード漏洩により全テナントデータへの直接アクセスが可能となる
- セキュリティインシデント発生時のフォレンジックが困難になる

**推奨対策**:
- `config/secrets.prod.yaml` をリポジトリから削除し、Gitの履歴からも除去（`git filter-branch` または BFG Repo-Cleaner を使用）
- AWS Secrets Manager のみをシークレットの単一ソースとして使用する（既に導入済みのため移行コストは低い）
- デプロイ担当者が参照する必要がある場合は、AWS Secrets Manager コンソールまたは CLI への適切なIAMアクセスを付与する
- `.gitignore` に `config/secrets*.yaml` を追加する

---

### C-02: JWT単独によるCSRF対策の不完全性

**該当箇所**: セクション 6.3 CSRF対策

**問題**:
> state-changingな操作はすべてAuthorizationヘッダーにJWTを付与することを必須とする。JWTは認証済みユーザーのみ保持できるため、CSRF対策として十分と判断する。

この判断は部分的にしか正しくない。Authorizationヘッダーに格納されたJWTを使用するXHRリクエストはCSRFから保護されるが、設計書を読む限り**アクセストークンはlocalStorageに保存**される一方、**リフレッシュトークンはHttpOnly Cookieに保存**されている。

**根本的な問題**:
- リフレッシュトークンのCookie認証フローにおいて、`/api/auth/refresh` エンドポイントはブラウザが自動的にCookieを送信するため、CSRF攻撃に対して脆弱である
- 悪意のあるサイトが `fetch('/api/auth/refresh', {method: 'POST', credentials: 'include'})` を呼び出すことで、被害者のリフレッシュトークンを使用した不正なトークン更新が可能
- JWTがlocalStorageに保存される間はXHR/FetchによるJWT付与はCSRFを防ぐが、Cookie経由の認証経路が残存する

**推奨対策**:
- `/api/auth/refresh` エンドポイントにCSRFトークンまたはOrigin/Refererヘッダー検証を追加する
- リフレッシュトークンCookieに `SameSite=Strict` または `SameSite=Lax` 属性を設定する（これが最もシンプルで効果的な対策）
- Stripe Webhookエンドポイント (`/api/webhooks/stripe`) には署名検証（`stripe-signature` ヘッダー）が必要（Stripeのベストプラクティス）。現設計に明示されていないため、実装時に確認が必要

---

### C-03: CORS設定の正規表現マッチング脆弱性

**該当箇所**: セクション 6.4 CORS設定

**問題**:
```javascript
const allowedOrigin = /\.nexamart\.com$/;
```

この正規表現は `nexamart.com` で終わるすべてのオリジンを許可してしまう。

**攻撃シナリオ**:
- `evilnexamart.com` → マッチする（攻撃者が登録可能なドメイン）
- `hack-nexamart.com` → マッチする
- `attacker.com/path?origin=test.nexamart.com` → オリジンヘッダーとしては機能しないが、実装の堅牢性が低い

さらに `Access-Control-Allow-Credentials: true` が設定されており、Cookieを含む認証済みクロスオリジンリクエストが悪意のあるドメインから可能となる。

**推奨対策**:
```javascript
const allowedOrigins = new Set([
  'https://nexamart.com',
  'https://admin.nexamart.com',
  // テナントサブドメインは動的検証が必要
]);

// テナントサブドメインの検証
const tenantSubdomainPattern = /^https:\/\/[a-z0-9-]+\.nexamart\.com$/;
if (allowedOrigins.has(origin) || tenantSubdomainPattern.test(origin)) {
  // テナントサブドメインの場合はDBでの存在確認も実施
}
```
- ホワイトリスト方式への変更
- テナントサブドメインはDBに登録された有効なテナントスラグとの照合を行う

---

## 重要な問題 (Significant)

### S-01: アクセストークンのlocalStorage保存によるXSS脆弱性

**該当箇所**: セクション 4.1 認証フロー

**問題**:
> アクセストークン: ブラウザの `localStorage` に保存

localStorageに保存されたJWTアクセストークンは、XSS（クロスサイトスクリプティング）攻撃によって窃取される可能性がある。

**影響分析**:
- 悪意のあるスクリプトが `localStorage.getItem('access_token')` を実行することで、被害者のトークンを取得可能
- 取得したトークンは攻撃者のサーバーに送信でき、60分間有効なセッションハイジャックが可能
- CSPにより一定程度のXSSリスクを軽減しているが、CSPバイパスの手法も存在する

**推奨対策**:
- アクセストークンも `HttpOnly` Cookieに保存する（CSRF対策と組み合わせて設計）
- またはメモリ内（React State/Context）にのみ保持し、ページリロード時はリフレッシュトークンで再発行する方式を採用する
- 後者の方式が近年のベストプラクティスとして推奨されている（Token in Memory + Refresh Cookie）

---

### S-02: アクセストークンの即時無効化不能

**該当箇所**: セクション 4.2 セッション管理

**問題**:
> 不正検知や権限変更が発生した場合のトークン即時無効化は、リフレッシュトークンの期限切れに依存する設計とする

不正検知（アカウント乗っ取りの疑い）や権限剥奪（テナントアカウントの停止等）が発生した際に、最大60分間有効なアクセストークンを無効化できない。

**影響分析**:
- マルチテナント環境での不正テナントへの対応が遅延する
- KYC審査で問題が発覚したテナントの操作を即時停止できない
- アカウント乗っ取りが検出されても、被害を最小化できない

**推奨対策**:
- Redisにアクセストークンのブラックリスト（JTI: JWT ID を使用）を実装し、強制無効化機能を追加する
- または、アクセストークンの有効期限を5〜15分に短縮し、リスク許容度を下げる
- 重要操作（テナント停止、権限変更）実施時は、対象ユーザーの全トークンを無効化するフローを設計する

---

### S-03: 認証エンドポイントのレート制限欠如

**該当箇所**: セクション 4.4 認証エンドポイント

**問題**:
設計書において、認証エンドポイントに対するレート制限が明示されていない。

**影響分析**:
- `/api/auth/login`: ブルートフォース攻撃・クレデンシャルスタッフィング攻撃に対して脆弱
- `/api/auth/register`: スパムアカウント大量作成が可能
- `/api/auth/refresh`: トークンリフレッシュエンドポイントへの過負荷攻撃が可能
- マルチテナント環境では、特定テナントを標的とした認証攻撃が他テナントに影響する可能性がある

**推奨対策**:
- Kong ゲートウェイレベルでのレート制限プラグインを設定する（例: `/api/auth/login` に対してIPアドレスごとに1分間10回まで）
- ログイン失敗時のアカウントロックアウト方針を設計する（例: 5回失敗後30分ロック）
- アカウント列挙攻撃対策として、存在しないメールアドレスでも同一の応答時間・メッセージを返す設計を明示する

---

### S-04: MIME型チェックのみによるファイルアップロード検証の不足

**該当箇所**: セクション 6.5 ファイルアップロード

**問題**:
> MIME型チェック: `Content-Type` ヘッダーによる判定のみ（拡張子検証なし）

`Content-Type` ヘッダーはクライアントが自由に設定できるため、悪意のあるファイル（実行可能ファイル、HTMLファイル等）を画像として偽装してアップロードできる。

**影響分析**:
- `image/jpeg` という `Content-Type` に `.html` ファイルをアップロードし、悪意のあるコンテンツをCloudFront経由で配信可能
- パブリックバケットに格納されるため、悪意のあるファイルが公開URLで提供される
- SVGファイルにJavaScriptを埋め込んだXSS攻撃が可能（SVGはXMLベースでスクリプトを含められる）

**推奨対策**:
- ファイルのマジックバイト（バイナリシグネチャ）による検証を実装する（`Content-Type` ではなくファイル内容に基づく判定）
- 許可する拡張子をホワイトリスト方式で制限する（`.jpg`, `.jpeg`, `.png`, `.webp` のみ等）
- 画像ファイルは再エンコード処理（ImageMagick等）を通じて、悪意のあるデータを除去する（Image Stripping）
- ウイルススキャンを「将来対応」ではなく計画に組み込む

---

### S-05: マルチテナントデータ分離のアプリケーション層依存

**該当箇所**: セクション 3.2 マルチテナント分離方式

**問題**:
> アプリケーション層でのクエリフィルタリングにより他テナントデータへのアクセスを防止する

テナント分離がアプリケーション層のクエリフィルタリングのみに依存しており、実装上の単一障害点となっている。

**影響分析**:
- SQLクエリに `WHERE tenant_id = ?` の追加を忘れた場合、全テナントのデータが露出する
- Prisma ORM使用でも、ミドルウェアが適用されていないクエリやraw SQLクエリでの漏洩リスクがある
- マルチテナント環境での情報漏洩は法的・契約上の重大な問題となる

**推奨対策**:
- Prisma Middlewareまたは Row Level Security (PostgreSQL RLS) を活用し、`tenant_id` フィルタリングをデータベース層で強制する
- コアAPIサービスの全クエリがテナントスコープで実行されることを保証するアーキテクチャパターン（例: TenantContext の強制注入）を設計書に明示する
- テナント分離のペネトレーションテストを定期的に実施する方針を追加する

---

## 中程度の問題 (Moderate)

### M-01: 個人情報のフィールドレベル暗号化の未実施

**該当箇所**: セクション 5.1 保存データの暗号化

**問題**:
> 氏名・住所・電話番号などの個人情報は平文で保存する。RDS暗号化により保護されているため、フィールドレベルでの追加暗号化は不要と判断する。

RDS TDEはディスク盗難・バックアップ漏洩に対する保護であり、DBへの不正アクセスや内部者脅威への保護ではない。

**推奨対策**:
- 高感度データ（氏名、住所、電話番号）のフィールドレベル暗号化（アプリケーション層）の採用を検討する
- 少なくとも、アクセスログの強化によりPIIへのアクセスを記録する

---

### M-02: PIIの保持期間・削除方針の未定義

**該当箇所**: セクション 5.3 個人情報（PII）管理

**問題**:
> データ保持期間・削除方針: 現時点では未定義

マーケットプレイスとして個人情報を扱う場合、GDPRや日本の個人情報保護法に基づく保持期間と削除権の実装が法的義務となる可能性がある。

**推奨対策**:
- 退会ユーザーのデータ削除またはアノニマイズの具体的なフローを設計する
- 法的保持義務（税務記録等）と個人情報削除要求の競合を設計書に明示する

---

### M-03: 署名付きURL有効期限の長さ

**該当箇所**: セクション 5.4 S3ストレージセキュリティ

**問題**:
> 請求書・契約書類: プライベートバケット（署名付きURL発行、有効期限7日）

7日間という有効期限は、機密書類へのアクセスURLとしては長すぎる。

**推奨対策**:
- 有効期限を1〜24時間に短縮する
- アクセス権の変更（テナント停止等）時に既存の署名付きURLを無効化できないため、有効期限の短縮が重要

---

### M-04: 監査ログの分離不足

**該当箇所**: セクション 8.4 監査ログ

**問題**:
> ログはアプリケーションの通常ログと同一のCloudWatch Logsストリームに出力する

セキュリティ監査ログをアプリケーションログと同一ストリームに混在させると、改ざんリスクと検索の困難さが生じる。

**推奨対策**:
- セキュリティ監査ログを専用のCloudWatch Logsストリームまたはロググループに分離する
- CloudTrailとの統合を検討する
- 監査ログへの書き込みのみを許可し、削除・変更を禁止するIAMポリシーを設計する
- 認証失敗ログについては、セクション 9.4 で言及されているが監査ログ設計（セクション 8.4）に明示的に含まれていない。一貫性を持たせる必要がある

---

### M-05: Stripe Webhookの署名検証が未明示

**該当箇所**: セクション 7.3 外部サービス連携

**問題**:
> Webhookエンドポイント `/api/webhooks/stripe` にてイベント受信後、支払いステータスを注文に反映する

Stripe Webhookの `stripe-signature` ヘッダーによるペイロード署名検証が設計書に明示されていない。

**影響分析**:
- 署名検証なしの場合、攻撃者が偽のWebhookリクエストを送信し、支払い未完了の注文を「支払い完了」に変更できる
- 商品の不正取得（詐欺）に直結する重大な業務リスク

**推奨対策**:
- Stripe Webhook受信時の署名検証（`stripe.webhooks.constructEvent()`）を設計書に明示する
- `/api/webhooks/stripe` に対してStripeのIPアドレス範囲からのリクエストのみを許可するIPフィルタリングを追加する

---

### M-06: 依存ライブラリの既知脆弱性

**該当箇所**: セクション 8.2 依存ライブラリ管理

**問題**:
> `multer@1.4.4` を使用（マルチパートフォーム処理）

`multer@1.4.4` には既知の脆弱性（CVE-2022-24434等）が報告されており、現在の最新版は 1.4.5-lts.1 以降が推奨されている。また、四半期ごとのセキュリティアップデート確認は本番環境では頻度が低い。

**推奨対策**:
- `multer` を最新の安全なバージョンに更新する
- セキュリティアップデートの適用頻度を月次以上に引き上げる
- `npm audit` または Dependabot/Snyk による継続的な脆弱性監視を導入する

---

## 軽微な問題 / 改善提案 (Minor)

### N-01: `platform_admin` への過剰権限集中

`platform_admin` ロールが全テナント・全リソースへの読み書き権限を持つ設計は、内部者脅威リスクを高める。最小権限原則の観点から、管理者ロールをより細分化することを検討する（例: `platform_readonly_admin`, `platform_kyc_admin` 等）。

### N-02: ECS間通信の暗号化の検討

セクション 5.2 では CloudFront → ECS 間はHTTPSとしているが、マイクロサービス間（認証サービス ↔ コアAPIサービス ↔ 注文/商品/テナント管理サービス）の通信暗号化が設計書に明示されていない。AWS App Mesh または mTLS の採用を検討する。

### N-03: リフレッシュトークンのローテーション

現設計にリフレッシュトークンローテーション（使用するたびに新しいトークンを発行し、古いトークンを無効化する）が明示されていない。トークン窃取の検出・無効化に有効なため、実装を推奨する。

---

## 設計上の評価ポイント

以下の点は適切に設計されている:

- Stripe への決済情報委譲によるPCI DSS負荷の軽減
- bcrypt（cost 12）による適切なパスワードハッシュ化
- AWS Secrets Manager の使用（本番シークレットのリポジトリ格納を除く）
- Prisma ORM によるパラメータ化クエリでのSQLインジェクション対策
- DOMPurify によるリッチテキストサニタイズ
- CSP設定の実装
- ログアウト時のリフレッシュトークンブラックリスト化
- ECSのプライベートサブネット配置
- 管理コンソールのVPN必須化

---

## 優先対応サマリ

| 優先度 | ID | 問題 | 推奨アクション |
|--------|-----|------|--------------|
| Critical | C-01 | 本番シークレットのリポジトリ格納 | 即時削除・Secrets Manager統一 |
| Critical | C-02 | JWT単独CSRF対策の不完全性 | SameSite Cookie + Refresh endpoint CSRF対策 |
| Critical | C-03 | CORS正規表現脆弱性 | ホワイトリスト方式に変更 |
| Significant | S-01 | アクセストークンのlocalStorage保存 | HttpOnly Cookie またはメモリ保持に変更 |
| Significant | S-02 | アクセストークン即時無効化不能 | JTIブラックリスト実装 |
| Significant | S-03 | 認証エンドポイントのレート制限欠如 | Kong プラグインでレート制限設定 |
| Significant | S-04 | ファイルアップロード検証の不足 | マジックバイト検証・再エンコード処理 |
| Significant | S-05 | マルチテナント分離のアプリケーション層依存 | RLS または Prisma Middleware の強制適用 |
