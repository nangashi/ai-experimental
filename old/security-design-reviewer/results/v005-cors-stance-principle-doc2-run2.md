# Security Design Review: Nexamart プラットフォーム システム設計書 v1.4.0

---

## Critical Issues

### C-01: CORS正規表現サフィックスマッチによる攻撃者制御ドメインのバイパス（§6.4）

**問題の詳細:**
CORS設定において `/\.nexamart\.com$/` という正規表現によるサフィックスマッチを使用している。この実装は `evil.nexamart.com` のような攻撃者が登録したサブドメイン、または `attackernexamart.com` のような文字列末尾が一致するドメインからのリクエストを許可してしまう。

具体的には、正規表現 `/\.nexamart\.com$/` は以下のドメインにマッチする:
- `evil.nexamart.com`（攻撃者が取得した任意のサブドメイン、またはサブドメインテイクアウト攻撃で乗っ取ったサブドメイン）
- `*.nexamart.com` 全体が対象となるため、テナントサブドメイン（`{tenant-slug}.nexamart.com`）が悪意あるコンテンツを配信する状態になった場合、クロステナント攻撃の踏み台になる

さらに `Access-Control-Allow-Credentials: true` が設定されているため、マッチしたオリジンのページは認証済みユーザーの認証情報（Cookie等）を含むクロスオリジンリクエストを送信できる。

**危険な構文の特定:**
- `allowedOrigin.test(origin)` — origin文字列の末尾一致（サフィックスマッチ）であり、ドメイン境界の検証を行っていない
- `reply.header('Access-Control-Allow-Credentials', 'true')` — credentialedリクエストを許可することで、バイパス成功時の影響を最大化している

**影響:**
攻撃者が制御するドメインから正規ユーザーのセッション情報を含むAPIリクエストを発行でき、他テナントのデータ読み取り・注文操作・個人情報アクセスが可能になる。マルチテナント環境であるため、テナント間データ漏洩の経路となる。

**対策:**
許可オリジンを明示的な文字列セットで管理する。正規表現や部分マッチは使用しない。

```javascript
const ALLOWED_ORIGINS = new Set([
  'https://admin.nexamart.com',
  // テナントサブドメインは動的に解決する場合、DBからの正式リストと照合する
]);

function isAllowedOrigin(origin) {
  // 完全一致のみ許可
  if (ALLOWED_ORIGINS.has(origin)) return true;
  // テナントサブドメインはDBのテナントスラッグリストと完全一致で検証
  return isRegisteredTenantOrigin(origin);
}
```

---

### C-02: 本番シークレットのリポジトリ保存（§8.1）

**問題の詳細:**
`config/secrets.prod.yaml` に本番環境のシークレット値を記録し、「アクセス制限を設けたうえで」リポジトリに含めることが設計に明記されている。JWT署名鍵・DBパスワード・外部APIキーがリポジトリに存在する場合、以下のリスクが生じる:

- Gitの履歴から削除済みシークレットが復元される
- リポジトリアクセス権限を持つ全員（開発者・CI/CDシステム・GitHub Actions等）がシークレットにアクセスできる
- リポジトリが意図せず公開された場合の即時漏洩

AWS Secrets Managerを既に利用しているにもかかわらず、ファイルによる二重管理を行うことは冗長かつリスクの高い設計である。

**影響:**
JWT署名鍵の漏洩により任意のユーザーになりすました偽JWTの生成が可能。DBパスワードの漏洩により全テナントデータへの直接アクセスが可能。

**対策:**
- `config/secrets.prod.yaml` をリポジトリから除外し、git履歴からも削除する（`git filter-repo` 等）
- 参照が必要な場合はAWS Secrets Managerコンソールへのアクセスで代替する
- `secrets.prod.yaml` を `.gitignore` に追加し、その存在自体をCIで検出・ブロックする

---

### C-03: アクセストークンのlocalStorage保存によるXSS経由の窃取（§4.1）

**問題の詳細:**
アクセストークン（JWT、有効期限60分）をブラウザの `localStorage` に保存している。`localStorage` はJavaScriptから読み取り可能であるため、XSS攻撃が成功した場合にトークンが窃取される。

CSPで `default-src 'self'` が設定されているが、CDN配信のサードパーティスクリプト、テナントが登録した商品説明（DOMPurifyでサニタイズ済み）のバイパス、またはNext.jsのバンドルに含まれるサードパーティライブラリの脆弱性によってXSSが発生した場合、トークンが窃取される。

**影響:**
トークン窃取後、攻撃者はAPIをフルに操作できる。アクセストークンのサーバーサイドブラックリストが存在しないため（§4.2）、窃取後60分間は無効化不可能。

**対策:**
- アクセストークンを `HttpOnly` Cookie に移行し、JavaScriptからアクセス不能にする
- または、メモリ内（JavaScriptの変数）でのみ保持し、ページリロード時はリフレッシュトークンで再発行する
- いずれの場合もCSRF対策の強化が必要（C-04参照）

---

### C-04: CSRFトークン未設計・JWT単独依存のCSRF防御（§6.3）

**問題の詳細:**
CSRF対策として「Authorizationヘッダー経由のJWT」のみを採用し、CSRFトークンおよびSameSite Cookie属性の設計が存在しない。この設計は以下の条件で脆弱となる:

- アクセストークンをCookieに移行した場合（C-03の対策実施時）、CSRF攻撃が成功する
- リフレッシュトークンは `HttpOnly` Cookie に保存されているが、リフレッシュエンドポイント（`POST /api/auth/refresh`）に対するCSRFが可能であり、攻撃者がリフレッシュを強制してトークンをローテーションさせることができる

**層の欠如:**
「JWTのみによるCSRF防御」という単一層の防御は、将来のアーキテクチャ変更（Cookie化）に対して脆弱であり、Reporting Rule（Defense Layer Separation）に照らして独立した欠陥として報告する。

**対策:**
- リフレッシュトークンCookieに `SameSite=Strict` または `SameSite=Lax` を設定する
- state-changingなAPIに対してCSRFトークン（Double Submit Cookie方式等）を追加設計する

---

## Significant Issues

### S-01: テナント分離がアプリケーション層クエリフィルタリングのみに依存（§3.2）

**問題の詳細:**
マルチテナントデータ分離は「アプリケーション層でのクエリフィルタリング」のみで実現している。全テーブルに `tenant_id` を持つ共有スキーマ方式において、単一のSQLクエリでの `WHERE tenant_id = ?` 漏れが全テナントデータ漏洩に直結する。

設計書には以下のリスク緩和策が記述されていない:
- Row-Level Security（RLS）によるDB層でのテナント分離
- ORMレベルでのテナントスコープ強制（グローバルスコープ等）
- テナント境界を超えたアクセスの監査ログ

**影響:**
バグ1件でクロステナントデータアクセスが発生するシングルポイントオブフェイラー設計。Nexamartには個人情報・注文情報・決済関連データが含まれるため、影響は広範。

**対策:**
PostgreSQL Row-Level Security（RLS）をアプリケーション層フィルタリングの補完として設計する。すべてのクエリが通過するミドルウェア層でテナントスコープを強制する設計を明記する。

---

### S-02: X-Tenant-IDヘッダーの信頼設計と内部ネットワークからの偽装リスク（§3.2）

**問題の詳細:**
コアAPIサービスは Kong ゲートウェイが付与する `X-Tenant-ID` ヘッダーを「信頼済みの値」として処理する。内部ネットワーク（プライベートサブネット）からのリクエストがゲートウェイを経由せずコアAPIサービスに直接到達した場合、任意の `X-Tenant-ID` を指定してデータアクセスが可能になる。

サービス間通信においても同様のリスクが存在する（ECSコンテナ間通信でゲートウェイをバイパスする構成が可能）。

**対策:**
- コアAPIサービスがKong経由リクエストであることを検証する仕組みを設計する（例: Kong署名ヘッダー、mTLS）
- Security Groupで直接アクセスを制限する設計を明記する

---

### S-03: ファイルアップロードのContent-Typeヘッダーのみによるファイル種別検証（§6.5）

**問題の詳細:**
ファイルアップロードのMIME型検証を `Content-Type` ヘッダーのみで行っており、拡張子検証・マジックバイト検証・ウイルススキャンが存在しない。

Presigned URL経由のクライアント直接アップロードでは、攻撃者が `Content-Type: image/jpeg` を指定しながら実際にはPHPファイルやHTMLファイルをアップロードできる（S3はContent-Typeをそのまま信頼する）。

パブリックバケット（テナントロゴ・商品画像）経由でHTMLファイルをホストした場合、CloudFrontからのコンテンツ配信によりフィッシング・ドライブバイダウンロードに利用される。

**multerのバージョンについて:**
`multer@1.4.4` はReDoS脆弱性（CVE-2022-24434）の影響を受けるバージョンの可能性がある。最新の `@1.4.5-lts.1` または `2.x` への更新を検討すること。

**対策:**
- S3 Object Lambdaまたはアップロード後のLambdaトリガーでマジックバイト検証を実装する
- `Content-Disposition` にファイル名を含め、拡張子をホワイトリスト検証する
- AWS Security Hub + Amazon Guardduty でS3の不審ファイルを検出する設計を追加する

---

### S-04: Stripe Webhookの署名検証設計の欠如（§7.3）

**問題の詳細:**
`/api/webhooks/stripe` エンドポイントでStripe Webhookイベントを受信し、支払いステータスを注文に反映する設計が示されているが、Webhookの正当性検証（Stripe署名検証: `stripe-signature` ヘッダーの検証）についての言及がない。

署名検証なしの場合、攻撃者が偽のPaymentIntentSucceededイベントを送信して未払いの注文を支払い済みとしてマークできる。

**対策:**
Stripe Webhook署名検証（`stripe.webhooks.constructEvent()`）の設計を明記する。

---

### S-05: アクセストークンの即時無効化不能（§4.2）

**問題の詳細:**
アクセストークン（60分有効）にはサーバーサイドのブラックリストが存在せず、権限変更・アカウント停止・不正検知時にトークンを即時無効化できない。

テナントスタッフのロール変更、不正アクセス検知後の強制ログアウトが60分間有効にならない設計は、マルチテナント環境では特に高リスクである。

**対策:**
- アクセストークンの有効期限を5〜15分に短縮し、リフレッシュトークンで継続セッションを維持する
- 高権限操作（テナント停止・ロール変更等）発生時にRedisブラックリストへの追加を設計する

---

## Moderate Issues

### M-01: 認証エンドポイントへのレート制限設計の欠如（§4.4）

**問題の詳細:**
ログインエンドポイント（`POST /api/auth/login`）、パスワードリセット、ユーザー登録エンドポイントに対するレート制限設計が記述されていない。ブルートフォース攻撃・クレデンシャルスタッフィング攻撃への耐性が不明。

**対策:**
Kongゲートウェイのレート制限プラグインで認証エンドポイントに対して IPおよびアカウント単位のレート制限を設計する（例: 5回/分/IP）。

---

### M-02: 監査ログへの認証失敗・権限変更イベント記録の設計不整合（§8.4 vs §9.4）

**問題の詳細:**
§9.4に「認証失敗・権限変更等の重要イベントをアプリケーションログに記録する」と記述されているが、§8.4の監査ログ定義には認証失敗・権限変更が含まれていない。また「アプリケーションの通常ログと同一のCloudWatch Logsストリームに出力する」という設計は、監査ログと運用ログが混在し、改ざん・削除への耐性が低い。

**対策:**
- 監査ログを専用ストリーム（またはCloudTrail等の改ざん耐性のあるサービス）に分離する
- §8.4の対象イベントリストに認証失敗・権限変更・センシティブデータアクセスを追加する
- 参照整合性: §8.4は「セキュリティ要件（7.4節）」を参照しているが、設計書に7.4節が存在しない（欠落）

---

### M-03: 個人情報フィールドレベル暗号化の省略判断（§5.2）

**問題の詳細:**
氏名・住所・電話番号を平文で保存し、「RDS TDEで保護されているため追加暗号化不要」と判断している。RDS TDEはディスク盗難・バックアップ漏洩には有効だが、以下のシナリオには無効である:

- DBユーザー認証情報の漏洩によるSQLクエリでのデータ取得
- アプリケーション層のSQLインジェクション（Prismaのrawクエリ使用時）
- 内部不正によるデータ参照

マルチテナントプラットフォームで複数テナントの顧客個人情報を扱う場合、フィールドレベル暗号化は一般的なセキュリティ要件である。

**対策:**
少なくとも電話番号・住所フィールドにAES-256によるフィールドレベル暗号化を設計し、鍵管理をKMSと統合する。

---

### M-04: PII保持期間・削除ポリシーの未定義（§5.3）

**問題の詳細:**
「データ保持期間・削除方針は現時点では未定義」と明記されており、退会後のデータ削除フローが存在しない。マルチテナント環境で買い手の個人情報（氏名・住所・メールアドレス・電話番号）を無期限に保持することは、GDPRや個人情報保護法上のリスクとなる。

**対策:**
退会時のデータ削除または匿名化フローを設計し、テナント単位でのデータ保持期間を定義する。

---

### M-05: 商品API更新・削除エンドポイントのリソース所有権検証（§7.1）

**問題の詳細:**
`PUT /api/products/:id` および `DELETE /api/products/:id` は `tenant_admin` または `tenant_staff` が実行可能であるが、対象商品が「自テナントの商品」であることの検証設計が明記されていない。

JWTのテナントIDと `X-Tenant-ID` の照合（§4.3）は設計されているが、商品の `tenant_id` と実行者のテナントIDの照合がアプリケーションレベルで明示的に設計されているかが不明。

**対策:**
各APIハンドラで「リソースの `tenant_id` == リクエスト者のテナントID」を検証する設計を明記する。

---

## Minor Improvements

### N-01: 署名付きURL有効期限7日間の長さ（§5.4）

請求書・契約書類の署名付きURL有効期限が7日間と長い。署名付きURLはURLを知る者誰でもアクセスできるため、短い有効期限（1時間〜24時間）が推奨される。

---

### N-02: KMSキーローテーション周期（§5.1）

AWS KMSの年1回キーローテーションは最小推奨値。PCI DSS等の規制要件がある場合は年次で不足する可能性がある。自動ローテーション（AWS KMSの自動年次ローテーション機能）の使用を明記する。

---

### N-03: CSPの`default-src 'self'`のみでは不十分な可能性（§6.2）

CloudFrontでCDN配信を行い、Stripeの決済フォームを組み込む場合、`script-src 'self' https://js.stripe.com` 等の明示的なCSPディレクティブが必要。`default-src 'self'` のみでは実際の運用時にCSP違反が多発し、緩和設定へのプレッシャーが生じる。

---

## Positive Aspects

- bcrypt cost factor 12の採用（§4.1）: 適切なパスワードハッシュ強度
- リフレッシュトークンのHTTP-Only Cookie保存（§4.1）: XSS耐性
- Prisma ORMによるパラメータ化クエリ（§6.1）: SQLインジェクション対策
- クレジットカード情報のStripe委譲（§5.1）: PCI DSS対象範囲の最小化
- AWS Secrets Managerによるシークレット管理（§8.1）: 適切な基盤
- ECSプライベートサブネット配置（§8.3）: ネットワーク分離の基本設計
