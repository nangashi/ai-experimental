---
source: /home/toyama-ryosuke/ghq/github.com/nangashi/ai-experimental/docs/knowledge/changeability-design-principles.md
extracted: 2026-02-16
med_version: 3
passed: 12
total: 25
---

# Instruction Extract: changeability-design-principles

## KE-001: 値オブジェクトの適用条件を明示する → PASS

### フィルタ評価
- 再利用価値: ○ — 値オブジェクト判断は頻出シーン
- 遵守改善効果: 高 — ソース文書に過剰適用リスクが明記されている（AI適用時の注意セクション）
- 行動変容: ○ — classitis防止の具体的条件分岐を提供
- 確度: ○ — 実務パターンと制限事項が記録されている
- 削除テスト: YES — 条件なしでは過剰適用が起きる

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: バリデーションやドメインロジックを持つ値を表現する場合
- **action**: 値にバリデーションルール、計算ロジック、フォーマット変換などのドメインロジックが存在する場合のみ値オブジェクトとして専用クラスを作成する。バリデーションもロジックもない単純な値（ID文字列、フラグ値等）にはプリミティブ型またはtype aliasを使用する。
- **rationale**: Rich Hickeyは「値をカスタムクラスで囲むことは汎用的なデータ操作を不可能にする」と指摘。John Ousterhoutは「浅いモジュール」になる危険を、Kent Beckは「最小要素の規則に反する」と警告している。ソース文書のAI適用時の注意セクションにclassitis（過剰適用の典型例）として明記されている。
- **conditions**: プロトタイプや小規模ツール。現代言語のvalue class/newtypeで実行時オーバーヘッドを除去できる場合は適用コストが低い。

---

## KE-002: 完全コンストラクタの技術的例外を認識する → PASS

### フィルタ評価
- 再利用価値: ○ — ORM/DI環境での設計判断に頻出
- 遵守改善効果: 高 — AIは「完全コンストラクタは常に適用すべき」と過剰適用しやすい
- 行動変容: ○ — 例外を認めるべき条件を明示
- 確度: ○ — ORM/DI制約は実務での確立された例外
- 削除テスト: YES — 技術制約による例外を判断できない

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: ドメインオブジェクトの構築設計
- **action**: オブジェクトはコンストラクタで全フィールドを初期化しバリデーションを通過した状態でのみ生成可能にする。ただしORM/DIフレームワークが技術的に引数なしコンストラクタを要求する場合は例外として許容し、その理由をコメントで記録する。パラメータ爆発の場合はビルダーパターンを併用する。
- **rationale**: Eric EvansがDDDでアグリゲートの不変条件維持を重視。ORMのリフレクション、デシリアライゼーションでは技術的に完全コンストラクタが不可能な場合がある。
- **conditions**: ORM/DI等のフレームワーク制約。パラメータが多数でビルダーパターンを使用する場合。

---

## KE-003: 不変性の性能例外を計測ベースで判断する → PASS

### フィルタ評価
- 再利用価値: ○ — 性能最適化判断のベースライン
- 遵守改善効果: 高 — AIは「性能のため」を理由に可変設計を安易に許容しやすい
- 行動変容: ○ — 「計測に基づいて判断」という条件を追加
- 確度: ○ — 不変性の普遍的支持は記録済み
- 削除テスト: YES — 計測不要で可変設計を選ぶリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: データ構造の可変/不変選択
- **action**: フィールド・変数はデフォルトで不変にする。性能が最優先の領域（大量データのバッチ処理、ゲームエンジン等）で可変データ構造を選択する場合は、必ず計測に基づいて判断する。
- **rationale**: Rich Hickey、Eric Evans、Joshua Blochなどほぼ全ての設計思想家が不変性を支持する稀有な合意点。並行処理の安全性、予測可能性、デバッグ容易性で優位。
- **conditions**: パフォーマンスクリティカルな局所的処理で、計測により性能差が実証された場合のみ。

---

## KE-004: データクラスの適用範囲をドメイン層に限定する → PASS

### フィルタ評価
- 再利用価値: ○ — データクラス判断は頻出
- 遵守改善効果: 高 — AIはDTO/イベント/コマンドにも「低凝集」判定を誤適用しやすい
- 行動変容: ○ — 適用層を明示的に制限
- 確度: ○ — 層分離による適用境界は確立された設計原則
- 削除テスト: YES — 層を区別せず一律適用するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: データのみを保持しロジックを持たないクラスの評価
- **action**: ドメイン層においてデータのみを保持しロジックを持たないクラスは低凝集の兆候として扱う。DTO、イベント、コマンド、APIレスポンス等のデータ転送目的クラスは対象外とする。関数型パラダイムを採用している場合も対象外とする。
- **rationale**: Martin Fowlerも「Data Class」をコードスメルとして認めるが、Rich Hickeyは「データとロジックの分離」を基本原則とし、現代言語（Kotlinのdata class、Java record）もデータ構造の明示的表現を支持している。適用層の区別が重要。
- **conditions**: DTO・イベント・コマンド等のデータ転送目的クラス。関数型パラダイム採用時。インフラ層のデータ構造。

---

## KE-005: 副作用を持つstaticメソッドのみを排除対象とする → PASS

### フィルタ評価
- 再利用価値: ○ — staticメソッド設計の頻出判断
- 遵守改善効果: 高 — AIは純粋関数のstaticも一律排除しやすい
- 行動変容: ○ — 純粋関数のstatic許容を明示
- 確度: ○ — Martin Fowler、Robert C. Martinの見解が記録されている
- 削除テスト: YES — 純粋関数staticまで排除するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: staticメソッドの設計判断
- **action**: 副作用（DB書き込み、ファイルI/O、外部API呼び出し等）や外部状態への依存を持つstaticメソッドを避ける。入力のみに依存し副作用を持たない純粋関数は、static/パッケージレベル関数として正当である。
- **rationale**: Martin Fowlerはstaticメソッドの主な問題をポリモーフィズム不可（テスト時のスタブ差し替え困難）と指摘。Robert C. Martinは「ポリモーフィックである可能性がない場合」はstaticが適切と認める。純粋関数は副作用も外部依存もないため問題にならない。
- **conditions**: 純粋関数（副作用なし、外部状態非依存）。数学的計算、型変換、フォーマット処理。関数型プログラミングやGoのパッケージレベル関数。

---

## KE-006: デメテルの法則の適用除外を明示する → PASS

### フィルタ評価
- 再利用価値: ○ — Fluent API設計での頻出判断
- 遵守改善効果: 高 — AIはFluent APIのメソッドチェーンも違反と誤検出しやすい
- 行動変容: ○ — 同一オブジェクトへの操作は除外すると明示
- 確度: ○ — Fluent APIとビルダーパターンの除外は確立された解釈
- 削除テスト: YES — 正当なメソッドチェーンを違反と判定するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: オブジェクト間のメッセージパッシング設計
- **action**: オブジェクトは直接の協力者のメソッドのみを呼び出す。`a.getB().getC().doSomething()`のような3段階以上のメソッドチェーンは内部構造への依存を示す違反の兆候。ただしFluent APIやビルダーパターンの同一オブジェクトへの操作は除外する。
- **rationale**: 内部構造への依存を制限することで変更の波及を局所化する。Fluent APIは同一オブジェクトへの連続操作であり、デメテルの法則違反ではない。過度な適用は委譲メソッドの増殖を招き、John Ousterhoutの「浅いモジュール」問題になりうる。
- **conditions**: Fluent API / ビルダーパターン。ナビゲーション的アクセスが言語の慣習として確立している場合（例: RailsのActiveRecord関連）。

---

## KE-007: CQSの正当な例外を許容する → PASS

### フィルタ評価
- 再利用価値: ○ — CQS設計判断は頻出
- 遵守改善効果: 高 — AIはCQSを厳格に適用し、正当な例外も違反扱いしやすい
- 行動変容: ○ — 並行処理のアトミック操作など正当な例外を明示
- 確度: ○ — Martin Fowlerのpop()例、並行処理のアトミック操作は確立された例外
- 削除テスト: YES — 正当な例外を違反と判定し過剰な分割を招くリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: メソッドの状態変更と値返却の分離判断
- **action**: メソッドはデフォルトで「状態を変更するコマンド」か「値を返すクエリ」のどちらか一方のみを行う。ただしアトミック操作（`compareAndSwap`, `getAndIncrement`, `putIfAbsent`）、自然なAPI（`stack.pop()`）、分割が呼び出し側の複雑さを著しく増す場合は例外として許容し理由を記録する。
- **rationale**: Bertrand Meyerが提唱し、Martin Fowlerも「非常に有用な原則」と評価。ただしFowlerは「`stack.pop()`のようにクエリとコマンドを一体にしたほうが著しく便利な場合がある」と指摘。並行処理のアトミック操作は不可欠。
- **conditions**: アトミック操作（並行処理）。pop()のような自然なAPI。分割が呼び出し側の複雑さを著しく増す場合。

---

## KE-008: 条件分岐の構造化に閾値条件を設定する → PASS

### フィルタ評価
- 再利用価値: ○ — リファクタリング判断の頻出シーン
- 遵守改善効果: 高 — ソース文書に過剰適用が明記されている（AI適用時の注意セクション）
- 行動変容: ○ — 「2ファイル以上」という具体的閾値を提供
- 確度: ○ — 実務パターンとExpression Problemが記録されている
- 削除テスト: YES — 閾値なしでは単一箇所の分岐にもクラス階層を導入するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: 同一条件の分岐が複数箇所に散在している場合
- **action**: 同一条件の分岐（型判定、ステータス判定等）が2ファイル以上に散在している場合、ポリモーフィズムまたはパターンマッチで構造化する。単一箇所の単純な分岐には適用しない。
- **rationale**: Martin Fowlerが条件分岐が複数メソッドに散在している場合のリファクタリング技法として紹介。Expression Problemにより、型の追加より振る舞いの追加が頻繁な場合は逆効果。John Ousterhoutは単純な分岐1つのためにクラス階層を作るのは浅いモジュールの典型と指摘。ソース文書のAI適用時の注意セクションに過剰適用の典型例として記録されている。
- **conditions**: 単一箇所の単純な分岐。型の追加より振る舞いの追加が頻繁な場合。パターンマッチで網羅性を検証できる言語環境。

---

## KE-009: ファーストクラスコレクションの適用条件を明示する → PASS

### フィルタ評価
- 再利用価値: ○ — コレクション設計の頻出判断
- 遵守改善効果: 高 — ソース文書に過剰適用が明記されている（AI適用時の注意セクション）
- 行動変容: ○ — ビジネスルールの有無で判断する条件を明示
- 確度: ○ — 実務パターンと制限事項が記録されている
- 削除テスト: YES — ビジネスルールのないコレクションにもラッパーを生成するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: ビジネスルールを持つコレクションの設計
- **action**: コレクションにビジネスルール（最大件数制約、要素の重複禁止、合計値の計算等）や不変条件が存在する場合、専用クラスにカプセル化する。ビジネスルールのない単純なコレクションには適用しない。
- **rationale**: コレクション操作のビジネスルールが1箇所に集約される。Rich Hickeyは「コレクションを専用クラスで包むことはmap/filter等の標準操作を不可能にする」と指摘。John Ousterhoutは「ビジネスルールを持たないコレクションのラッパーは浅いモジュールの典型例」と警告。ソース文書のAI適用時の注意セクションに過剰適用が記録されている。
- **conditions**: ビジネスルールのない単純なコレクション。言語のコレクションAPIで十分に表現できる場合。

---

## KE-010: サブクラスの都合でスーパークラスを変更しない → PASS

### フィルタ評価
- 再利用価値: ○ — 継承設計の頻出シーン
- 遵守改善効果: 高 — AIはサブクラス追加時にスーパークラス修正を提案しやすい
- 行動変容: ○ — スーパークラス修正を禁止する明確な指示
- 確度: ○ — 開放閉鎖原則の具体的適用として確立
- 削除テスト: YES — サブクラスの要求でスーパークラスを変更するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: 継承関係の設計
- **action**: 継承関係において、子クラスの要求で親クラスを変更してはならない。サブクラスの追加がスーパークラスの修正を必要としない安定したインターフェースを設計する。
- **rationale**: 開放閉鎖原則（OCP）の具体的適用。サブクラスの追加によるスーパークラスの変更は、他のサブクラスに予期しない影響を波及させる。
- **conditions**: 過度に安定性を求めるとスーパークラスが過剰に抽象的になる場合がある。そもそも継承よりコンポジションを優先すべき場面が多い（GoF）。

---

## KE-011: 共通化判断を目的の一致に基づかせる → PASS

### フィルタ評価
- 再利用価値: ○ — 共通化判断は頻出
- 遵守改善効果: 高 — AIはコードの見た目の類似で共通化しやすい
- 行動変容: ○ — 「目的の一致」を判断基準として明示
- 確度: ○ — Sandi Metz、Dan Abramov、DRY原典著者の見解が記録されている
- 削除テスト: YES — 見た目の類似で共通化するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: コードの共通化・再利用判断
- **action**: コードの見た目が似ていても、ビジネス上の目的が異なるなら共通化しない。共通化の判断は「コードの見た目」ではなく「意図の一致」に基づく。目的が同じと判断した場合は共通化を推奨する。
- **rationale**: Sandi Metzは「間違った抽象は重複より遥かにコストが高い」と述べた。Dan Abramovも安易な共通化が将来の変更を困難にする実体験を紹介。Dave Thomas & Andy Hunt（DRY原典著者）もDRYは見た目の類似ではなく知識の重複を対象とすると明言。
- **conditions**: 「目的が同じかどうか」の判断基準が曖昧になりがち。チーム内で「目的」の定義が共有されていない場合、実務で適用困難。判断を誤ると正当な共通化を見逃す可能性もある。

---

## KE-012: 目的駆動命名をドメイン層に限定する → PASS

### フィルタ評価
- 再利用価値: ○ — 命名判断は頻出
- 遵守改善効果: 高 — AIはインフラ層にも目的駆動命名を適用しやすい
- 行動変容: ○ — 適用層を明示的に制限
- 確度: ○ — Eric Evans、Martin Fowler、Kent Beckの見解が記録されている
- 削除テスト: YES — 層を区別せず一律適用するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: ドメイン層のクラス名・メソッド名の命名
- **action**: ドメイン層のクラス名・メソッド名は、技術的な「何であるか」ではなく、ビジネス上の「何のためか」で命名する。「商品」のような存在ベースの汎用名を避け、「予約品」「出品物」「発送品」のように目的ごとに分離する。インフラ層やフレームワーク連携のコードでは技術的な命名（`UserRepository`, `HttpClient`）が適切。
- **rationale**: Eric Evans（DDD/ユビキタス言語）、Martin Fowler（Intention Revealing Name）、Kent Beck（Simple Design — Reveals Intention）のいずれとも整合。命名が適切であれば、クラスの責務が自然に分離される。Evansは「命名はドメインエキスパートとの対話から生まれるべき」としている。
- **conditions**: インフラ層、技術的ユーティリティ、フレームワーク連携コード。

---

## KE-013: 役割駆動設計の適用規模を明示する → PASS

### フィルタ評価
- 再利用価値: ○ — モデル分割判断のベースライン
- 遵守改善効果: 高 — ソース文書に過剰適用が明記されている（AI適用時の注意セクション）
- 行動変容: ○ — 「大規模ドメイン」という適用条件を明示
- 確度: ○ — Eric EvansのBounded Context、YAGNIの視点が記録されている
- 削除テスト: YES — 小規模プロジェクトでも過剰分割するリスクがある

### 抽出内容
- **use-when**: Generating or editing code (self-check for dead code accumulation and adjacent code alteration)
- **scope**: 大規模ドメインでのモデル分割判断
- **action**: 大規模ドメインで、同一エンティティの異なる役割が明確に識別でき、役割間の振る舞いが異なる場合に限り、役割ごとにモデルを分割する。小規模プロジェクトでは1つのモデルで十分。
- **rationale**: Eric Evans（DDD/Bounded Context）の「大規模システムで単一の統一モデルを持つことに反対」する方針と整合。John Ousterhoutは「過度な分割は浅いモジュールの増殖を招く」と警告。YAGNIは「将来のための分割は実際に複雑さが正当化するレベルに達してから」と主張。ソース文書のAI適用時の注意セクションに過剰適用が記録されている。
- **conditions**: 小規模プロジェクト。役割間で共有するデータが多く、分割コストが利益を上回る場合。CRUDアプリやマイクロサービスの1サービス。

---

## KE-014: 値オブジェクト → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計パターンの基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、適用条件の遵守改善はKE-001で抽出済み
- 行動変容: × — KE-001の適用条件がないと過剰適用になる
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-001の適用条件がより重要
- **除外理由**: KE-001で適用条件込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-015: 完全コンストラクタ → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、技術的例外の判断はKE-002で抽出済み
- 行動変容: × — KE-002の例外条件がないと柔軟性を欠く
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-002の例外条件がより重要
- **除外理由**: KE-002で技術的例外込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-016: 不変性優先 → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、性能例外の計測ベース判断はKE-003で抽出済み
- 行動変容: × — KE-003の計測条件がないと安易な可変設計を許容
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-003の計測条件がより重要
- **除外理由**: KE-003で性能例外の計測条件込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-017: データクラス=低凝集の兆候 → FILTERED

### フィルタ評価
- 再利用価値: ○ — コードスメルの基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、適用層の限定はKE-004で抽出済み
- 行動変容: × — KE-004の層限定がないと誤適用
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-004の層限定がより重要
- **除外理由**: KE-004で適用層の限定込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-018: null可能性の型による安全管理 → FILTERED

### フィルタ評価
- 再利用価値: ○ — 型安全の基本原則
- 遵守改善効果: 低 — AIは型システムのnull安全サポートを理解している
- 行動変容: × — AIは言語の型システムに従ってコードを生成する
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — 指示なしでもAIは型システムに従う
- **除外理由**: AIのデフォルト判断と同方向。指示なしでも型システムに従ってコードを生成する。

---

## KE-019: 副作用を持つstaticメソッドの排除 → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、純粋関数の除外はKE-005で抽出済み
- 行動変容: × — KE-005の適用条件がないと過剰適用
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-005の適用条件がより重要
- **除外理由**: KE-005で純粋関数の除外込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-020: デメテルの法則 → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、Fluent API除外はKE-006で抽出済み
- 行動変容: × — KE-006の除外条件がないと誤検出
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-006の除外条件がより重要
- **除外理由**: KE-006でFluent API除外込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-021: CQS（コマンド・クエリ分離） → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、正当な例外の許容はKE-007で抽出済み
- 行動変容: × — KE-007の例外条件がないと過剰適用
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-007の例外条件がより重要
- **除外理由**: KE-007で正当な例外込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-022: 散在する条件分岐の構造化 → FILTERED

### フィルタ評価
- 再利用価値: ○ — リファクタリング技法の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、閾値条件はKE-008で抽出済み
- 行動変容: × — KE-008の閾値がないと過剰適用
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-008の閾値条件がより重要
- **除外理由**: KE-008で閾値条件込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-023: ファーストクラスコレクション → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計パターンの基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、適用条件はKE-009で抽出済み
- 行動変容: × — KE-009の適用条件がないと過剰適用
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-009の適用条件がより重要
- **除外理由**: KE-009でビジネスルールの有無による適用条件込みで抽出済み。原則自体の説明は行動変容に寄与しない。

---

## KE-024: AI適用時の注意セクション全体 → FILTERED

### フィルタ評価
- 再利用価値: ○ — AI挙動特性の知見
- 遵守改善効果: 低 — 個別の適用条件はKE-001, 008, 009, 013で抽出済み
- 行動変容: × — 具体的な指示は各原則の適用条件として既に抽出済み
- 確度: ○ — 実証記録されている
- 削除テスト: NO — 個別の適用条件が既に抽出されている
- **除外理由**: このセクションの具体的な適用条件は各原則の抽出項目（KE-001, 008, 009, 013）に含まれている。メタレベルの説明は行動変容に寄与しない。

---

## KE-025: DRY=意図の重複禁止 → FILTERED

### フィルタ評価
- 再利用価値: ○ — 設計原則の基本知識
- 遵守改善効果: 低 — 原則自体はAIが知っているが、目的の一致判断はKE-011で抽出済み
- 行動変容: × — KE-011の判断基準がより具体的
- 確度: ○ — 原則は確立されている
- 削除テスト: NO — KE-011の判断基準がより重要
- **除外理由**: KE-011で目的の一致に基づく共通化判断として抽出済み。DRYの正しい定義自体の説明は行動変容に寄与しない。
