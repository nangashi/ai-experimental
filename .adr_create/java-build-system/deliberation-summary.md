# 審議サマリー

## 決定ステートメント

### 議題
新規開発プロジェクトにおいて、Javaのビルドシステムとしてどのツール/方式を採用するか

### スコープ
- 対象: ビルドシステム（ビルドツール）の選択。依存関係管理、コンパイル、テスト実行、パッケージングを担うツールの決定
- 対象外: IDE の選択、CI/CD パイプラインの構成、デプロイ方式の決定

### 可逆性
medium
ビルドスクリプトの書き換えとプロジェクト構造の調整が必要になるが、Javaソースコード自体はビルドツールに依存しないため再利用可能。ただしプロジェクト規模が大きくなるほど移行コストは増大する。

## 関連する既存決定

### ADR-0001: Java Version Selection for New Project
- 決定: 新規開発プロジェクトで Java 21（LTS）を採用する
- 今回の議題との関連: ビルドシステムの選択は、選択されたJavaバージョン（Java 21）との互換性が前提条件となる。ビルドツールはJavaバージョンをサポートし、そのエコシステム（フレームワーク、ライブラリ）と統合できる必要がある
- 制約への影響:
  - 今回のビルドシステムは Java 21 を確実にサポートしなければならない（Certainty）
  - 選択したビルドツールは Spring Boot 3.x との統合が必要である（ADR-0001のC3, S1から派生）
  - Virtual Threads等のJava 21新機能をビルドプロセスで活用する可能性がある（ADR-0001のS2から派生）
  - OpenJDKディストリビューション経由の無償利用を前提とし、ビルドツールもこれに対応する必要がある（ADR-0001のS3から派生）
  - プロジェクトは長期運用を前提としており、ビルドシステムも長期サポートが必要である（ADR-0001のS4, S10から派生）

## 前提条件（CSD）

### 確実（Certainty）

- C1: Java 21（LTS）を採用済みである — 根拠: ADR-0001で決定済み。ビルドシステムはJava 21を確実にサポートする必要がある
- C2: OpenJDKディストリビューション経由の無償利用を前提とする — 根拠: ADR-0001で決定済み（S3から派生）。ビルドツールもこれに対応する必要がある
- C3: プロジェクトは長期運用を前提としている — 根拠: ADR-0001で決定済み（S4, S10から派生）。ビルドシステムも長期サポートが必要である
- C4: Spring Boot 3.x との統合が必要である — 根拠: ADR-0001のC3, S1から派生。ビルドツールはSpring Boot 3.xのエコシステムと統合できる必要がある
- C5: Gradle は Groovy/Kotlin DSL により柔軟な設定が可能であり、Maven は XML ベースで標準化されている — 根拠: 各ツールの設計上の特性として確実な事実
- C6: プロジェクトの可逆性は medium である — 根拠: decision-statement.md で定義済み。ビルドスクリプトの書き換えとプロジェクト構造の調整が必要だが、Javaソースコード自体はビルドツールに依存しない

### 仮定（Supposition）

- S1: チームはJavaビルドツールの一般的な知識を持っている — 根拠: 新規開発プロジェクトでJava 21を採用済みであり、Java開発の基礎知識があると推定される、検証方法: チームメンバーのスキルセットを確認する
- S2: プロジェクト規模は中規模以上になる見込みである — 根拠: ADR-0001で長期運用を前提としていることから、一定の規模が想定される、検証方法: プロジェクト要件定義や機能リストを確認する
- S3: ビルド時間はプロジェクトの生産性に影響する — 根拠: 一般的な開発プロセスでビルド頻度が高い場合、ビルド時間短縮は開発効率に寄与する、検証方法: 開発フローとビルド頻度を分析する
- S4: 複雑なビルド要件（マルチモジュール、カスタムタスク等）が将来発生する可能性がある — 根拠: 長期運用前提のプロジェクトでは機能追加に伴いビルド要件が複雑化する傾向がある、検証方法: プロジェクト計画や技術要件を確認する
- S5: Gradle のエコシステムは今後も成長を続ける — 根拠: 2026年のコミュニティランキングでトップを獲得、検証方法: コミュニティ動向とプラグインエコシステムの拡大を追跡する
- S6: Maven 4 は近い将来に正式リリースされる — 根拠: Maven 4.0.0-rc-5 がリリース候補として提供されている、検証方法: Maven プロジェクトの公式アナウンスを追跡する
- S7: CI/CD環境でビルドキャッシュを利用可能である — 根拠: 現代的なCI/CD環境ではキャッシュ機能が一般的に提供されている、検証方法: CI/CDプラットフォームの仕様を確認する
- S8: パフォーマンス面では Gradle が Maven より優位である — 根拠: research.md の一般的な計測結果に基づく。ただしプロジェクト固有の条件で結果が変わる可能性がある（元C6、レッドチーム指摘により再分類）、検証方法: プロジェクト固有の条件で実測する
- S9: 現時点で必要なプラグインは Maven/Gradle 両エコシステムで利用可能である — 根拠: 両ツールとも成熟したエコシステムを持つが、プロジェクト固有の要件で確認が必要（元C7、レッドチーム指摘により再分類）、検証方法: 必要なプラグインの存在と互換性を確認する
- S10: チームは Groovy/Kotlin DSL または XML の記述に抵抗がない — 根拠: 暗黙の仮定として検出。特に Kotlin DSL はJava開発者にとって追加学習が必要、検証方法: チームメンバーにDSLサンプルを提示してフィードバックを得る
- S11: プロジェクトは単一のビルドツールに統一される — 根拠: 暗黙の仮定として検出。マイクロサービス等で将来的にビルドツール混在の可能性がある、検証方法: プロジェクトアーキテクチャの将来計画を確認する
- S12: Java 21 の全機能は Gradle/Maven 両方で問題なく利用できる — 根拠: 暗黙の仮定として検出。特に Maven 3.x 系列での Java 21 サポート状況は要確認、検証方法: 各ツールの Java 21 サポート状況を調査する

### 不確実（Doubt）

- D1: チームの Gradle/Maven それぞれの習熟度 — 影響範囲: 学習コスト、初期生産性、保守性、リスク: 不慣れなツールを選択した場合、初期段階で生産性が低下しビルドスクリプトの品質が劣化する可能性がある
- D2: プロジェクトの具体的な規模とビルド頻度 — 影響範囲: パフォーマンス要件の重要度、リスク: 規模が小さくビルド頻度が低い場合、パフォーマンス差が実質的な影響を持たない可能性がある
- D3: 将来的なマルチモジュール化やカスタムビルドタスクの必要性 — 影響範囲: 柔軟性と拡張性の重要度、リスク: 複雑なビルド要件が発生しない場合、Gradleの柔軟性がオーバースペックとなる可能性がある
- D4: Maven 4 正式リリースのタイミングとプラグインエコシステムの移行状況 — 影響範囲: Maven選択時の移行リスク、リスク: Maven 4 が予想より遅れる場合、Maven 3系列での長期運用が必要になる可能性がある
- D5: CI/CD環境の具体的な構成とキャッシュ機能の有無 — 影響範囲: ビルドキャッシュの実効性、リスク: CI/CD環境でキャッシュが利用できない場合、Gradle の Build Cache による優位性が限定的になる可能性がある
- D6: 既存の組織標準やガバナンス要件 — 影響範囲: ツール選択の自由度、リスク: 組織レベルで特定のビルドツールが標準化されている場合、技術的最適解と異なる選択を強いられる可能性がある。**最優先で検証すべき項目**: この仮定が崩れた場合、全ての技術的評価が無意味になる

## 判断基準

優先度の設定は決定者（人間）に委ねられる。

### OBJ-1: 長期的な保守性
- 種別: fundamental（根本目的）
- 定義: ビルドスクリプトの可読性が高く、チームメンバーが容易に理解・修正でき、長期運用においても保守負荷が増大しないこと
- 評価の視点:
  - ビルド定義の可読性と理解しやすさ
  - ドキュメントとコミュニティサポートの充実度
  - ツール自体の長期サポート見込み
  - チームの学習コストと習熟の容易さ

### OBJ-2: ビルドパフォーマンス
- 種別: fundamental（根本目的）
- 定義: 開発中の頻繁なビルドにおいて、ビルド時間が開発生産性のボトルネックにならないこと
- 評価の視点:
  - インクリメンタルビルドの効率性
  - ビルドキャッシュ機能の有効性
  - 並列実行の最適化
  - 大規模プロジェクトでのスケーラビリティ

### OBJ-3: エコシステムとの統合性
- 種別: fundamental（根本目的）
- 定義: Spring Boot 3.x および Java 21 のエコシステムと自然に統合でき、必要なプラグインやツールが利用可能であること
- 評価の視点:
  - Spring Boot 3.x との統合の容易さ
  - Java 21 の全機能のサポート
  - 必要なプラグインの利用可能性と品質
  - IDE およびCI/CDツールとの統合

### OBJ-4: 将来の拡張性
- 種別: fundamental（根本目的）
- 定義: プロジェクトの成長に伴う複雑なビルド要件（マルチモジュール、カスタムタスク等）に柔軟に対応できること
- 評価の視点:
  - マルチモジュール構成への対応力
  - カスタムビルドタスクの実装容易性
  - プラグインエコシステムの成長見込み
  - 複雑なビルドロジックの表現力

### OBJ-5: 標準化と予測可能性
- 種別: fundamental（根本目的）
- 定義: ビルドプロセスが標準的で予測可能であり、チーム間での一貫性が保たれ、暗黙的な動作による混乱が少ないこと
- 評価の視点:
  - デフォルト規約の明確さと広く受け入れられた標準の存在
  - ビルドプロセスの透明性と予測可能性
  - 業界標準としての採用率
  - 過度なカスタマイズによる複雑化のリスク

## 検討した選択肢

### ALT-1: Gradle (Kotlin DSL)
- 概要: Kotlin DSL によるタイプセーフなビルド定義。Build Cache、Configuration Cache、Convention Plugins 等の機能を活用し、パフォーマンスと拡張性を両立する
- 提案元: OBJ-1（保守性：型安全性とIDEサポート）、OBJ-2（パフォーマンス：Build Cache/Configuration Cache）、OBJ-3（統合性：Spring Boot公式サポート）、OBJ-4（拡張性：プログラマティックなビルドロジック）、OBJ-5（標準化：Convention Plugins）

### ALT-2: Maven
- 概要: XML ベースの宣言的ビルド定義。Convention over Configuration の徹底と成熟したエコシステムにより、標準化と保守性を重視する
- 提案元: OBJ-1（保守性：可読性とドキュメント充実）、OBJ-3（統合性：Spring Boot公式第一サポート）、OBJ-5（標準化：業界標準としての実績）

### ALT-3: Gradle (Groovy DSL)
- 概要: Groovy DSL による柔軟なビルド定義。Gradle の伝統的な記述方式で、参考資料が豊富。動的型付けによる簡潔な記述が特徴
- 提案元: OBJ-1（保守性：簡潔な記述）、OBJ-4（拡張性：柔軟なスクリプティング）

### 除外した選択肢
- Bazel: 除外理由 — 学習コストが極めて高く（D1関連）、Spring Boot 3.x の公式プラグインが存在しない（C4制約）。モノレポ・超大規模プロジェクト向けであり、今回のスコープに合致しない
- Buck2: 除外理由 — エコシステムが未成熟で長期サポートが不透明（C3制約）。Spring Boot 3.x の統合が存在しない（C4制約）
- Ant + Ivy: 除外理由 — Spring Boot 3.x の公式統合が存在しない（C4制約）。エコシステムが縮小傾向にあり長期運用に不適（C3制約）

## トレードオフ行列

| 判断基準 | ALT-1: Gradle (Kotlin DSL) | ALT-2: Maven | ALT-3: Gradle (Groovy DSL) |
|----------|---------------------------|--------------|---------------------------|
| OBJ-1: 長期的な保守性 | ○ | ◎ | △ |
| OBJ-2: ビルドパフォーマンス | ◎ | × | ◎ |
| OBJ-3: エコシステムとの統合性 | ◎ | ○ | ◎ |
| OBJ-4: 将来の拡張性 | ◎ | △ | ◎ |
| OBJ-5: 標準化と予測可能性 | ○ | ◎ | △ |

### 各セルの詳細

#### ALT-1 (Gradle Kotlin DSL) × OBJ-1 (長期的な保守性)
- 評価: ○
- 利点: 型安全性によるIDEサポートが強力。補完・エラー検出・リファクタリングが容易。Java開発者にとってKotlinは文法的に近い
- 欠点: DSL自体の学習コストが存在。Gradleの暗黙的な動作（タスク実行順序、キャッシュ挙動等）が混乱の原因となりうる。メジャーバージョンアップ時に破壊的変更のリスク
- 根拠: Kotlin DSLはGroovy DSLより保守性で優れるが、Mavenの20年以上の実績と明確な規約には及ばない

#### ALT-1 (Gradle Kotlin DSL) × OBJ-2 (ビルドパフォーマンス)
- 評価: ◎
- 利点: Build Cache使用時に最大100倍の速度向上。インクリメンタルビルド、並列タスク実行。Configuration Cacheによる設定時間削減。Kotlin DSL最適化で編集フィードバック2.5倍高速化
- 欠点: 初回ビルドではキャッシュなし。CI/CD環境のキャッシュ対応に依存（S7, D5）
- 根拠: 複数の出典で一貫してGradleのパフォーマンス優位性が確認されている。継続的な最適化により優位性は拡大傾向

#### ALT-1 (Gradle Kotlin DSL) × OBJ-3 (エコシステムとの統合性)
- 評価: ◎
- 利点: Spring Boot 3.x公式サポート。Java 21完全互換。IDE統合成熟（IntelliJ IDEA ネイティブサポート）。CI/CDでBuild Cache/Configuration Cache活用可能。Plugin Portal に30,000以上のプラグイン
- 欠点: Kotlin DSLの学習コスト。サードパーティプラグインの品質にばらつき
- 根拠: 2026年のSlantランキングで1位。Spring InitializrでGradle (Kotlin)が選択肢として提供

#### ALT-1 (Gradle Kotlin DSL) × OBJ-4 (将来の拡張性)
- 評価: ◎
- 利点: タイプセーフなカスタムタスク実装。柔軟なマルチモジュール構成。プログラマティックなビルドロジック記述。活発なプラグインエコシステム
- 欠点: 過度なカスタマイズによる保守性低下リスク。S4（複雑なビルド要件の発生）が成立しない場合オーバースペック
- 根拠: Kotlin DSLの型安全性によりリファクタリングに強く、大規模化への対応力が高い

#### ALT-1 (Gradle Kotlin DSL) × OBJ-5 (標準化と予測可能性)
- 評価: ○
- 利点: タイプセーフな設定でビルドスクリプトの誤りをコンパイル時に検出。Convention Pluginsでチーム標準を共通化可能
- 欠点: 規約維持にはチームの規律が必要。業界標準としての認知度はMavenに劣る。Gradleの柔軟性により規約逸脱が可能
- 根拠: Convention Pluginsで標準化を実現可能だが、Mavenの「制約による標準化」とは本質的に異なるアプローチ

#### ALT-2 (Maven) × OBJ-1 (長期的な保守性)
- 評価: ◎
- 利点: XMLの明確な構造。20年以上のドキュメント・コミュニティ蓄積。Apache Software Foundationによる長期サポート保証。規約重視で暗黙的動作が少ない
- 欠点: 大規模化するとpom.xmlが冗長化。カスタマイズにプラグイン開発が必要で保守対象増加
- 根拠: Mavenの設計思想「規約による標準化」が長期的な保守性の観点で最も有利

#### ALT-2 (Maven) × OBJ-2 (ビルドパフォーマンス)
- 評価: ×
- 利点: 安定した動作。Maven Daemon（プレビュー版）によるJVM起動コスト削減の可能性
- 欠点: Gradleの2倍以上遅い。インクリメンタルビルド・ビルドキャッシュの最適化がGradleに大幅に劣る。Maven Daemonは未成熟
- 根拠: 複数の出典で一貫してMavenのパフォーマンスがGradleに劣ることが確認。ただしD2（規模・ビルド頻度）次第で影響度は変動

#### ALT-2 (Maven) × OBJ-3 (エコシステムとの統合性)
- 評価: ○
- 利点: Spring Boot 3.x公式ドキュメントでMavenが第一にサポート。Java 21サポート確立。成熟したプラグインエコシステム。IDE・CI/CDの標準サポート
- 欠点: Maven 4移行時のプラグイン互換性問題。カスタムプラグイン開発がGradleより煩雑
- 根拠: Spring InitializrでMavenがデフォルト選択肢。Maven Centralが事実上の標準リポジトリ

#### ALT-2 (Maven) × OBJ-4 (将来の拡張性)
- 評価: △
- 利点: 成熟したマルチモジュールサポート。標準的なプラグイン機構
- 欠点: 複雑なビルドロジックの表現力が限定的。カスタムタスクにJavaプラグイン開発が必要（高コスト）。大規模化でpom.xml冗長化
- 根拠: Maven 4で新機能追加が期待されるが、Gradleのスクリプト内カスタマイズの柔軟性には及ばない

#### ALT-2 (Maven) × OBJ-5 (標準化と予測可能性)
- 評価: ◎
- 利点: Convention over Configurationの徹底。業界標準のプロジェクト構造。宣言的な設定による予測可能性。単一の中央リポジトリ。カスタマイズ制限が標準化を保証
- 欠点: 柔軟性の低さ（他目的とのトレードオフ）
- 根拠: 「標準化と予測可能性」に対してMavenの設計思想が最も直接的に対応

#### ALT-3 (Gradle Groovy DSL) × OBJ-1 (長期的な保守性)
- 評価: △
- 利点: 簡潔な記述が可能。成熟したサンプルコード・プラグインが豊富
- 欠点: 型安全性の欠如でIDE補完が弱い。Gradleの方針転換によりKotlin DSLが推奨に。長期サポート見込みが不透明
- 根拠: Kotlin DSLへの移行推奨傾向があり、新規プロジェクトでGroovy DSLを選択するリスクが増大

#### ALT-3 (Gradle Groovy DSL) × OBJ-2 (ビルドパフォーマンス)
- 評価: ◎
- 利点: ALT-1と同様のGradleパフォーマンス基盤（Build Cache、インクリメンタルビルド、並列実行）を享受
- 欠点: Configuration Cache の一部最適化はKotlin DSLに特化。ALT-1と同じCI/CD依存
- 根拠: ビルドパフォーマンスはDSL選択よりGradleエンジン自体の特性に依存。Kotlin DSLとほぼ同等

#### ALT-3 (Gradle Groovy DSL) × OBJ-3 (エコシステムとの統合性)
- 評価: ◎
- 利点: ALT-1と同様のGradleエコシステム統合。歴史的にGroovy DSLのサンプルが多い
- 欠点: Kotlin DSLへの移行推奨により、新しいプラグインのドキュメントがKotlin DSL中心になりつつある
- 根拠: エコシステム統合はGradle本体の特性。DSL選択による差異は限定的

#### ALT-3 (Gradle Groovy DSL) × OBJ-4 (将来の拡張性)
- 評価: ◎
- 利点: 動的型付けによる高い柔軟性。カスタムタスク実装がシンプル。スクリプト的な記述が可能
- 欠点: 型安全性の欠如で大規模化時の保守性リスク。Kotlin DSLへのマイグレーション推奨傾向
- 根拠: 柔軟性ではGroovy DSLがKotlin DSLと同等以上だが、型安全性の欠如が大規模化時のリスク

#### ALT-3 (Gradle Groovy DSL) × OBJ-5 (標準化と予測可能性)
- 評価: △
- 利点: Gradleのデフォルト形態として既存ドキュメントが豊富
- 欠点: 動的型付けでランタイムまでエラー未検出。過度なカスタマイズリスクが最も高い。規約が弱くプロジェクト間の一貫性が保ちにくい
- 根拠: 標準化の観点では最もリスクが高い選択肢。Gradleの柔軟性が裏目に出る

## 判断ガイド

以下は条件付きの帰結の提示であり、推奨ではない。
最終的な優先順位の決定は判断者に委ねられる。

- **長期的な保守性（OBJ-1）と標準化（OBJ-5）を最優先するなら** → ALT-2 (Maven) が適している。20年以上の実績、Apache Foundation による長期サポート保証、業界標準としての一貫性により、保守性と予測可能性で最も優れている。ただし、ビルドパフォーマンス（OBJ-2）は著しく劣り、将来の拡張性（OBJ-4）にも制約がある。

- **ビルドパフォーマンス（OBJ-2）と将来の拡張性（OBJ-4）を最優先するなら** → ALT-1 (Gradle Kotlin DSL) が適している。Build Cache による最大100倍の速度向上、タイプセーフなカスタムタスク実装、柔軟なマルチモジュール構成により、パフォーマンスと拡張性で最も優れている。ただし、長期的な保守性（OBJ-1）と標準化（OBJ-5）では Maven に劣る。

- **バランスを取るなら** → ALT-1 (Gradle Kotlin DSL) と ALT-2 (Maven) の二択。ALT-3 (Gradle Groovy DSL) は、Kotlin DSL への移行推奨傾向により長期サポート見込みが不透明（OBJ-1: △）、標準化リスクが最も高い（OBJ-5: △）ため推奨しにくい。

### 重要な考慮点

1. **D6（組織標準）の検証が最優先**: 既存の組織標準やガバナンス要件が存在する場合、全ての技術的評価が無意味になる可能性がある。技術的検討の前に必ず確認すべき。

2. **プロジェクト特性による影響**:
   - D2（規模・ビルド頻度）が小規模の場合 → パフォーマンス差（OBJ-2）の影響は限定的になり、Maven の欠点が緩和される
   - D3（複雑なビルド要件の必要性）が低い場合 → Gradle の拡張性（OBJ-4）の優位性が過剰スペックとなり、Maven の簡潔性が優位になる
   - D1（チーム習熟度）が Maven 寄りの場合 → 学習コスト（OBJ-1）で Maven が有利になる

3. **CI/CD環境の影響**: D5（CI/CD環境のキャッシュ機能）が利用不可の場合、Gradle の Build Cache による優位性が限定的になり、パフォーマンス差は縮小する。

## 不確実性の影響

以下の不確実性が判明した場合、選択肢の評価が変化する可能性がある。

- **D1（チームの習熟度）が判明した場合**:
  - チームが Maven 経験豊富 → Maven の保守性（OBJ-1）が相対的に向上。学習コストが最小化される
  - チームが Gradle 経験豊富 → Gradle Kotlin DSL の保守性（OBJ-1）が相対的に向上。学習コストが軽減される
  - チームが両方未経験 → 学習曲線の差が顕著になり、Maven の可読性・ドキュメント充実度が優位に働く

- **D2（プロジェクトの規模とビルド頻度）が判明した場合**:
  - 小規模・低頻度 → Maven のパフォーマンス劣性（OBJ-2: ×）の影響が限定的になり、実質的な差異が小さくなる。保守性（OBJ-1）が相対的に重要度を増す
  - 大規模・高頻度 → Gradle のパフォーマンス優位性（OBJ-2: ◎）が決定的に重要になり、ビルド時間がチーム生産性に直結する。Maven は現実的選択肢から外れる可能性

- **D3（複雑なビルド要件の必要性）が判明した場合**:
  - 複雑なビルド要件が確実に発生 → Gradle の拡張性（OBJ-4: ◎）の価値が高まり、Maven の制約（OBJ-4: △）が深刻な問題となる
  - 複雑なビルド要件が発生しない → Gradle の柔軟性がオーバースペックとなり、Maven の「制約による標準化」（OBJ-5: ◎）が魅力的になる

- **D4（Maven 4 リリース）が判明した場合**:
  - 近い将来に正式リリース → Maven のパフォーマンス改善（Maven Daemon 等）により OBJ-2 の評価が × → △ に改善される可能性
  - リリースが遅延 → Maven 3.x での長期運用が必要になり、現状のパフォーマンス劣性（OBJ-2: ×）が固定化される

- **D5（CI/CD環境のキャッシュ機能）が判明した場合**:
  - キャッシュ利用可能 → Gradle の Build Cache が活用でき、パフォーマンス優位性（OBJ-2: ◎）が最大化される
  - キャッシュ利用不可 → Gradle のパフォーマンス優位性が縮小し、Maven との差が相対的に小さくなる。ただし依然として Gradle が優位

- **D6（組織標準）が判明した場合**:
  - 組織レベルで Maven 標準化 → 技術的評価に関わらず Maven を採用。ガバナンス要件が技術的最適性を上回る
  - 組織レベルで Gradle 標準化 → 技術的評価に関わらず Gradle を採用
  - 組織標準なし → 技術的評価に基づく自由な選択が可能。本審議の全評価が有効
