# OBJ-1: 長期的な保守性 — 評価結果

## 提案した代替案

### Maven（標準 XML 方式）
- 理由: ビルド定義の可読性と理解しやすさを最優先する観点から提案。XML ベースの設定は構造が明確で、チーム間での理解が統一しやすい。規約重視のアプローチにより、暗黙的な動作が少なく、長期運用における予測可能性が高い。ドキュメントとコミュニティサポートが非常に充実しており、Apache Software Foundation によるガバナンスにより長期サポートの見込みが高い。

### Gradle（Kotlin DSL 方式）
- 理由: チームの学習コストと習熟の容易性を重視する観点から提案。Java 開発者にとって Kotlin は文法的に近く、Groovy DSL よりも学習曲線が緩やか。型安全性により IDE のサポートが強力で、ビルドスクリプトの保守性が向上する。ただし DSL 自体の学習コストは存在するため、長期的な保守性への貢献は条件付き。

### Gradle（Groovy DSL 方式）
- 理由: 柔軟性と表現力を重視する観点から提案。複雑なビルドロジックを簡潔に記述できるため、ビルドスクリプトの行数が減少し、可読性が向上する可能性がある。ただし Groovy の動的型付けにより、IDE のサポートが Kotlin DSL に比べて弱く、保守性の観点からは劣る。

## 評価

### Maven（標準 XML 方式）

- 評価: ◎
- 利点:
  - **ビルド定義の可読性**: XML は構造が明確で、タグの階層により依存関係やプラグイン設定が視覚的に理解しやすい。Java 開発者にとって XML の読み書きは一般的であり、特別な学習コストがかからない
  - **ドキュメントとコミュニティサポート**: Apache Maven プロジェクトは20年以上の歴史を持ち、公式ドキュメント、書籍、Stack Overflow の情報が極めて豊富。トラブルシューティングが容易
  - **長期サポートの見込み**: Apache Software Foundation の成熟したガバナンスにより、長期的なサポートとバージョン互換性が保証されている。Maven 4 のリリース候補が存在し、今後も継続的な開発が見込まれる（research.md: Maven 4.0.0-rc-5）
  - **標準化と予測可能性**: 規約重視（Convention over Configuration）により、デフォルトの動作が明確。暗黙的な振る舞いが少なく、チームメンバーが予測可能な形でビルドスクリプトを理解できる
- 欠点:
  - **XML の冗長性**: プロジェクトが大規模化すると、pom.xml が冗長になり、可読性が低下する可能性がある（research.md: 大規模プロジェクトでは設定ファイルが冗長になる傾向）
  - **カスタマイズの困難性**: 複雑なビルドロジックを実装する場合、Maven プラグインの開発が必要となり、保守対象が増える可能性がある
- 根拠: Maven の設計思想は「規約による標準化」であり、これは長期的な保守性の観点から非常に有利。XML 形式は記述が冗長になる傾向があるものの、構造が明確であり、チームメンバーの理解が統一しやすい。Apache Software Foundation のガバナンスと20年以上の実績により、長期サポートの信頼性が高い
- CSD依存:
  - S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）: XML に対する抵抗感がない場合、Maven の保守性の利点が最大限発揮される。逆に XML を嫌うチームでは、保守意欲の低下により保守性が劣化する可能性がある
  - S1（チームはJavaビルドツールの一般的な知識を持っている）: Maven の基本的な理解があれば、学習コストは最小限で済む

### Gradle（Kotlin DSL 方式）

- 評価: ○
- 利点:
  - **型安全性と IDE サポート**: Kotlin DSL は型安全であり、IntelliJ IDEA や Eclipse での補完・エラー検出が強力。ビルドスクリプトのリファクタリングが容易で、保守性が向上する
  - **Java 開発者との親和性**: Java 開発者にとって Kotlin は文法的に近く、Groovy DSL に比べて学習曲線が緩やか。チームの習熟が比較的容易
  - **ドキュメントとコミュニティ**: Gradle の公式ドキュメントは充実しており、Kotlin DSL のサンプルも豊富。2026年のコミュニティランキングでトップを獲得しており、今後もサポートの拡大が見込まれる（research.md: 2026年の Slant コミュニティランキングで Gradle が1位）
- 欠点:
  - **DSL 学習コスト**: Kotlin の文法自体は Java 開発者にとって理解しやすいが、Gradle の DSL 概念（依存関係の構成、タスクのグラフ構造等）は独自の学習が必要。初期段階での生産性低下のリスクがある
  - **暗黙的な動作**: Gradle は規約よりも柔軟性を重視しており、タスクの実行順序やビルドキャッシュの挙動等、暗黙的な動作が多い。これが長期運用における混乱の原因となる可能性がある
  - **バージョン間の互換性**: Gradle はメジャーバージョンアップ時に破壊的変更を含むことがあり、長期運用における移行コストが発生する可能性がある
- 根拠: Kotlin DSL は型安全性により IDE のサポートが強力で、保守性の観点から Groovy DSL より優れている。ただし Gradle の DSL 自体の学習コストと、規約よりも柔軟性を重視する設計思想により、Maven に比べて長期的な保守性の予測可能性は劣る。コミュニティの成長は顕著だが、Maven の20年以上の実績には及ばない
- CSD依存:
  - S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）: Kotlin DSL に対する抵抗感がない場合、型安全性の利点が最大限発揮される
  - D1（チームの Gradle/Maven それぞれの習熟度）: Gradle に精通したメンバーがいる場合、学習コストが大幅に削減され、保守性が向上する。逆に Gradle 未経験のチームでは、初期段階での生産性低下と、ビルドスクリプトの品質劣化のリスクが高まる

### Gradle（Groovy DSL 方式）

- 評価: △
- 利点:
  - **簡潔な記述**: Groovy の動的型付けにより、ビルドスクリプトを簡潔に記述できる。冗長性が少なく、可読性が向上する可能性がある
  - **柔軟性**: 複雑なビルドロジックを自然に表現できるため、カスタムタスクの実装が容易。長期運用において特殊な要件が発生した場合に対応しやすい
  - **成熟したエコシステム**: Gradle の歴史的なデフォルト方式であり、サンプルコードやプラグインの多くが Groovy DSL ベース。情報の入手が比較的容易
- 欠点:
  - **型安全性の欠如**: Groovy の動的型付けにより、IDE の補完・エラー検出が Kotlin DSL に比べて弱い。ビルドスクリプトの保守性が劣化する
  - **学習コスト**: Java 開発者にとって Groovy の文法は馴染みが薄く、Kotlin DSL に比べて学習曲線が急。チームの習熟に時間がかかる
  - **Gradle の方針転換**: Gradle プロジェクトは Kotlin DSL を推奨方式としており、Groovy DSL は今後のサポートが縮小する可能性がある。長期的なサポート見込みが不透明
- 根拠: Groovy DSL は簡潔な記述が可能だが、型安全性の欠如により IDE のサポートが弱く、保守性の観点から Kotlin DSL に劣る。Gradle プロジェクトの方針転換により、今後 Kotlin DSL が主流となる可能性が高く、Groovy DSL の長期サポート見込みが不透明。長期的な保守性を重視する観点からは懸念が大きい
- CSD依存:
  - S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）: Groovy DSL に対する抵抗感がない場合でも、型安全性の欠如による保守性の低下は避けられない
  - D1（チームの Gradle/Maven それぞれの習熟度）: Groovy に精通したメンバーがいる場合、学習コストは削減されるが、型安全性の欠如による長期的な保守性の問題は残る

### Bazel

- 評価: ×
- 利点:
  - **長期的なサポート見込み**: Google が開発・維持しており、Google の内部ツールとして広く使用されている。長期的なサポートの信頼性は高い
  - **大規模プロジェクトでの実績**: モノレポ構成や超大規模プロジェクトでの保守性に優れている
- 欠点:
  - **学習コストが極めて高い**: Bazel 独自の概念（BUILD ファイル、WORKSPACE、ルール定義等）を習得する必要があり、チームの習熟に長期間を要する
  - **ドキュメントとコミュニティ**: Maven/Gradle に比べてドキュメントとコミュニティサポートが限定的。特に日本語の情報が少なく、トラブルシューティングが困難
  - **Java エコシステムとの統合**: Bazel は多言語対応を重視しており、Java 固有のエコシステム（Spring Boot, Maven Central 等）との統合が Maven/Gradle に比べて煩雑。保守負荷が増大する可能性がある
  - **ツール自体の複雑性**: Bazel の設定ファイルは BUILD と WORKSPACE に分離され、依存関係の記述が冗長。可読性が低下する
- 根拠: Bazel は Google が開発する信頼性の高いツールだが、学習コストが極めて高く、チームメンバーが容易に理解・修正できる状態にするまでの時間が長大。Java エコシステムとの統合も煩雑であり、長期運用における保守負荷が増大するリスクが高い。モノレポや超大規模プロジェクトでない限り、長期的な保守性の観点から適していない
- CSD依存:
  - D1（チームの Gradle/Maven それぞれの習熟度）: Bazel に精通したメンバーがいない限り、学習コストと保守負荷が極めて高い
  - S2（プロジェクト規模は中規模以上になる見込みである）: 超大規模プロジェクトでない限り、Bazel の複雑性は保守性を阻害する要因となる

### Buck2

- 評価: ×
- 利点:
  - **パフォーマンス**: Buck1 の2倍の速度でビルドを完了する（research.md: Meta の内部テストで Buck1 の2倍の速度）
  - **モダンな設計**: Rust で記述され、関数型評価モデルを採用
- 欠点:
  - **エコシステムの未成熟**: 若いツールであり、コミュニティとエコシステムの成長が今後の鍵となる（research.md: エンタープライズユースケースを置き換えるには早期段階）
  - **ドキュメントとサポートの不足**: Maven/Gradle に比べてドキュメントが限定的であり、コミュニティサポートも未成熟。トラブルシューティングが困難
  - **長期サポートの不透明性**: Meta の社内ツールとして開発されており、オープンソースプロジェクトとしての長期的なガバナンスとサポート体制が不透明
  - **学習コスト**: Starlark を使用し Bazel と類似しているが、ルール定義 API は Bazel と互換性がないため、独自の学習が必要
- 根拠: Buck2 はモダンな設計とパフォーマンスの優位性を持つが、エコシステムが未成熟であり、ドキュメントとコミュニティサポートが限定的。長期サポートの見込みも不透明であり、長期的な保守性の観点から採用リスクが極めて高い
- CSD依存:
  - C3（プロジェクトは長期運用を前提としている）: 長期運用前提のプロジェクトにおいて、長期サポートの不透明性は致命的なリスク
