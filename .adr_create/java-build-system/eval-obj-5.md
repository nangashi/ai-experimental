# OBJ-5: 標準化と予測可能性 — 評価結果

## 提案した代替案

- **Maven**: 標準化と予測可能性の観点で最適。XML ベースの宣言的な設定、Convention over Configuration の徹底、業界標準としての長年の実績により、チーム間での一貫性が保たれ、予測可能なビルドプロセスを実現できる。Maven Central という単一の中央リポジトリ、標準的なプロジェクト構造（src/main/java 等）、標準ライフサイクル（compile, test, package 等）により、プロジェクト間の移動やオンボーディングが容易。

- **Gradle with Kotlin DSL + Convention Plugins**: Gradle の柔軟性を保ちつつ、規約を徹底することで予測可能性を向上させるアプローチ。Convention Plugins でチーム標準のビルドロジックを共通化し、Kotlin DSL でタイプセーフな設定を強制することで、過度なカスタマイズを抑制できる。ただし Maven と比較すると、規約の維持にはチーム側の規律が必要。

- **Gradle with Groovy DSL**: Gradle の標準的な利用形態。柔軟性が高い反面、標準化と予測可能性の観点では課題がある。Groovy の動的型付けにより、ビルドスクリプトの誤りがランタイムまで検出されず、カスタマイズの自由度が高すぎることで、プロジェクトごとにビルド定義が大きく異なるリスクがある。

## 評価

### Maven

- 評価: ◎
- 利点:
  - **規約の明確さと一貫性**: Convention over Configuration の徹底により、プロジェクト構造とビルドプロセスが標準化されている。src/main/java, src/test/java 等のディレクトリ構造、compile → test → package の標準ライフサイクルは広く知られており、新規参加者のオンボーディングが容易
  - **業界標準としての実績**: Java エコシステムで最も長く使われてきたビルドツールであり、2026年時点でも多くのエンタープライズプロジェクトで採用されている。Maven プロジェクトの構造は事実上の業界標準として認識されており、チーム間の移動やオープンソースプロジェクトへの参加が容易
  - **宣言的な設定による予測可能性**: XML ベースの pom.xml は宣言的であり、「何をするか」を記述する。実行順序や依存関係の解決ロジックは Maven 本体が保証するため、ビルドプロセスの動作が予測しやすい
  - **単一の中央リポジトリ**: Maven Central が事実上の標準リポジトリとして機能しており、依存関係の解決が一貫している。リポジトリの設定ミスによる予期しない動作が発生しにくい
  - **カスタマイズの制限が予測可能性を保証**: Maven はカスタマイズが困難であるため、過度に複雑化したビルドスクリプトが生まれにくい。これは一見制約に見えるが、標準化の観点では利点となる
- 欠点:
  - **柔軟性の低さ**: 標準的な構造から外れた要件（非標準的なディレクトリ構成、複雑なビルドロジック）への対応が困難。これは標準化の裏返しであり、この目的の観点では欠点とは言い難いが、他の目的（OBJ-4: 将来の拡張性）とのトレードオフとなる
- 根拠:
  - Research.md の「Maven は XML ベースで標準化されている」という記述、および長年のエコシステム実績
  - CSD-final の C5（Maven は XML ベースで標準化されている）が確実な事実として確認されている
  - objectives.md の「業界標準としての採用率」「デフォルト規約の明確さと広く受け入れられた標準の存在」という評価視点に対し、Maven は最も高い水準で対応している
- CSD依存: なし

### Gradle with Kotlin DSL + Convention Plugins

- 評価: ○
- 利点:
  - **タイプセーフな設定**: Kotlin DSL により、ビルドスクリプトの記述ミスがコンパイル時に検出される。Groovy DSL と比較して予測可能性が向上
  - **規約の共通化が可能**: Convention Plugins を使用することで、チーム標準のビルドロジックを共通化し、プロジェクト間での一貫性を保つことができる。これにより、Gradle の柔軟性を維持しつつ、標準化を実現できる
  - **IDE サポートの強化**: Kotlin DSL は IntelliJ IDEA 等の IDE で補完やナビゲーションが効きやすく、ビルドスクリプトの理解と編集が容易
- 欠点:
  - **規約の維持にはチームの規律が必要**: Convention Plugins を導入しても、それを遵守するかはチーム次第。Gradle の柔軟性により、規約を逸脱したカスタマイズが可能であるため、標準化を維持するにはレビュープロセスやガバナンスが必要
  - **業界標準としての認知度は Maven に劣る**: Kotlin DSL は比較的新しい選択肢であり、Groovy DSL ほど広く普及していない。チーム間の移動やオープンソースプロジェクトでの採用例は Maven に及ばない
  - **学習コストの追加**: Kotlin DSL の習得には追加の学習コストがかかる。S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）が仮定であり、Kotlin DSL が未経験の場合は初期の生産性低下が懸念される
- 根拠:
  - Gradle の Kotlin DSL はタイプセーフであり、ビルドロジックのエラーを早期に検出できる（技術的事実）
  - ただし、規約の維持にはチーム側の規律が必要であり、Maven のような「制約による標準化」ではない
  - CSD-final の S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）が仮定であり、Kotlin DSL の習熟度が不確実
- CSD依存: S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）— Kotlin DSL が未経験の場合、学習コストが発生し初期段階での標準化が困難になる可能性がある

### Gradle with Groovy DSL

- 評価: △
- 利点:
  - **Gradle のデフォルト形態**: Groovy DSL は Gradle の伝統的な設定形式であり、既存のプロジェクトやドキュメントの多くが Groovy DSL を使用している。エコシステムとの互換性が高い
  - **柔軟性による適応力**: 非標準的な要件にも対応可能であり、将来の変化に適応しやすい。ただし標準化の観点ではこれは両刃の剣
- 欠点:
  - **動的型付けによる予測可能性の低下**: Groovy は動的型付け言語であり、ビルドスクリプトの誤りがランタイムまで検出されない。これにより、ビルドプロセスの動作が予測しにくくなる
  - **過度なカスタマイズのリスク**: Gradle の柔軟性により、プロジェクトごとにビルド定義が大きく異なる可能性がある。「過度なカスタマイズによる複雑化のリスク」（objectives.md の評価視点）が最も高い選択肢
  - **規約の弱さ**: Maven の Convention over Configuration と比較して、Gradle はデフォルト規約が弱く、プロジェクト構造やビルドプロセスがプロジェクトごとに異なりやすい
  - **ビルドプロセスの透明性が低い**: Gradle は設定フェーズと実行フェーズが分離され、タスクグラフの動的構築により、ビルドプロセスの動作を理解するのが難しい。Maven の宣言的なライフサイクルと比較して、予測可能性が劣る
- 根拠:
  - Groovy の動的型付けは言語の特性として確実な事実（CSD-final の C5 に含意される）
  - Research.md の「Gradle は Groovy または Kotlin DSL を使用し、簡潔なビルドスクリプトを記述可能」という記述は柔軟性を示すが、標準化の観点では課題となる
  - objectives.md の「過度なカスタマイズによる複雑化のリスク」という評価視点に対し、Groovy DSL は最もリスクが高い
- CSD依存: S10（チームは Groovy/Kotlin DSL または XML の記述に抵抗がない）— Groovy DSL が未経験の場合、動的型付けの特性により、誤ったビルドスクリプトを作成しても気づきにくく、標準化が困難になる可能性がある
