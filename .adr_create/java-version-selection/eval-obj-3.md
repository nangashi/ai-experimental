# OBJ-3: チームの学習コストと生産性 — 評価結果

## 提案した代替案

- **Java 17**: チームの既存スキルセット（Java 8/11）から最も段階的な移行が可能。Records、Sealed Classes、Pattern Matchingなどの新機能は革新的だが、学習曲線は緩やか。Spring Boot 3の最小要件でもあり、フレームワークとの整合性が高く、教育リソース（公式ドキュメント、コミュニティQ&A）が最も充実している。
- **Java 11**: 既存のJava 8経験からの延長線上で学習負荷が最小。Java 8からの移行事例が豊富で、社内にも知見が蓄積されている可能性が高い。新機能はHTTP Client、Local-Variable Syntax for Lambda等に限定され、習得項目が少ない。
- **Java 21**: Virtual Threadsという革新的な並行処理モデルの導入により、チームは新しい概念（構造化並行性、軽量スレッド）を学習する必要がある。Records、Pattern Matching、Sealed Classesに加え、String Templates等の追加機能も習得対象。教育リソースはJava 17比で少ないが、2024年リリースのため2026年時点では情報が蓄積されつつある。学習コストは高いが、習得後の生産性向上（特に並行処理）の可能性も大きい。

## 評価

### Java 11

- 評価: △
- 利点:
  - 既存スキルセット（Java 8）からの学習コストが最小。HTTP Client、var等の新機能は限定的で習得が容易
  - 長期間使用された実績があり、社内ナレッジが蓄積されている可能性が高い
  - 教育リソース（書籍、研修、Q&A）が豊富で、トラブルシューティング情報も充実
  - 開発初期段階で新機能習得による生産性低下リスクがほぼゼロ
- 欠点:
  - Spring Boot 3を使用する場合は選択不可（C3: Spring Boot 3.xはJava 17を最小要件とする）
  - 新機能が限定的で、モダンなJavaの開発パターン（Records、Pattern Matching等）を習得できず、将来のバージョン移行時の学習コストが後送りされる
  - 2026年9月にOracle JDKのEOLを迎えるため、プロジェクト開始直後にディストリビューション変更やバージョン移行を検討する必要があり、逆に学習負荷が増大するリスク
- 根拠: research.mdでJava 11のEOL（2026年9月）とSpring Boot 3の最小要件（Java 17）が明示されている。S1（Spring Boot等のフレームワーク使用）が成立する場合、制約C3により実質的に除外される
- CSD依存: S1が成立する場合、C3により除外される。S1が成立しない場合も、D1（サードパーティライブラリのJava 21/25互換性）の懸念が低減する一方、最新エコシステムへの追従が困難になる

### Java 17

- 評価: ◎
- 利点:
  - Java 8/11からの段階的な学習経路が確立されている。Records、Sealed Classes、Pattern Matchingは概念的に新しいが、既存のJavaの延長として理解しやすい
  - Spring Boot 3の最小要件であり、フレームワークとの整合性が高い。フレームワークのドキュメントやサンプルコードがJava 17を前提としているため、学習時の参照情報が豊富
  - 2021年リリースで2026年時点では5年の実績があり、教育リソース（書籍、オンライン研修、Qiita/Stack Overflowの情報）が最も充実
  - 新機能（Records、Pattern Matching等）は生産性向上に寄与するが、段階的な採用が可能で強制ではない。既存のJavaスタイルでも開発可能
  - Premier Supportが2026年まで、Extended Supportが2029年9月まで継続し、学習投資が長期的に有効
- 欠点:
  - Java 8/11からの移行では、Records、Sealed Classes、Pattern Matchingの習得が必要。特にパターンマッチングは従来のif-else/switchとは異なる思考が必要
  - Text Blocksやvar等の構文糖衣的な機能の習得も必要（ただし習得難易度は低い）
- 根拠: research.mdでSpring Boot 3がJava 17を最小要件とすることが確認され、Java 17の教育リソースが最も充実していることが推測される。Java 17は2021年リリースで2026年時点で成熟期にあり、コミュニティの知見蓄積が最大
- CSD依存: S1（フレームワーク使用）が成立する場合、C3によりJava 17以上が必須となり選択肢として強化される。D2（学習コスト許容度と教育リソース）の不確実性が低い場合（リソースが確保できる場合）、評価は維持される

### Java 21

- 評価: ○
- 利点:
  - Virtual Threadsは概念的に新しいが、既存の並行処理（ExecutorService、Thread）の知識があれば理解の基盤がある。軽量スレッドによりコード記述が簡潔になり、習得後の生産性向上が期待できる
  - Records、Pattern Matching、Sealed Classes等はJava 17の延長として習得可能
  - String Templates、Sequenced Collections等の新機能は開発効率を向上させる（習得後）
  - 2024年リリースで2026年時点では2年の実績があり、教育リソースが蓄積されつつある。公式ドキュメントは充実
- 欠点:
  - Virtual Threadsの習得には構造化並行性（Structured Concurrency）の理解が必要で、従来のスレッドプールとは異なる設計思想を学ぶ必要がある。D4（並行処理要件の規模）が小さい場合、学習投資対効果が低い
  - Java 17比で追加機能が多く、全機能を習得する場合の学習コストが高い。特にPattern Matching for switch、Record Patterns等の高度な機能は習得に時間がかかる
  - 教育リソースはJava 17比で少ない。特に日本語の書籍や研修は限定的（2026年時点）
  - 開発初期段階で新機能の理解不足による生産性低下のリスクがある（S5: チームがJava 17以降未習熟の場合）
- 根拠: research.mdでVirtual Threadsが並行処理で有効と報告されているが、S2（Virtual Threadsが有効に機能する）およびD4（並行処理要件の規模）に依存する。教育リソースはJava 17より少ない
- CSD依存:
  - S2（Virtual Threadsが有効に機能する）が崩れる場合、Virtual Threads習得の投資対効果が低下し評価が△に低下
  - D4（並行処理要件の規模）が小さいことが判明した場合、Virtual Threadsの学習投資が正当化されず評価が△に低下
  - S5（チームがJava 8/11経験のみ）が正しい場合、学習コストの高さが顕在化し、開発初期の生産性低下リスクが増大
  - D2（学習コスト許容度と教育リソース）が厳しいことが判明した場合（時間・予算が限定的）、評価が△に低下

### Java 25

- 評価: ×
- 利点:
  - 最新LTSで長期サポートが保証される
  - Java 21の全機能に加え、最新の言語機能を利用できる（習得後）
- 欠点:
  - 2025年9月リリースで2026年2月時点ではリリース後5ヶ月。教育リソース（書籍、研修、コミュニティQ&A）がほぼ存在しない
  - D6（Java 25のエコシステム成熟度）の不確実性が高く、ツール・ライブラリ・IDE・ドキュメントの整備状況が不明。トラブルシューティング情報が不足し、問題発生時の解決コストが高い
  - チームがJava 8/11経験のみ（S5）の場合、Java 17→21→25の累積的な学習が必要で、学習コストが極めて高い
  - 開発初期段階で未知の問題に遭遇するリスクが高く、生産性が大幅に低下する可能性
  - 社内に知見がなく、外部の教育リソースも限定的なため、チーム内でのナレッジ共有が困難
- 根拠: research.mdでJava 25が2025年9月リリースと確認され、2026年2月時点では極めて新しい。D6（エコシステム成熟度）の不確実性により、学習リソース不足のリスクが極めて高い
- CSD依存:
  - D6（Java 25のエコシステム成熟度）が低いことが判明した場合、教育リソース不足が確定し評価維持（早期採用リスクが現実化）
  - S5（チームがJava 8/11経験のみ）が正しい場合、累積的な学習負荷が極めて高く、プロジェクト初期の生産性低下リスクが深刻化
  - D2（学習コスト許容度）が厳しい場合、早期採用による学習投資が許容されず、評価維持
